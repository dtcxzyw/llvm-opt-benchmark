; ModuleID = 'bench/qemu/original/block.c.ll'
source_filename = "bench/qemu/original/block.c.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.anon.10 = type { ptr }
%union.anon.11 = type { %struct.QTailQLink }
%struct.QTailQLink = type { ptr, ptr }
%struct.QEnumLookup = type { ptr, ptr, i32 }
%struct.BlockDriver = type { ptr, i32, i8, i8, i8, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.anon.9, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.anon.9 = type { ptr, ptr }
%struct.BdrvChildClass = type { i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%union.anon.16 = type { %struct.QTailQLink }
%struct.QemuOptDesc = type { ptr, i32, ptr, ptr }
%struct.TransactionActionDrv = type { ptr, ptr, ptr }
%struct.perm_name = type { i64, ptr }
%union.anon.20 = type { %struct.QTailQLink }
%struct.QemuMutex = type { %union.pthread_mutex_t, i8 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.QemuEvent = type { i32, i8 }
%struct.BlockDriverState = type { i32, i8, i8, i8, i8, i8, ptr, ptr, ptr, %struct.anon, i8, [4096 x i8], [4096 x i8], [4096 x i8], [16 x i8], ptr, [4096 x i8], %struct.BlockLimits, i32, i32, i32, i32, [32 x i8], %union.anon, %union.anon.0, %union.anon.1, i32, [16 x %struct.anon.2], ptr, %struct.anon.3, ptr, ptr, %struct.anon.4, ptr, ptr, i32, ptr, i64, i64, %struct.QemuMutex, %struct.anon.5, %struct.Stat64, i32, i32, i32, i32, i32, i32, %struct.QemuMutex, %struct.anon.6, %struct.CoQueue, i8, i32, i8, %struct.CoMutex, ptr, ptr }
%struct.anon = type { ptr }
%struct.BlockLimits = type { i32, i64, i32, i64, i32, i32, i32, i64, i32, i64, i64, i32, i8, i32, i32, i32, i32, i32, i32, i32 }
%union.anon = type { %struct.QTailQLink }
%union.anon.0 = type { %struct.QTailQLink }
%union.anon.1 = type { %struct.QTailQLink }
%struct.anon.2 = type { ptr }
%struct.anon.3 = type { ptr }
%struct.anon.4 = type { ptr }
%struct.anon.5 = type { ptr }
%struct.Stat64 = type { i64 }
%struct.anon.6 = type { ptr }
%struct.CoQueue = type { %struct.anon.7 }
%struct.anon.7 = type { ptr, ptr }
%struct.CoMutex = type { i32, ptr, %struct.anon.8, %struct.anon.8, i32, i32, ptr }
%struct.anon.8 = type { ptr }
%struct.BdrvChild = type { ptr, ptr, ptr, i32, ptr, i64, i64, i8, i8, %struct.anon.14, %struct.anon.15 }
%struct.anon.14 = type { ptr, ptr }
%struct.anon.15 = type { ptr, ptr }
%struct.ErrorPropagator = type { ptr, ptr }
%struct.QObjectBase_ = type { i32, i64 }
%struct.BdrvOpBlocker = type { ptr, %struct.anon.25 }
%struct.anon.25 = type { ptr, ptr }
%struct.BdrvAioNotifier = type { ptr, ptr, ptr, i8, %struct.anon.26 }
%struct.anon.26 = type { ptr, ptr }
%struct._GString = type { ptr, i64, i64 }
%struct.BlockReopenQueueEntry = type { i8, %struct.BDRVReopenState, %union.anon.19 }
%struct.BDRVReopenState = type { ptr, i32, i32, i8, ptr, ptr, ptr, ptr, ptr }
%union.anon.19 = type { %struct.QTailQLink }
%struct.timeval = type { i64, i64 }
%struct.BlockdevRef = type { i32, %union.anon.17 }
%union.anon.17 = type { %struct.BlockdevOptions }
%struct.BlockdevOptions = type { i32, ptr, i8, i32, ptr, i8, i8, i8, i8, i8, i8, i8, i32, %union.anon.18 }
%union.anon.18 = type { %struct.BlockdevOptionsBlkdebug }
%struct.BlockdevOptionsBlkdebug = type { ptr, ptr, i8, i64, i8, i32, i8, i32, i8, i32, i8, i32, i8, i32, i8, ptr, i8, ptr, i8, ptr, i8, ptr }
%struct.QDictEntry = type { ptr, ptr, %struct.anon.27 }
%struct.anon.27 = type { ptr, ptr }
%struct._GSList = type { ptr, ptr }
%struct.BlockDeviceInfoList = type { ptr, ptr }
%struct.XDbgBlockGraphConstructor = type { ptr, ptr }
%struct.XDbgBlockGraphNode = type { i64, i32, ptr }
%struct.XDbgBlockGraphNodeList = type { ptr, ptr }
%struct.BlockJob = type { %struct.Job, i32, i64, %struct.RateLimit, ptr, %struct.Notifier, %struct.Notifier, %struct.Notifier, %struct.Notifier, %struct.Notifier, ptr }
%struct.Job = type { ptr, ptr, ptr, i8, i8, ptr, ptr, %struct.ProgressMeter, ptr, i32, i32, %struct.QEMUTimer, i32, i8, i8, i8, i8, i8, i8, i32, ptr, %struct.NotifierList, %struct.NotifierList, %struct.NotifierList, %struct.NotifierList, %struct.NotifierList, %struct.anon.22, ptr, %struct.anon.23 }
%struct.ProgressMeter = type { i64, i64, %struct.QemuMutex }
%struct.QEMUTimer = type { i64, ptr, ptr, ptr, ptr, i32, i32 }
%struct.NotifierList = type { %struct.anon.21 }
%struct.anon.21 = type { ptr }
%struct.anon.22 = type { ptr, ptr }
%struct.anon.23 = type { ptr, ptr }
%struct.RateLimit = type { %struct.QemuMutex, i64, i64, i64, i64, i64 }
%struct.Notifier = type { ptr, %struct.anon.24 }
%struct.anon.24 = type { ptr, ptr }
%struct.XDbgBlockGraphEdge = type { i64, i64, ptr, ptr, ptr }
%struct.BlockPermissionList = type { ptr, i32 }
%struct.XDbgBlockGraphEdgeList = type { ptr, ptr }
%struct.XDbgBlockGraph = type { ptr, ptr }
%struct.BlockDriverInfo = type { i32, i32, i64, i8, i8 }
%struct.BdrvNextIterator = type { i32, ptr, ptr }
%struct.rcu_reader_data = type { i64, i8, i32, %struct.anon.28, %struct.NotifierList }
%struct.anon.28 = type { ptr, ptr }
%struct.BdrvBlockStatusCache = type { %struct.rcu_head, i8, i64, i64 }
%struct.rcu_head = type { ptr, ptr }
%struct.BdrvChildSetPermState = type { ptr, i64, i64 }
%struct.BdrvAttachChildCommonState = type { ptr, ptr, ptr }
%struct.BdrvSetInheritsFrom = type { ptr, ptr }
%struct.BdrvReplaceChildState = type { ptr, ptr }
%struct.BdrvStateSetAioContext = type { ptr, ptr }

@.str = private unnamed_addr constant [3 x i8] c":/\00", align 1
@.str.1 = private unnamed_addr constant [28 x i8] c"!path_is_absolute(filename)\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"../qemu/block.c\00", align 1
@__PRETTY_FUNCTION__.bdrv_parse_filename_strip_prefix = private unnamed_addr constant [75 x i8] c"void bdrv_parse_filename_strip_prefix(const char *, const char *, QDict *)\00", align 1
@.str.3 = private unnamed_addr constant [3 x i8] c"./\00", align 1
@.str.4 = private unnamed_addr constant [38 x i8] c"!path_has_protocol(fat_filename->str)\00", align 1
@.str.5 = private unnamed_addr constant [9 x i8] c"filename\00", align 1
@__func__.bdrv_apply_auto_read_only = private unnamed_addr constant [26 x i8] c"bdrv_apply_auto_read_only\00", align 1
@.str.6 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.7 = private unnamed_addr constant [19 x i8] c"Image is read-only\00", align 1
@.str.8 = private unnamed_addr constant [6 x i8] c"json:\00", align 1
@__func__.bdrv_get_full_backing_filename_from_filename = private unnamed_addr constant [45 x i8] c"bdrv_get_full_backing_filename_from_filename\00", align 1
@.str.9 = private unnamed_addr constant [48 x i8] c"Cannot use relative backing file names for '%s'\00", align 1
@.str.10 = private unnamed_addr constant [22 x i8] c"qemu_in_main_thread()\00", align 1
@__PRETTY_FUNCTION__.bdrv_get_full_backing_filename = private unnamed_addr constant [67 x i8] c"char *bdrv_get_full_backing_filename(BlockDriverState *, Error **)\00", align 1
@.str.11 = private unnamed_addr constant [18 x i8] c"bdrv->format_name\00", align 1
@__PRETTY_FUNCTION__.bdrv_register = private unnamed_addr constant [34 x i8] c"void bdrv_register(BlockDriver *)\00", align 1
@bdrv_drivers = internal global %struct.anon.10 zeroinitializer, align 8
@__PRETTY_FUNCTION__.bdrv_new = private unnamed_addr constant [33 x i8] c"BlockDriverState *bdrv_new(void)\00", align 1
@bdrv_drain_all_count = external local_unnamed_addr global i32, align 4
@all_bdrv_states = internal global %union.anon.11 { %struct.QTailQLink { ptr null, ptr @all_bdrv_states } }, align 8
@__PRETTY_FUNCTION__.bdrv_find_format = private unnamed_addr constant [44 x i8] c"BlockDriver *bdrv_find_format(const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_is_whitelisted = private unnamed_addr constant [46 x i8] c"int bdrv_is_whitelisted(BlockDriver *, _Bool)\00", align 1
@use_bdrv_whitelist = internal unnamed_addr global i1 false, align 4
@__PRETTY_FUNCTION__.bdrv_co_create = private unnamed_addr constant [70 x i8] c"int bdrv_co_create(BlockDriver *, const char *, QemuOpts *, Error **)\00", align 1
@error_fatal = external global ptr, align 8
@.str.13 = private unnamed_addr constant [13 x i8] c"coroutine_fn\00", section "llvm.metadata"
@.str.14 = private unnamed_addr constant [111 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block_int-common.h\00", section "llvm.metadata"
@__func__.bdrv_co_create = private unnamed_addr constant [15 x i8] c"bdrv_co_create\00", align 1
@.str.15 = private unnamed_addr constant [44 x i8] c"Driver '%s' does not support image creation\00", align 1
@.str.16 = private unnamed_addr constant [23 x i8] c"Could not create image\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_create_opts_simple = private unnamed_addr constant [82 x i8] c"int bdrv_co_create_opts_simple(BlockDriver *, const char *, QemuOpts *, Error **)\00", align 1
@.str.17 = private unnamed_addr constant [5 x i8] c"size\00", align 1
@.str.18 = private unnamed_addr constant [14 x i8] c"preallocation\00", align 1
@PreallocMode_lookup = external constant %struct.QEnumLookup, align 8
@__func__.bdrv_co_create_opts_simple = private unnamed_addr constant [27 x i8] c"bdrv_co_create_opts_simple\00", align 1
@.str.19 = private unnamed_addr constant [36 x i8] c"Unsupported preallocation mode '%s'\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"driver\00", align 1
@.str.21 = private unnamed_addr constant [176 x i8] c"Protocol driver '%s' does not support creating new images, so an existing image must be selected as the target; however, opening the given target as an existing image failed: \00", align 1
@__PRETTY_FUNCTION__.bdrv_co_create_file = private unnamed_addr constant [60 x i8] c"int bdrv_co_create_file(const char *, QemuOpts *, Error **)\00", align 1
@__func__.bdrv_co_create_file = private unnamed_addr constant [20 x i8] c"bdrv_co_create_file\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"bs != NULL\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_delete_file = private unnamed_addr constant [54 x i8] c"int bdrv_co_delete_file(BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_co_delete_file = private unnamed_addr constant [20 x i8] c"bdrv_co_delete_file\00", align 1
@.str.23 = private unnamed_addr constant [30 x i8] c"Block node '%s' is not opened\00", align 1
@.str.24 = private unnamed_addr constant [44 x i8] c"Driver '%s' does not support image deletion\00", align 1
@__PRETTY_FUNCTION__.bdrv_probe_blocksizes = private unnamed_addr constant [60 x i8] c"int bdrv_probe_blocksizes(BlockDriverState *, BlockSizes *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_probe_geometry = private unnamed_addr constant [58 x i8] c"int bdrv_probe_geometry(BlockDriverState *, HDGeometry *)\00", align 1
@.str.25 = private unnamed_addr constant [5 x i8] c"/tmp\00", align 1
@.str.26 = private unnamed_addr constant [9 x i8] c"/var/tmp\00", align 1
@.str.27 = private unnamed_addr constant [13 x i8] c"%s/vl.XXXXXX\00", align 1
@__func__.create_tmp_file = private unnamed_addr constant [16 x i8] c"create_tmp_file\00", align 1
@.str.28 = private unnamed_addr constant [35 x i8] c"Could not open temporary file '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_protocol = private unnamed_addr constant [63 x i8] c"BlockDriver *bdrv_find_protocol(const char *, _Bool, Error **)\00", align 1
@bdrv_file = external global %struct.BlockDriver, align 8
@.str.29 = private unnamed_addr constant [10 x i8] c"p != NULL\00", align 1
@__func__.bdrv_find_protocol = private unnamed_addr constant [19 x i8] c"bdrv_find_protocol\00", align 1
@.str.30 = private unnamed_addr constant [22 x i8] c"Unknown protocol '%s'\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"threads\00", align 1
@.str.32 = private unnamed_addr constant [7 x i8] c"native\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"io_uring\00", align 1
@.str.34 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.35 = private unnamed_addr constant [7 x i8] c"ignore\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"on\00", align 1
@.str.37 = private unnamed_addr constant [6 x i8] c"unmap\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.39 = private unnamed_addr constant [11 x i8] c"directsync\00", align 1
@.str.40 = private unnamed_addr constant [10 x i8] c"writeback\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"unsafe\00", align 1
@.str.42 = private unnamed_addr constant [13 x i8] c"writethrough\00", align 1
@child_of_bds = dso_local constant %struct.BdrvChildClass { i8 0, i8 1, ptr @bdrv_inherited_options, ptr null, ptr @bdrv_child_get_parent_desc, ptr null, ptr @bdrv_child_cb_inactivate, ptr @bdrv_child_cb_attach, ptr @bdrv_child_cb_detach, ptr @bdrv_child_cb_drained_begin, ptr @bdrv_child_cb_drained_end, ptr @bdrv_child_cb_drained_poll, ptr @bdrv_child_cb_update_filename, ptr @bdrv_child_cb_change_aio_ctx, ptr null, ptr null, ptr @child_of_bds_get_parent_aio_context }, align 8
@__PRETTY_FUNCTION__.bdrv_new_open_driver_opts = private unnamed_addr constant [97 x i8] c"BlockDriverState *bdrv_new_open_driver_opts(BlockDriver *, const char *, QDict *, int, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_new_open_driver = private unnamed_addr constant [83 x i8] c"BlockDriverState *bdrv_new_open_driver(BlockDriver *, const char *, int, Error **)\00", align 1
@.str.43 = private unnamed_addr constant [12 x i8] c"bdrv_common\00", align 1
@.str.44 = private unnamed_addr constant [10 x i8] c"node-name\00", align 1
@.str.45 = private unnamed_addr constant [35 x i8] c"Node name of the block device node\00", align 1
@.str.46 = private unnamed_addr constant [33 x i8] c"Block driver to use for the node\00", align 1
@.str.47 = private unnamed_addr constant [13 x i8] c"cache.direct\00", align 1
@.str.48 = private unnamed_addr constant [44 x i8] c"Bypass software writeback cache on the host\00", align 1
@.str.49 = private unnamed_addr constant [15 x i8] c"cache.no-flush\00", align 1
@.str.50 = private unnamed_addr constant [22 x i8] c"Ignore flush requests\00", align 1
@.str.51 = private unnamed_addr constant [10 x i8] c"read-only\00", align 1
@.str.52 = private unnamed_addr constant [33 x i8] c"Node is opened in read-only mode\00", align 1
@.str.53 = private unnamed_addr constant [15 x i8] c"auto-read-only\00", align 1
@.str.54 = private unnamed_addr constant [54 x i8] c"Node can become read-only if opening read-write fails\00", align 1
@.str.55 = private unnamed_addr constant [14 x i8] c"detect-zeroes\00", align 1
@.str.56 = private unnamed_addr constant [45 x i8] c"try to optimize zero writes (off, on, unmap)\00", align 1
@.str.57 = private unnamed_addr constant [8 x i8] c"discard\00", align 1
@.str.58 = private unnamed_addr constant [41 x i8] c"discard operation (ignore/off, unmap/on)\00", align 1
@.str.59 = private unnamed_addr constant [12 x i8] c"force-share\00", align 1
@.str.60 = private unnamed_addr constant [43 x i8] c"always accept other writers (default: off)\00", align 1
@bdrv_runtime_opts = dso_local global { ptr, ptr, i8, %union.anon.16, [10 x %struct.QemuOptDesc] } { ptr @.str.43, ptr null, i8 0, %union.anon.16 { %struct.QTailQLink { ptr null, ptr getelementptr (i8, ptr @bdrv_runtime_opts, i64 24) } }, [10 x %struct.QemuOptDesc] [%struct.QemuOptDesc { ptr @.str.44, i32 0, ptr @.str.45, ptr null }, %struct.QemuOptDesc { ptr @.str.20, i32 0, ptr @.str.46, ptr null }, %struct.QemuOptDesc { ptr @.str.47, i32 1, ptr @.str.48, ptr null }, %struct.QemuOptDesc { ptr @.str.49, i32 1, ptr @.str.50, ptr null }, %struct.QemuOptDesc { ptr @.str.51, i32 1, ptr @.str.52, ptr null }, %struct.QemuOptDesc { ptr @.str.53, i32 1, ptr @.str.54, ptr null }, %struct.QemuOptDesc { ptr @.str.55, i32 0, ptr @.str.56, ptr null }, %struct.QemuOptDesc { ptr @.str.57, i32 0, ptr @.str.58, ptr null }, %struct.QemuOptDesc { ptr @.str.59, i32 1, ptr @.str.60, ptr null }, %struct.QemuOptDesc zeroinitializer] }, align 8
@.str.62 = private unnamed_addr constant [19 x i8] c"simple-create-opts\00", align 1
@.str.63 = private unnamed_addr constant [18 x i8] c"Virtual disk size\00", align 1
@.str.64 = private unnamed_addr constant [41 x i8] c"Preallocation mode (allowed values: off)\00", align 1
@bdrv_create_opts_simple = dso_local global { ptr, ptr, i8, %union.anon.16, [3 x %struct.QemuOptDesc] } { ptr @.str.62, ptr null, i8 0, %union.anon.16 { %struct.QTailQLink { ptr null, ptr getelementptr (i8, ptr @bdrv_create_opts_simple, i64 24) } }, [3 x %struct.QemuOptDesc] [%struct.QemuOptDesc { ptr @.str.17, i32 3, ptr @.str.63, ptr null }, %struct.QemuOptDesc { ptr @.str.18, i32 0, ptr @.str.64, ptr null }, %struct.QemuOptDesc zeroinitializer] }, align 8
@bdrv_drv_set_perm_drv = dso_local global %struct.TransactionActionDrv { ptr @bdrv_drv_set_perm_abort, ptr @bdrv_drv_set_perm_commit, ptr null }, align 8
@__PRETTY_FUNCTION__.bdrv_get_cumulative_perm = private unnamed_addr constant [74 x i8] c"void bdrv_get_cumulative_perm(BlockDriverState *, uint64_t *, uint64_t *)\00", align 1
@.str.66 = private unnamed_addr constant [16 x i8] c"consistent read\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.68 = private unnamed_addr constant [16 x i8] c"write unchanged\00", align 1
@.str.69 = private unnamed_addr constant [7 x i8] c"resize\00", align 1
@__const.bdrv_perm_names.permissions = private unnamed_addr constant [5 x %struct.perm_name] [%struct.perm_name { i64 1, ptr @.str.66 }, %struct.perm_name { i64 2, ptr @.str.67 }, %struct.perm_name { i64 4, ptr @.str.68 }, %struct.perm_name { i64 8, ptr @.str.69 }, %struct.perm_name zeroinitializer], align 16
@.str.70 = private unnamed_addr constant [3 x i8] c", \00", align 1
@__PRETTY_FUNCTION__.bdrv_child_try_set_perm = private unnamed_addr constant [71 x i8] c"int bdrv_child_try_set_perm(BdrvChild *, uint64_t, uint64_t, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_refresh_perms = private unnamed_addr constant [72 x i8] c"int bdrv_child_refresh_perms(BlockDriverState *, BdrvChild *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_default_perms = private unnamed_addr constant [136 x i8] c"void bdrv_default_perms(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@.str.71 = private unnamed_addr constant [67 x i8] c"!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA | BDRV_CHILD_COW))\00", align 1
@.str.72 = private unnamed_addr constant [50 x i8] c"!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA))\00", align 1
@__func__.bdrv_default_perms = private unnamed_addr constant [19 x i8] c"bdrv_default_perms\00", align 1
@bdrv_qapi_perm_to_blk_perm.permissions = internal unnamed_addr constant [4 x i64] [i64 1, i64 2, i64 4, i64 8], align 16
@.str.73 = private unnamed_addr constant [34 x i8] c"qapi_perm < BLOCK_PERMISSION__MAX\00", align 1
@__PRETTY_FUNCTION__.bdrv_qapi_perm_to_blk_perm = private unnamed_addr constant [53 x i8] c"uint64_t bdrv_qapi_perm_to_blk_perm(BlockPermission)\00", align 1
@__PRETTY_FUNCTION__.bdrv_root_attach_child = private unnamed_addr constant [145 x i8] c"BdrvChild *bdrv_root_attach_child(BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, uint64_t, uint64_t, void *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_child = private unnamed_addr constant [132 x i8] c"BdrvChild *bdrv_attach_child(BlockDriverState *, BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_root_unref_child = private unnamed_addr constant [40 x i8] c"void bdrv_root_unref_child(BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_unref_child = private unnamed_addr constant [55 x i8] c"void bdrv_unref_child(BlockDriverState *, BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained = private unnamed_addr constant [82 x i8] c"int bdrv_set_backing_hd_drained(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@.str.74 = private unnamed_addr constant [24 x i8] c"bs->quiesce_counter > 0\00", align 1
@.str.75 = private unnamed_addr constant [37 x i8] c"bs->backing->bs->quiesce_counter > 0\00", align 1
@__PRETTY_FUNCTION__.bdrv_set_backing_hd = private unnamed_addr constant [74 x i8] c"int bdrv_set_backing_hd(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_backing_file = private unnamed_addr constant [80 x i8] c"int bdrv_open_backing_file(BlockDriverState *, QDict *, const char *, Error **)\00", align 1
@.str.76 = private unnamed_addr constant [4 x i8] c"%s.\00", align 1
@.str.77 = private unnamed_addr constant [14 x i8] c"file.filename\00", align 1
@__func__.bdrv_open_backing_file = private unnamed_addr constant [23 x i8] c"bdrv_open_backing_file\00", align 1
@.str.78 = private unnamed_addr constant [37 x i8] c"Driver doesn't support backing files\00", align 1
@.str.79 = private unnamed_addr constant [30 x i8] c"Could not open backing file: \00", align 1
@__PRETTY_FUNCTION__.bdrv_open_child = private unnamed_addr constant [140 x i8] c"BdrvChild *bdrv_open_child(const char *, QDict *, const char *, BlockDriverState *, const BdrvChildClass *, BdrvChildRole, _Bool, Error **)\00", align 1
@.str.80 = private unnamed_addr constant [40 x i8] c"!parent->drv->filtered_child_is_backing\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_file_child = private unnamed_addr constant [92 x i8] c"int bdrv_open_file_child(const char *, QDict *, const char *, BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_blockdev_ref = private unnamed_addr constant [66 x i8] c"BlockDriverState *bdrv_open_blockdev_ref(BlockdevRef *, Error **)\00", align 1
@.str.81 = private unnamed_addr constant [25 x i8] c"ref->type == QTYPE_QDICT\00", align 1
@error_abort = external global ptr, align 8
@__PRETTY_FUNCTION__.bdrv_open = private unnamed_addr constant [80 x i8] c"BlockDriverState *bdrv_open(const char *, const char *, QDict *, int, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_queue = private unnamed_addr constant [92 x i8] c"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *, BlockDriverState *, QDict *, _Bool)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_queue_free = private unnamed_addr constant [48 x i8] c"void bdrv_reopen_queue_free(BlockReopenQueue *)\00", align 1
@.str.82 = private unnamed_addr constant [57 x i8] c"qemu_get_current_aio_context() == qemu_get_aio_context()\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_multiple = private unnamed_addr constant [55 x i8] c"int bdrv_reopen_multiple(BlockReopenQueue *, Error **)\00", align 1
@.str.83 = private unnamed_addr constant [17 x i8] c"bs_queue != NULL\00", align 1
@__func__.bdrv_reopen_multiple = private unnamed_addr constant [21 x i8] c"bdrv_reopen_multiple\00", align 1
@.str.84 = private unnamed_addr constant [21 x i8] c"Error flushing drive\00", align 1
@.str.85 = private unnamed_addr constant [40 x i8] c"bs_entry->state.bs->quiesce_counter > 0\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen = private unnamed_addr constant [62 x i8] c"int bdrv_reopen(BlockDriverState *, QDict *, _Bool, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_set_read_only = private unnamed_addr constant [67 x i8] c"int bdrv_reopen_set_read_only(BlockDriverState *, _Bool, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_close_all = private unnamed_addr constant [26 x i8] c"void bdrv_close_all(void)\00", align 1
@.str.86 = private unnamed_addr constant [23 x i8] c"job_next(NULL) == NULL\00", align 1
@.str.87 = private unnamed_addr constant [31 x i8] c"QTAILQ_EMPTY(&all_bdrv_states)\00", align 1
@__PRETTY_FUNCTION__.bdrv_drop_filter = private unnamed_addr constant [51 x i8] c"int bdrv_drop_filter(BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_append = private unnamed_addr constant [66 x i8] c"int bdrv_append(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@.str.88 = private unnamed_addr constant [17 x i8] c"!bs_new->backing\00", align 1
@.str.89 = private unnamed_addr constant [8 x i8] c"backing\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_bs = private unnamed_addr constant [69 x i8] c"int bdrv_replace_child_bs(BdrvChild *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_insert_node = private unnamed_addr constant [17 x i8] c"bdrv_insert_node\00", align 1
@.str.90 = private unnamed_addr constant [24 x i8] c"driver is not specified\00", align 1
@.str.91 = private unnamed_addr constant [21 x i8] c"Unknown driver: '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_insert_node = private unnamed_addr constant [79 x i8] c"BlockDriverState *bdrv_insert_node(BlockDriverState *, QDict *, int, Error **)\00", align 1
@.str.92 = private unnamed_addr constant [32 x i8] c"bdrv_get_aio_context(bs) == ctx\00", align 1
@.str.93 = private unnamed_addr constant [24 x i8] c"Could not create node: \00", align 1
@.str.94 = private unnamed_addr constant [25 x i8] c"Could not replace node: \00", align 1
@.str.95 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@__PRETTY_FUNCTION__.bdrv_find_overlay = private unnamed_addr constant [76 x i8] c"BlockDriverState *bdrv_find_overlay(BlockDriverState *, BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_base = private unnamed_addr constant [53 x i8] c"BlockDriverState *bdrv_find_base(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_freeze_backing_chain = private unnamed_addr constant [80 x i8] c"int bdrv_freeze_backing_chain(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_freeze_backing_chain = private unnamed_addr constant [26 x i8] c"bdrv_freeze_backing_chain\00", align 1
@.str.96 = private unnamed_addr constant [32 x i8] c"Cannot freeze '%s' link to '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_unfreeze_backing_chain = private unnamed_addr constant [73 x i8] c"void bdrv_unfreeze_backing_chain(BlockDriverState *, BlockDriverState *)\00", align 1
@.str.97 = private unnamed_addr constant [14 x i8] c"child->frozen\00", align 1
@__PRETTY_FUNCTION__.bdrv_drop_intermediate = private unnamed_addr constant [81 x i8] c"int bdrv_drop_intermediate(BlockDriverState *, BlockDriverState *, const char *)\00", align 1
@__func__.bdrv_measure = private unnamed_addr constant [13 x i8] c"bdrv_measure\00", align 1
@.str.98 = private unnamed_addr constant [52 x i8] c"Block driver '%s' does not support size measurement\00", align 1
@__PRETTY_FUNCTION__.bdrv_iterate_format = private unnamed_addr constant [72 x i8] c"void bdrv_iterate_format(void (*)(void *, const char *), void *, _Bool)\00", align 1
@.str.99 = private unnamed_addr constant [10 x i8] c"node_name\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_node = private unnamed_addr constant [47 x i8] c"BlockDriverState *bdrv_find_node(const char *)\00", align 1
@graph_bdrv_states = internal global %union.anon.20 { %struct.QTailQLink { ptr null, ptr @graph_bdrv_states } }, align 8
@__PRETTY_FUNCTION__.bdrv_named_nodes_list = private unnamed_addr constant [60 x i8] c"BlockDeviceInfoList *bdrv_named_nodes_list(_Bool, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_get_xdbg_block_graph = private unnamed_addr constant [52 x i8] c"XDbgBlockGraph *bdrv_get_xdbg_block_graph(Error **)\00", align 1
@job_mutex = external global %struct.QemuMutex, align 8
@__PRETTY_FUNCTION__.bdrv_lookup_bs = private unnamed_addr constant [71 x i8] c"BlockDriverState *bdrv_lookup_bs(const char *, const char *, Error **)\00", align 1
@__func__.bdrv_lookup_bs = private unnamed_addr constant [15 x i8] c"bdrv_lookup_bs\00", align 1
@.str.100 = private unnamed_addr constant [26 x i8] c"Device '%s' has no medium\00", align 1
@.str.101 = private unnamed_addr constant [43 x i8] c"Cannot find device='%s' nor node-name='%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_chain_contains = private unnamed_addr constant [66 x i8] c"_Bool bdrv_chain_contains(BlockDriverState *, BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_next_node = private unnamed_addr constant [53 x i8] c"BlockDriverState *bdrv_next_node(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_next_all_states = private unnamed_addr constant [59 x i8] c"BlockDriverState *bdrv_next_all_states(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_has_zero_init_1 = private unnamed_addr constant [45 x i8] c"int bdrv_has_zero_init_1(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_has_zero_init = private unnamed_addr constant [43 x i8] c"int bdrv_has_zero_init(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_breakpoint = private unnamed_addr constant [74 x i8] c"int bdrv_debug_breakpoint(BlockDriverState *, const char *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_remove_breakpoint = private unnamed_addr constant [67 x i8] c"int bdrv_debug_remove_breakpoint(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_resume = private unnamed_addr constant [56 x i8] c"int bdrv_debug_resume(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_is_suspended = private unnamed_addr constant [64 x i8] c"_Bool bdrv_debug_is_suspended(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_backing_image = private unnamed_addr constant [76 x i8] c"BlockDriverState *bdrv_find_backing_image(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_activate = private unnamed_addr constant [48 x i8] c"int bdrv_activate(BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_activate = private unnamed_addr constant [14 x i8] c"bdrv_activate\00", align 1
@.str.102 = private unnamed_addr constant [37 x i8] c"Could not refresh total sector count\00", align 1
@.str.103 = private unnamed_addr constant [36 x i8] c"!(bs->open_flags & BDRV_O_INACTIVE)\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_invalidate_cache = private unnamed_addr constant [59 x i8] c"int bdrv_co_invalidate_cache(BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_activate_all = private unnamed_addr constant [33 x i8] c"void bdrv_activate_all(Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_inactivate_all = private unnamed_addr constant [30 x i8] c"int bdrv_inactivate_all(void)\00", align 1
@__PRETTY_FUNCTION__.bdrv_ref = private unnamed_addr constant [34 x i8] c"void bdrv_ref(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_unref = private unnamed_addr constant [36 x i8] c"void bdrv_unref(BlockDriverState *)\00", align 1
@.str.104 = private unnamed_addr constant [15 x i8] c"bs->refcnt > 0\00", align 1
@.str.105 = private unnamed_addr constant [23 x i8] c"bdrv_schedule_unref_bh\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_is_blocked = private unnamed_addr constant [68 x i8] c"_Bool bdrv_op_is_blocked(BlockDriverState *, BlockOpType, Error **)\00", align 1
@.str.106 = private unnamed_addr constant [40 x i8] c"(int) op >= 0 && op < BLOCK_OP_TYPE_MAX\00", align 1
@.str.107 = private unnamed_addr constant [20 x i8] c"Node '%s' is busy: \00", align 1
@__PRETTY_FUNCTION__.bdrv_op_block = private unnamed_addr constant [61 x i8] c"void bdrv_op_block(BlockDriverState *, BlockOpType, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_unblock = private unnamed_addr constant [63 x i8] c"void bdrv_op_unblock(BlockDriverState *, BlockOpType, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_block_all = private unnamed_addr constant [52 x i8] c"void bdrv_op_block_all(BlockDriverState *, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_unblock_all = private unnamed_addr constant [54 x i8] c"void bdrv_op_unblock_all(BlockDriverState *, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_blocker_is_empty = private unnamed_addr constant [51 x i8] c"_Bool bdrv_op_blocker_is_empty(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_img_create = private unnamed_addr constant [117 x i8] c"void bdrv_img_create(const char *, const char *, const char *, const char *, char *, uint64_t, int, _Bool, Error **)\00", align 1
@__func__.bdrv_img_create = private unnamed_addr constant [16 x i8] c"bdrv_img_create\00", align 1
@.str.108 = private unnamed_addr constant [25 x i8] c"Unknown file format '%s'\00", align 1
@.str.109 = private unnamed_addr constant [51 x i8] c"Format driver '%s' does not support image creation\00", align 1
@.str.110 = private unnamed_addr constant [53 x i8] c"Protocol driver '%s' does not support image creation\00", align 1
@.str.111 = private unnamed_addr constant [43 x i8] c"The image size must be specified only once\00", align 1
@.str.112 = private unnamed_addr constant [13 x i8] c"backing_file\00", align 1
@.str.113 = private unnamed_addr constant [48 x i8] c"Backing file not supported for file format '%s'\00", align 1
@.str.114 = private unnamed_addr constant [12 x i8] c"backing_fmt\00", align 1
@.str.115 = private unnamed_addr constant [55 x i8] c"Backing file format not supported for file format '%s'\00", align 1
@.str.116 = private unnamed_addr constant [76 x i8] c"Error: Trying to create an image with the same filename as the backing file\00", align 1
@.str.117 = private unnamed_addr constant [45 x i8] c"Expected backing file name, got empty string\00", align 1
@.str.118 = private unnamed_addr constant [13 x i8] c"full_backing\00", align 1
@.str.119 = private unnamed_addr constant [31 x i8] c"Could not open backing image.\0A\00", align 1
@.str.120 = private unnamed_addr constant [46 x i8] c"Backing file specified without backing format\00", align 1
@.str.121 = private unnamed_addr constant [24 x i8] c"Detected format of %s.\0A\00", align 1
@.str.122 = private unnamed_addr constant [27 x i8] c"Could not get size of '%s'\00", align 1
@.str.123 = private unnamed_addr constant [38 x i8] c"Image creation needs a size parameter\00", align 1
@.str.124 = private unnamed_addr constant [25 x i8] c"Formatting '%s', fmt=%s \00", align 1
@.str.125 = private unnamed_addr constant [2 x i8] c" \00", align 1
@stdout = external local_unnamed_addr global ptr, align 8
@.str.126 = private unnamed_addr constant [13 x i8] c"cluster_size\00", align 1
@.str.127 = private unnamed_addr constant [35 x i8] c" (try using a larger cluster size)\00", align 1
@.str.128 = private unnamed_addr constant [51 x i8] c"The image size is too large for file format '%s'%s\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_lock = private unnamed_addr constant [38 x i8] c"void bdrv_co_lock(BlockDriverState *)\00", align 1
@.str.129 = private unnamed_addr constant [20 x i8] c"qemu_in_coroutine()\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_unlock = private unnamed_addr constant [40 x i8] c"void bdrv_co_unlock(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_change_aio_context = private unnamed_addr constant [102 x i8] c"_Bool bdrv_child_change_aio_context(BdrvChild *, AioContext *, GHashTable *, Transaction *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_try_change_aio_context = private unnamed_addr constant [89 x i8] c"int bdrv_try_change_aio_context(BlockDriverState *, AioContext *, BdrvChild *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_add_aio_context_notifier = private unnamed_addr constant [113 x i8] c"void bdrv_add_aio_context_notifier(BlockDriverState *, void (*)(AioContext *, void *), void (*)(void *), void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_remove_aio_context_notifier = private unnamed_addr constant [116 x i8] c"void bdrv_remove_aio_context_notifier(BlockDriverState *, void (*)(AioContext *, void *), void (*)(void *), void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_amend_options = private unnamed_addr constant [108 x i8] c"int bdrv_amend_options(BlockDriverState *, QemuOpts *, BlockDriverAmendStatusCB *, void *, _Bool, Error **)\00", align 1
@__func__.bdrv_amend_options = private unnamed_addr constant [19 x i8] c"bdrv_amend_options\00", align 1
@.str.130 = private unnamed_addr constant [16 x i8] c"Node is ejected\00", align 1
@.str.131 = private unnamed_addr constant [52 x i8] c"Block driver '%s' does not support option amendment\00", align 1
@__PRETTY_FUNCTION__.bdrv_recurse_can_replace = private unnamed_addr constant [71 x i8] c"_Bool bdrv_recurse_can_replace(BlockDriverState *, BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.check_to_replace_node = private unnamed_addr constant [84 x i8] c"BlockDriverState *check_to_replace_node(BlockDriverState *, const char *, Error **)\00", align 1
@__func__.check_to_replace_node = private unnamed_addr constant [22 x i8] c"check_to_replace_node\00", align 1
@.str.132 = private unnamed_addr constant [40 x i8] c"Failed to find node with node-name='%s'\00", align 1
@.str.133 = private unnamed_addr constant [147 x i8] c"Cannot replace '%s' by a node mirrored from '%s', because it cannot be guaranteed that doing so would not lead to an abrupt change of visible data\00", align 1
@__PRETTY_FUNCTION__.bdrv_refresh_filename = private unnamed_addr constant [47 x i8] c"void bdrv_refresh_filename(BlockDriverState *)\00", align 1
@.str.134 = private unnamed_addr constant [32 x i8] c"QLIST_NEXT(child, next) == NULL\00", align 1
@.str.135 = private unnamed_addr constant [8 x i8] c"json:%s\00", align 1
@__PRETTY_FUNCTION__.bdrv_dirname = private unnamed_addr constant [49 x i8] c"char *bdrv_dirname(BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_dirname = private unnamed_addr constant [13 x i8] c"bdrv_dirname\00", align 1
@.str.137 = private unnamed_addr constant [21 x i8] c"Node '%s' is ejected\00", align 1
@.str.138 = private unnamed_addr constant [46 x i8] c"Cannot generate a base directory for %s nodes\00", align 1
@__PRETTY_FUNCTION__.bdrv_add_child = private unnamed_addr constant [70 x i8] c"void bdrv_add_child(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_add_child = private unnamed_addr constant [15 x i8] c"bdrv_add_child\00", align 1
@.str.139 = private unnamed_addr constant [44 x i8] c"The node %s does not support adding a child\00", align 1
@.str.140 = private unnamed_addr constant [37 x i8] c"Cannot add a %s child to a %s parent\00", align 1
@.str.141 = private unnamed_addr constant [6 x i8] c"zoned\00", align 1
@.str.144 = private unnamed_addr constant [27 x i8] c"not support zoned children\00", align 1
@.str.145 = private unnamed_addr constant [33 x i8] c"The node %s already has a parent\00", align 1
@__PRETTY_FUNCTION__.bdrv_del_child = private unnamed_addr constant [63 x i8] c"void bdrv_del_child(BlockDriverState *, BdrvChild *, Error **)\00", align 1
@__func__.bdrv_del_child = private unnamed_addr constant [15 x i8] c"bdrv_del_child\00", align 1
@.str.146 = private unnamed_addr constant [46 x i8] c"The node %s does not support removing a child\00", align 1
@.str.147 = private unnamed_addr constant [43 x i8] c"The node %s does not have a child named %s\00", align 1
@__PRETTY_FUNCTION__.bdrv_make_empty = private unnamed_addr constant [43 x i8] c"int bdrv_make_empty(BdrvChild *, Error **)\00", align 1
@.str.148 = private unnamed_addr constant [54 x i8] c"c->perm & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)\00", align 1
@__func__.bdrv_make_empty = private unnamed_addr constant [16 x i8] c"bdrv_make_empty\00", align 1
@.str.149 = private unnamed_addr constant [35 x i8] c"%s does not support emptying nodes\00", align 1
@.str.150 = private unnamed_addr constant [19 x i8] c"Failed to empty %s\00", align 1
@.str.151 = private unnamed_addr constant [35 x i8] c"bs->backing->role & BDRV_CHILD_COW\00", align 1
@__PRETTY_FUNCTION__.bdrv_cow_child = private unnamed_addr constant [46 x i8] c"BdrvChild *bdrv_cow_child(BlockDriverState *)\00", align 1
@.str.152 = private unnamed_addr constant [27 x i8] c"!(bs->backing && bs->file)\00", align 1
@__PRETTY_FUNCTION__.bdrv_filter_child = private unnamed_addr constant [49 x i8] c"BdrvChild *bdrv_filter_child(BlockDriverState *)\00", align 1
@.str.153 = private unnamed_addr constant [30 x i8] c"c->role & BDRV_CHILD_FILTERED\00", align 1
@.str.154 = private unnamed_addr constant [29 x i8] c"!(cow_child && filter_child)\00", align 1
@__PRETTY_FUNCTION__.bdrv_filter_or_cow_child = private unnamed_addr constant [56 x i8] c"BdrvChild *bdrv_filter_or_cow_child(BlockDriverState *)\00", align 1
@.str.155 = private unnamed_addr constant [7 x i8] c"!found\00", align 1
@__PRETTY_FUNCTION__.bdrv_primary_child = private unnamed_addr constant [50 x i8] c"BdrvChild *bdrv_primary_child(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_skip_implicit_filters = private unnamed_addr constant [65 x i8] c"BlockDriverState *bdrv_skip_implicit_filters(BlockDriverState *)\00", align 1
@__func__.bdrv_can_set_read_only = private unnamed_addr constant [23 x i8] c"bdrv_can_set_read_only\00", align 1
@.str.156 = private unnamed_addr constant [53 x i8] c"Can't set node '%s' to r/o with copy-on-read enabled\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_find_format = private unnamed_addr constant [47 x i8] c"BlockDriver *bdrv_do_find_format(const char *)\00", align 1
@__PRETTY_FUNCTION__.create_file_fallback_truncate = private unnamed_addr constant [73 x i8] c"int64_t create_file_fallback_truncate(BlockBackend *, int64_t, Error **)\00", align 1
@__func__.create_file_fallback_truncate = private unnamed_addr constant [30 x i8] c"create_file_fallback_truncate\00", align 1
@.str.158 = private unnamed_addr constant [46 x i8] c"Failed to inquire the new image file's length\00", align 1
@__PRETTY_FUNCTION__.create_file_fallback_zero_first_sector = private unnamed_addr constant [78 x i8] c"int create_file_fallback_zero_first_sector(BlockBackend *, int64_t, Error **)\00", align 1
@__func__.create_file_fallback_zero_first_sector = private unnamed_addr constant [39 x i8] c"create_file_fallback_zero_first_sector\00", align 1
@.str.159 = private unnamed_addr constant [45 x i8] c"Failed to clear the new image's first sector\00", align 1
@.str.160 = private unnamed_addr constant [25 x i8] c"!obj || obj->base.refcnt\00", align 1
@.str.161 = private unnamed_addr constant [105 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qapi/qmp/qobject.h\00", align 1
@__PRETTY_FUNCTION__.qobject_unref_impl = private unnamed_addr constant [35 x i8] c"void qobject_unref_impl(QObject *)\00", align 1
@__PRETTY_FUNCTION__.find_hdev_driver = private unnamed_addr constant [44 x i8] c"BlockDriver *find_hdev_driver(const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_find_protocol = private unnamed_addr constant [49 x i8] c"BlockDriver *bdrv_do_find_protocol(const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_inherited_options = private unnamed_addr constant [80 x i8] c"void bdrv_inherited_options(BdrvChildRole, _Bool, int *, QDict *, int, QDict *)\00", align 1
@.str.162 = private unnamed_addr constant [10 x i8] c"node '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_cb_inactivate = private unnamed_addr constant [42 x i8] c"int bdrv_child_cb_inactivate(BdrvChild *)\00", align 1
@.str.163 = private unnamed_addr constant [33 x i8] c"bs->open_flags & BDRV_O_INACTIVE\00", align 1
@.str.164 = private unnamed_addr constant [32 x i8] c"!(child->role & BDRV_CHILD_COW)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_cb_attach = private unnamed_addr constant [39 x i8] c"void bdrv_child_cb_attach(BdrvChild *)\00", align 1
@.str.165 = private unnamed_addr constant [34 x i8] c"child->role & BDRV_CHILD_FILTERED\00", align 1
@.str.166 = private unnamed_addr constant [13 x i8] c"!bs->backing\00", align 1
@.str.167 = private unnamed_addr constant [10 x i8] c"!bs->file\00", align 1
@.str.168 = private unnamed_addr constant [37 x i8] c"!(child->role & BDRV_CHILD_FILTERED)\00", align 1
@.str.169 = private unnamed_addr constant [26 x i8] c"bs->drv->supports_backing\00", align 1
@.str.170 = private unnamed_addr constant [36 x i8] c"!(child->role & BDRV_CHILD_PRIMARY)\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_attach = private unnamed_addr constant [38 x i8] c"void bdrv_backing_attach(BdrvChild *)\00", align 1
@.str.171 = private unnamed_addr constant [25 x i8] c"!parent->backing_blocker\00", align 1
@__func__.bdrv_backing_attach = private unnamed_addr constant [20 x i8] c"bdrv_backing_attach\00", align 1
@.str.172 = private unnamed_addr constant [35 x i8] c"node is used as backing hd of '%s'\00", align 1
@.str.173 = private unnamed_addr constant [18 x i8] c"child != bs->file\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_cb_detach = private unnamed_addr constant [39 x i8] c"void bdrv_child_cb_detach(BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_detach = private unnamed_addr constant [38 x i8] c"void bdrv_backing_detach(BdrvChild *)\00", align 1
@.str.174 = private unnamed_addr constant [24 x i8] c"parent->backing_blocker\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_update_filename = private unnamed_addr constant [90 x i8] c"int bdrv_backing_update_filename(BdrvChild *, BlockDriverState *, const char *, Error **)\00", align 1
@__func__.bdrv_backing_update_filename = private unnamed_addr constant [29 x i8] c"bdrv_backing_update_filename\00", align 1
@.str.175 = private unnamed_addr constant [35 x i8] c"Could not update backing file link\00", align 1
@__PRETTY_FUNCTION__.update_options_from_flags = private unnamed_addr constant [45 x i8] c"void update_options_from_flags(QDict *, int)\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_driver = private unnamed_addr constant [94 x i8] c"int bdrv_open_driver(BlockDriverState *, BlockDriver *, const char *, QDict *, int, Error **)\00", align 1
@.str.176 = private unnamed_addr constant [45 x i8] c"!drv->bdrv_needs_filename || bs->filename[0]\00", align 1
@__func__.bdrv_open_driver = private unnamed_addr constant [17 x i8] c"bdrv_open_driver\00", align 1
@.str.177 = private unnamed_addr constant [20 x i8] c"Could not open '%s'\00", align 1
@.str.178 = private unnamed_addr constant [21 x i8] c"Could not open image\00", align 1
@.str.179 = private unnamed_addr constant [45 x i8] c"!(bs->supported_read_flags & ~BDRV_REQ_MASK)\00", align 1
@.str.180 = private unnamed_addr constant [46 x i8] c"!(bs->supported_write_flags & ~BDRV_REQ_MASK)\00", align 1
@.str.181 = private unnamed_addr constant [28 x i8] c"bdrv_opt_mem_align(bs) != 0\00", align 1
@.str.182 = private unnamed_addr constant [28 x i8] c"bdrv_min_mem_align(bs) != 0\00", align 1
@.str.183 = private unnamed_addr constant [40 x i8] c"is_power_of_2(bs->bl.request_alignment)\00", align 1
@__PRETTY_FUNCTION__.bdrv_assign_node_name = private unnamed_addr constant [71 x i8] c"void bdrv_assign_node_name(BlockDriverState *, const char *, Error **)\00", align 1
@__func__.bdrv_assign_node_name = private unnamed_addr constant [22 x i8] c"bdrv_assign_node_name\00", align 1
@.str.184 = private unnamed_addr constant [24 x i8] c"Invalid node-name: '%s'\00", align 1
@.str.185 = private unnamed_addr constant [45 x i8] c"node-name=%s is conflicting with a device id\00", align 1
@.str.186 = private unnamed_addr constant [36 x i8] c"Duplicate nodes with node-name='%s'\00", align 1
@.str.187 = private unnamed_addr constant [19 x i8] c"Node name too long\00", align 1
@__PRETTY_FUNCTION__.bdrv_drv_set_perm_abort = private unnamed_addr constant [37 x i8] c"void bdrv_drv_set_perm_abort(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_drv_set_perm_commit = private unnamed_addr constant [38 x i8] c"void bdrv_drv_set_perm_commit(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_set_perm = private unnamed_addr constant [73 x i8] c"void bdrv_child_set_perm(BdrvChild *, uint64_t, uint64_t, Transaction *)\00", align 1
@bdrv_child_set_pem_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_child_set_perm_abort, ptr null, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_child_set_perm_abort = private unnamed_addr constant [39 x i8] c"void bdrv_child_set_perm_abort(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_refresh_perms = private unnamed_addr constant [68 x i8] c"int bdrv_refresh_perms(BlockDriverState *, Transaction *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_topological_dfs = private unnamed_addr constant [73 x i8] c"GSList *bdrv_topological_dfs(GSList *, GHashTable *, BlockDriverState *)\00", align 1
@.str.188 = private unnamed_addr constant [6 x i8] c"!list\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_refresh_perms = private unnamed_addr constant [81 x i8] c"int bdrv_do_refresh_perms(GSList *, BlockReopenQueue *, Transaction *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_parent_perms_conflict = private unnamed_addr constant [63 x i8] c"_Bool bdrv_parent_perms_conflict(BlockDriverState *, Error **)\00", align 1
@.str.189 = private unnamed_addr constant [6 x i8] c"a->bs\00", align 1
@__PRETTY_FUNCTION__.bdrv_a_allow_b = private unnamed_addr constant [57 x i8] c"_Bool bdrv_a_allow_b(BdrvChild *, BdrvChild *, Error **)\00", align 1
@.str.190 = private unnamed_addr constant [15 x i8] c"a->bs == b->bs\00", align 1
@__func__.bdrv_a_allow_b = private unnamed_addr constant [15 x i8] c"bdrv_a_allow_b\00", align 1
@.str.191 = private unnamed_addr constant [157 x i8] c"Permission conflict on node '%s': permissions '%s' are both required by %s (uses node '%s' as '%s' child) and unshared by %s (uses node '%s' as '%s' child).\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_user_desc = private unnamed_addr constant [40 x i8] c"char *bdrv_child_user_desc(BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_node_refresh_perm = private unnamed_addr constant [92 x i8] c"int bdrv_node_refresh_perm(BlockDriverState *, BlockReopenQueue *, Transaction *, Error **)\00", align 1
@__func__.bdrv_node_refresh_perm = private unnamed_addr constant [23 x i8] c"bdrv_node_refresh_perm\00", align 1
@.str.192 = private unnamed_addr constant [24 x i8] c"Block node is read-only\00", align 1
@.str.193 = private unnamed_addr constant [58 x i8] c"Read-only block node '%s' cannot support read-write users\00", align 1
@.str.194 = private unnamed_addr constant [98 x i8] c"Cannot get 'write' permission without 'resize': Image size is not a multiple of request alignment\00", align 1
@.str.195 = private unnamed_addr constant [27 x i8] c"QLIST_EMPTY(&bs->children)\00", align 1
@__PRETTY_FUNCTION__.bdrv_drv_set_perm = private unnamed_addr constant [87 x i8] c"int bdrv_drv_set_perm(BlockDriverState *, uint64_t, uint64_t, Transaction *, Error **)\00", align 1
@.str.196 = private unnamed_addr constant [36 x i8] c"bs->drv && bs->drv->bdrv_child_perm\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_perm = private unnamed_addr constant [153 x i8] c"void bdrv_child_perm(BlockDriverState *, BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_filter_default_perms = private unnamed_addr constant [143 x i8] c"void bdrv_filter_default_perms(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_default_perms_for_cow = private unnamed_addr constant [144 x i8] c"void bdrv_default_perms_for_cow(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_default_perms_for_storage = private unnamed_addr constant [148 x i8] c"void bdrv_default_perms_for_storage(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@.str.199 = private unnamed_addr constant [29 x i8] c"child_class->get_parent_desc\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_child_common = private unnamed_addr constant [162 x i8] c"BdrvChild *bdrv_attach_child_common(BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, uint64_t, uint64_t, void *, Transaction *, Error **)\00", align 1
@bdrv_attach_child_common_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_attach_child_common_abort, ptr null, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_attach_child_common_abort = private unnamed_addr constant [44 x i8] c"void bdrv_attach_child_common_abort(void *)\00", align 1
@.str.200 = private unnamed_addr constant [12 x i8] c"ret == true\00", align 1
@.str.201 = private unnamed_addr constant [15 x i8] c"parent_bs->drv\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_child_noperm = private unnamed_addr constant [154 x i8] c"BdrvChild *bdrv_attach_child_noperm(BlockDriverState *, BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, Transaction *, Error **)\00", align 1
@__func__.bdrv_attach_child_noperm = private unnamed_addr constant [25 x i8] c"bdrv_attach_child_noperm\00", align 1
@.str.202 = private unnamed_addr constant [52 x i8] c"Making '%s' a %s child of '%s' would create a cycle\00", align 1
@.str.203 = private unnamed_addr constant [15 x i8] c"!child->frozen\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_noperm = private unnamed_addr constant [64 x i8] c"void bdrv_replace_child_noperm(BdrvChild *, BlockDriverState *)\00", align 1
@.str.204 = private unnamed_addr constant [34 x i8] c"!new_bs || child->quiesced_parent\00", align 1
@.str.205 = private unnamed_addr constant [17 x i8] c"old_bs != new_bs\00", align 1
@.str.206 = private unnamed_addr constant [61 x i8] c"bdrv_get_aio_context(old_bs) == bdrv_get_aio_context(new_bs)\00", align 1
@.str.207 = private unnamed_addr constant [11 x i8] c"!child->bs\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_free = private unnamed_addr constant [34 x i8] c"void bdrv_child_free(BdrvChild *)\00", align 1
@.str.208 = private unnamed_addr constant [21 x i8] c"!child->next.le_prev\00", align 1
@bdrv_set_inherits_from_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_set_inherits_from_abort, ptr null, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_set_file_or_backing_noperm = private unnamed_addr constant [108 x i8] c"int bdrv_set_file_or_backing_noperm(BlockDriverState *, BlockDriverState *, _Bool, Transaction *, Error **)\00", align 1
@__func__.bdrv_set_file_or_backing_noperm = private unnamed_addr constant [32 x i8] c"bdrv_set_file_or_backing_noperm\00", align 1
@.str.209 = private unnamed_addr constant [15 x i8] c"Node corrupted\00", align 1
@.str.210 = private unnamed_addr constant [49 x i8] c"Cannot change frozen '%s' link from '%s' to '%s'\00", align 1
@.str.211 = private unnamed_addr constant [56 x i8] c"Driver '%s' of node '%s' does not support backing files\00", align 1
@.str.212 = private unnamed_addr constant [56 x i8] c"Cannot set file child to format node without file child\00", align 1
@.str.213 = private unnamed_addr constant [27 x i8] c"child->bs->quiesce_counter\00", align 1
@.str.214 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@.str.215 = private unnamed_addr constant [23 x i8] c"child->quiesced_parent\00", align 1
@__PRETTY_FUNCTION__.bdrv_remove_child = private unnamed_addr constant [51 x i8] c"void bdrv_remove_child(BdrvChild *, Transaction *)\00", align 1
@bdrv_remove_child_drv = internal global %struct.TransactionActionDrv { ptr null, ptr @bdrv_remove_child_commit, ptr null }, align 8
@__PRETTY_FUNCTION__.bdrv_remove_child_commit = private unnamed_addr constant [38 x i8] c"void bdrv_remove_child_commit(void *)\00", align 1
@.str.216 = private unnamed_addr constant [20 x i8] c"child_class != NULL\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_child_bs = private unnamed_addr constant [150 x i8] c"BlockDriverState *bdrv_open_child_bs(const char *, QDict *, const char *, BlockDriverState *, const BdrvChildClass *, BdrvChildRole, _Bool, Error **)\00", align 1
@__func__.bdrv_open_child_bs = private unnamed_addr constant [19 x i8] c"bdrv_open_child_bs\00", align 1
@.str.217 = private unnamed_addr constant [42 x i8] c"A block device must be specified for \22%s\22\00", align 1
@.str.218 = private unnamed_addr constant [59 x i8] c"QTYPE_NONE < obj->base.type && obj->base.type < QTYPE__MAX\00", align 1
@__PRETTY_FUNCTION__.qobject_type = private unnamed_addr constant [36 x i8] c"QType qobject_type(const QObject *)\00", align 1
@.str.219 = private unnamed_addr constant [23 x i8] c"!child_class || !flags\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_inherit = private unnamed_addr constant [147 x i8] c"BlockDriverState *bdrv_open_inherit(const char *, const char *, QDict *, int, BlockDriverState *, const BdrvChildClass *, BdrvChildRole, Error **)\00", align 1
@.str.220 = private unnamed_addr constant [24 x i8] c"!child_class == !parent\00", align 1
@.str.221 = private unnamed_addr constant [21 x i8] c"!qemu_in_coroutine()\00", align 1
@__func__.bdrv_open_inherit = private unnamed_addr constant [18 x i8] c"bdrv_open_inherit\00", align 1
@.str.222 = private unnamed_addr constant [84 x i8] c"Cannot reference an existing block device with additional options or a new filename\00", align 1
@.str.223 = private unnamed_addr constant [38 x i8] c"drvname || !(flags & BDRV_O_PROTOCOL)\00", align 1
@.str.224 = private unnamed_addr constant [64 x i8] c"Use of \22backing\22: \22\22 is deprecated; use \22backing\22: null instead\00", align 1
@.str.225 = private unnamed_addr constant [35 x i8] c"Must specify either driver or file\00", align 1
@.str.226 = private unnamed_addr constant [53 x i8] c"!!(flags & BDRV_O_PROTOCOL) == !!drv->bdrv_file_open\00", align 1
@.str.227 = private unnamed_addr constant [36 x i8] c"!(flags & BDRV_O_PROTOCOL) || !file\00", align 1
@.str.228 = private unnamed_addr constant [52 x i8] c"Block protocol '%s' doesn't support the option '%s'\00", align 1
@.str.229 = private unnamed_addr constant [51 x i8] c"Block format '%s' does not support the option '%s'\00", align 1
@__PRETTY_FUNCTION__.parse_json_protocol = private unnamed_addr constant [59 x i8] c"void parse_json_protocol(QDict *, const char **, Error **)\00", align 1
@__PRETTY_FUNCTION__.parse_json_filename = private unnamed_addr constant [51 x i8] c"QDict *parse_json_filename(const char *, Error **)\00", align 1
@.str.230 = private unnamed_addr constant [4 x i8] c"ret\00", align 1
@.str.231 = private unnamed_addr constant [35 x i8] c"Could not parse the JSON options: \00", align 1
@__func__.parse_json_filename = private unnamed_addr constant [20 x i8] c"parse_json_filename\00", align 1
@.str.232 = private unnamed_addr constant [26 x i8] c"Invalid JSON object given\00", align 1
@__PRETTY_FUNCTION__.bdrv_fill_options = private unnamed_addr constant [63 x i8] c"int bdrv_fill_options(QDict **, const char *, int *, Error **)\00", align 1
@__func__.bdrv_fill_options = private unnamed_addr constant [18 x i8] c"bdrv_fill_options\00", align 1
@.str.233 = private unnamed_addr constant [20 x i8] c"Unknown driver '%s'\00", align 1
@.str.234 = private unnamed_addr constant [61 x i8] c"Can't specify 'file' and 'filename' options at the same time\00", align 1
@.str.235 = private unnamed_addr constant [17 x i8] c"drv || !protocol\00", align 1
@__PRETTY_FUNCTION__.bdrv_temp_snapshot_options = private unnamed_addr constant [62 x i8] c"void bdrv_temp_snapshot_options(int *, QDict *, int, QDict *)\00", align 1
@__PRETTY_FUNCTION__.find_image_format = private unnamed_addr constant [78 x i8] c"int find_image_format(BlockBackend *, const char *, BlockDriver **, Error **)\00", align 1
@bdrv_raw = external local_unnamed_addr global %struct.BlockDriver, align 8
@__func__.find_image_format = private unnamed_addr constant [18 x i8] c"find_image_format\00", align 1
@.str.236 = private unnamed_addr constant [48 x i8] c"Could not read image for determining its format\00", align 1
@.str.237 = private unnamed_addr constant [61 x i8] c"Could not determine image format: No compatible driver found\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_common = private unnamed_addr constant [76 x i8] c"int bdrv_open_common(BlockDriverState *, BlockBackend *, QDict *, Error **)\00", align 1
@.str.238 = private unnamed_addr constant [17 x i8] c"bs->file == NULL\00", align 1
@.str.239 = private unnamed_addr constant [42 x i8] c"options != NULL && bs->options != options\00", align 1
@.str.240 = private unnamed_addr constant [12 x i8] c"drv != NULL\00", align 1
@__func__.bdrv_open_common = private unnamed_addr constant [17 x i8] c"bdrv_open_common\00", align 1
@.str.241 = private unnamed_addr constant [54 x i8] c"force-share=on can only be used with read-only images\00", align 1
@.str.242 = private unnamed_addr constant [43 x i8] c"The '%s' block driver requires a file name\00", align 1
@.str.245 = private unnamed_addr constant [37 x i8] c"qatomic_read(&bs->copy_on_read) == 0\00", align 1
@.str.246 = private unnamed_addr constant [43 x i8] c"Can't use copy-on-read on read-only device\00", align 1
@.str.247 = private unnamed_addr constant [23 x i8] c"Invalid discard option\00", align 1
@.str.248 = private unnamed_addr constant [37 x i8] c"!drv->bdrv_file_open || file == NULL\00", align 1
@__PRETTY_FUNCTION__.update_flags_from_options = private unnamed_addr constant [50 x i8] c"void update_flags_from_options(int *, QemuOpts *)\00", align 1
@trace_events_enabled_count = external local_unnamed_addr global i32, align 4
@_TRACE_BDRV_OPEN_COMMON_DSTATE = external local_unnamed_addr global i16, align 2
@message_with_timestamp = external local_unnamed_addr global i8, align 1
@.str.249 = private unnamed_addr constant [79 x i8] c"%d@%zu.%06zu:bdrv_open_common bs %p filename \22%s\22 flags 0x%x format_name \22%s\22\0A\00", align 1
@.str.250 = private unnamed_addr constant [66 x i8] c"bdrv_open_common bs %p filename \22%s\22 flags 0x%x format_name \22%s\22\0A\00", align 1
@qemu_loglevel = external local_unnamed_addr global i32, align 4
@BlockdevDetectZeroesOptions_lookup = external constant %struct.QEnumLookup, align 8
@__PRETTY_FUNCTION__.bdrv_parse_detect_zeroes = private unnamed_addr constant [80 x i8] c"BlockdevDetectZeroesOptions bdrv_parse_detect_zeroes(QemuOpts *, int, Error **)\00", align 1
@__func__.bdrv_parse_detect_zeroes = private unnamed_addr constant [25 x i8] c"bdrv_parse_detect_zeroes\00", align 1
@.str.251 = private unnamed_addr constant [89 x i8] c"setting detect-zeroes to unmap is not allowed without setting discard operation to unmap\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_flags = private unnamed_addr constant [45 x i8] c"int bdrv_open_flags(BlockDriverState *, int)\00", align 1
@__PRETTY_FUNCTION__.bdrv_parent_cb_change_media = private unnamed_addr constant [60 x i8] c"void bdrv_parent_cb_change_media(BlockDriverState *, _Bool)\00", align 1
@__PRETTY_FUNCTION__.bdrv_append_temp_snapshot = private unnamed_addr constant [88 x i8] c"BlockDriverState *bdrv_append_temp_snapshot(BlockDriverState *, int, QDict *, Error **)\00", align 1
@__func__.bdrv_append_temp_snapshot = private unnamed_addr constant [26 x i8] c"bdrv_append_temp_snapshot\00", align 1
@.str.252 = private unnamed_addr constant [25 x i8] c"Could not get image size\00", align 1
@bdrv_qcow2 = external global %struct.BlockDriver, align 8
@.str.253 = private unnamed_addr constant [42 x i8] c"Could not create temporary overlay '%s': \00", align 1
@.str.254 = private unnamed_addr constant [12 x i8] c"file.driver\00", align 1
@.str.255 = private unnamed_addr constant [6 x i8] c"qcow2\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_queue_child = private unnamed_addr constant [158 x i8] c"BlockReopenQueue *bdrv_reopen_queue_child(BlockReopenQueue *, BlockDriverState *, QDict *, const BdrvChildClass *, BdrvChildRole, _Bool, QDict *, int, _Bool)\00", align 1
@.str.256 = private unnamed_addr constant [15 x i8] c"backing.driver\00", align 1
@__PRETTY_FUNCTION__.bdrv_join_options = private unnamed_addr constant [61 x i8] c"void bdrv_join_options(BlockDriverState *, QDict *, QDict *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_prepare = private unnamed_addr constant [88 x i8] c"int bdrv_reopen_prepare(BDRVReopenState *, BlockReopenQueue *, Transaction *, Error **)\00", align 1
@.str.258 = private unnamed_addr constant [30 x i8] c"reopen_state->bs->drv != NULL\00", align 1
@.str.259 = private unnamed_addr constant [33 x i8] c"old_flags == reopen_state->flags\00", align 1
@__func__.bdrv_reopen_prepare = private unnamed_addr constant [20 x i8] c"bdrv_reopen_prepare\00", align 1
@.str.260 = private unnamed_addr constant [44 x i8] c"failed while preparing to reopen image '%s'\00", align 1
@.str.261 = private unnamed_addr constant [69 x i8] c"Block format '%s' used by node '%s' does not support reopening files\00", align 1
@.str.262 = private unnamed_addr constant [28 x i8] c"backing is missing for '%s'\00", align 1
@.str.263 = private unnamed_addr constant [30 x i8] c"Cannot change the option '%s'\00", align 1
@__const.bdrv_reset_options_allowed.common_options = private unnamed_addr constant [8 x ptr] [ptr @.str.44, ptr @.str.57, ptr @.str.47, ptr @.str.49, ptr @.str.51, ptr @.str.53, ptr @.str.55, ptr null], align 16
@__func__.bdrv_reset_options_allowed = private unnamed_addr constant [27 x i8] c"bdrv_reset_options_allowed\00", align 1
@.str.264 = private unnamed_addr constant [49 x i8] c"Option '%s' cannot be reset to its default value\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_parse_file_or_backing = private unnamed_addr constant [89 x i8] c"int bdrv_reopen_parse_file_or_backing(BDRVReopenState *, _Bool, Transaction *, Error **)\00", align 1
@.str.265 = private unnamed_addr constant [11 x i8] c"is_backing\00", align 1
@__func__.bdrv_reopen_parse_file_or_backing = private unnamed_addr constant [34 x i8] c"bdrv_reopen_parse_file_or_backing\00", align 1
@.str.266 = private unnamed_addr constant [39 x i8] c"Cannot replace implicit %s child of %s\00", align 1
@.str.267 = private unnamed_addr constant [58 x i8] c"'%s' is a %s filter node that does not support a %s child\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_commit = private unnamed_addr constant [43 x i8] c"void bdrv_reopen_commit(BDRVReopenState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_abort = private unnamed_addr constant [42 x i8] c"void bdrv_reopen_abort(BDRVReopenState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_node_common = private unnamed_addr constant [93 x i8] c"int bdrv_replace_node_common(BlockDriverState *, BlockDriverState *, _Bool, _Bool, Error **)\00", align 1
@.str.268 = private unnamed_addr constant [22 x i8] c"from->quiesce_counter\00", align 1
@.str.269 = private unnamed_addr constant [20 x i8] c"to->quiesce_counter\00", align 1
@.str.270 = private unnamed_addr constant [55 x i8] c"bdrv_get_aio_context(from) == bdrv_get_aio_context(to)\00", align 1
@.str.271 = private unnamed_addr constant [30 x i8] c"bdrv_chain_contains(from, to)\00", align 1
@.str.272 = private unnamed_addr constant [11 x i8] c"from != to\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_node_noperm = private unnamed_addr constant [101 x i8] c"int bdrv_replace_node_noperm(BlockDriverState *, BlockDriverState *, _Bool, Transaction *, Error **)\00", align 1
@.str.273 = private unnamed_addr constant [14 x i8] c"c->bs == from\00", align 1
@__func__.bdrv_replace_node_noperm = private unnamed_addr constant [25 x i8] c"bdrv_replace_node_noperm\00", align 1
@.str.274 = private unnamed_addr constant [36 x i8] c"Should not change '%s' link to '%s'\00", align 1
@.str.275 = private unnamed_addr constant [32 x i8] c"Cannot change '%s' link to '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_tran = private unnamed_addr constant [77 x i8] c"void bdrv_replace_child_tran(BdrvChild *, BlockDriverState *, Transaction *)\00", align 1
@.str.276 = private unnamed_addr constant [35 x i8] c"!new_bs || new_bs->quiesce_counter\00", align 1
@bdrv_replace_child_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_replace_child_abort, ptr @bdrv_replace_child_commit, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_replace_child_abort = private unnamed_addr constant [38 x i8] c"void bdrv_replace_child_abort(void *)\00", align 1
@.str.277 = private unnamed_addr constant [43 x i8] c"!bdrv_parent_drained_poll_single(s->child)\00", align 1
@.str.278 = private unnamed_addr constant [26 x i8] c"s->child->quiesced_parent\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_commit = private unnamed_addr constant [39 x i8] c"void bdrv_replace_child_commit(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_is_backing_chain_frozen = private unnamed_addr constant [85 x i8] c"_Bool bdrv_is_backing_chain_frozen(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_is_backing_chain_frozen = private unnamed_addr constant [29 x i8] c"bdrv_is_backing_chain_frozen\00", align 1
@.str.279 = private unnamed_addr constant [42 x i8] c"Cannot change '%s' link from '%s' to '%s'\00", align 1
@__PRETTY_FUNCTION__.xdbg_graph_add_edge = private unnamed_addr constant [81 x i8] c"void xdbg_graph_add_edge(XDbgBlockGraphConstructor *, void *, const BdrvChild *)\00", align 1
@.str.280 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/thread.h\00", align 1
@qemu_mutex_lock_func = external local_unnamed_addr global ptr, align 8
@__PRETTY_FUNCTION__.bdrv_find_debug_node = private unnamed_addr constant [59 x i8] c"BlockDriverState *bdrv_find_debug_node(BlockDriverState *)\00", align 1
@.str.281 = private unnamed_addr constant [38 x i8] c"bs->drv->bdrv_debug_remove_breakpoint\00", align 1
@__PRETTY_FUNCTION__.bdrv_has_bds_parent = private unnamed_addr constant [53 x i8] c"_Bool bdrv_has_bds_parent(BlockDriverState *, _Bool)\00", align 1
@__PRETTY_FUNCTION__.bdrv_inactivate_recurse = private unnamed_addr constant [48 x i8] c"int bdrv_inactivate_recurse(BlockDriverState *)\00", align 1
@_TRACE_BDRV_LOCK_MEDIUM_DSTATE = external local_unnamed_addr global i16, align 2
@.str.282 = private unnamed_addr constant [47 x i8] c"%d@%zu.%06zu:bdrv_lock_medium bs %p locked %d\0A\00", align 1
@.str.283 = private unnamed_addr constant [34 x i8] c"bdrv_lock_medium bs %p locked %d\0A\00", align 1
@.str.284 = private unnamed_addr constant [29 x i8] c"bdrv_op_blocker_is_empty(bs)\00", align 1
@__PRETTY_FUNCTION__.bdrv_delete = private unnamed_addr constant [37 x i8] c"void bdrv_delete(BlockDriverState *)\00", align 1
@.str.285 = private unnamed_addr constant [12 x i8] c"!bs->refcnt\00", align 1
@__PRETTY_FUNCTION__.bdrv_close = private unnamed_addr constant [36 x i8] c"void bdrv_close(BlockDriverState *)\00", align 1
@.str.286 = private unnamed_addr constant [32 x i8] c"QLIST_EMPTY(&bs->dirty_bitmaps)\00", align 1
@__PRETTY_FUNCTION__.bdrv_change_aio_context = private unnamed_addr constant [103 x i8] c"_Bool bdrv_change_aio_context(BlockDriverState *, AioContext *, GHashTable *, Transaction *, Error **)\00", align 1
@set_aio_context = internal global %struct.TransactionActionDrv { ptr null, ptr @bdrv_set_aio_context_commit, ptr @bdrv_set_aio_context_clean }, align 8
@__PRETTY_FUNCTION__.bdrv_parent_change_aio_context = private unnamed_addr constant [103 x i8] c"_Bool bdrv_parent_change_aio_context(BdrvChild *, AioContext *, GHashTable *, Transaction *, Error **)\00", align 1
@__func__.bdrv_parent_change_aio_context = private unnamed_addr constant [31 x i8] c"bdrv_parent_change_aio_context\00", align 1
@.str.287 = private unnamed_addr constant [42 x i8] c"Changing iothreads is not supported by %s\00", align 1
@.str.288 = private unnamed_addr constant [15 x i8] c"!errp || *errp\00", align 1
@.str.289 = private unnamed_addr constant [27 x i8] c"!bs->walking_aio_notifiers\00", align 1
@__PRETTY_FUNCTION__.bdrv_detach_aio_context = private unnamed_addr constant [49 x i8] c"void bdrv_detach_aio_context(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_aio_context = private unnamed_addr constant [63 x i8] c"void bdrv_attach_aio_context(BlockDriverState *, AioContext *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_remove_aio_context_notifier = private unnamed_addr constant [60 x i8] c"void bdrv_do_remove_aio_context_notifier(BdrvAioNotifier *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_overridden = private unnamed_addr constant [50 x i8] c"_Bool bdrv_backing_overridden(BlockDriverState *)\00", align 1
@.str.290 = private unnamed_addr constant [25 x i8] c"strlen(*option_name) > 0\00", align 1
@__PRETTY_FUNCTION__.append_strong_runtime_options = private unnamed_addr constant [65 x i8] c"_Bool append_strong_runtime_options(QDict *, BlockDriverState *)\00", align 1
@strong_options.global_options = internal constant [3 x ptr] [ptr @.str.20, ptr @.str.5, ptr null], align 16
@.str.291 = private unnamed_addr constant [32 x i8] c"!bs->drv || !bs->drv->is_filter\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_skip_filters = private unnamed_addr constant [66 x i8] c"BlockDriverState *bdrv_do_skip_filters(BlockDriverState *, _Bool)\00", align 1
@.str.292 = private unnamed_addr constant [97 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/rcu.h\00", align 1
@rcu_gp_ctr = external local_unnamed_addr global i64, align 8
@.str.293 = private unnamed_addr constant [25 x i8] c"p_rcu_reader->depth != 0\00", align 1
@__PRETTY_FUNCTION__.rcu_read_unlock = private unnamed_addr constant [27 x i8] c"void rcu_read_unlock(void)\00", align 1
@rcu_gp_event = external global %struct.QemuEvent, align 4
@.str.294 = private unnamed_addr constant [16 x i8] c"no_coroutine_fn\00", section "llvm.metadata"
@.str.295 = private unnamed_addr constant [112 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/sysemu/block-backend-io.h\00", section "llvm.metadata"
@.str.296 = private unnamed_addr constant [19 x i8] c"coroutine_mixed_fn\00", section "llvm.metadata"
@.str.297 = private unnamed_addr constant [16 x i8] c"../qemu/block.c\00", section "llvm.metadata"
@.str.298 = private unnamed_addr constant [105 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/graph-lock.h\00", section "llvm.metadata"
@.str.299 = private unnamed_addr constant [98 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/aio.h\00", section "llvm.metadata"
@.str.300 = private unnamed_addr constant [122 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/sysemu/block-backend-global-state.h\00", section "llvm.metadata"
@.str.301 = private unnamed_addr constant [107 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block_int-io.h\00", section "llvm.metadata"
@.str.302 = private unnamed_addr constant [103 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block-io.h\00", section "llvm.metadata"
@.str.303 = private unnamed_addr constant [108 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/coroutine-core.h\00", section "llvm.metadata"
@.str.304 = private unnamed_addr constant [113 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block-global-state.h\00", section "llvm.metadata"
@llvm.global.annotations = appending global [61 x { ptr, ptr, ptr, i32, ptr }] [{ ptr, ptr, ptr, i32, ptr } { ptr @blk_getlength, ptr @.str.294, ptr @.str.295, i32 81, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_getlength, ptr @.str.296, ptr @.str.295, i32 81, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_unref, ptr @.str.294, ptr @.str.297, i32 7245, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_child, ptr @.str.294, ptr @.str.297, i32 3774, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_graph_wrunlock, ptr @.str.294, ptr @.str.298, i32 130, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_driver, ptr @.str.294, ptr @.str.297, i32 1625, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_change_backing_file, ptr @.str.13, ptr @.str.297, i32 5773, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @aio_co_reschedule_self, ptr @.str.13, ptr @.str.299, i32 645, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @create_file_fallback_zero_first_sector, ptr @.str.13, ptr @.str.297, i32 604, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_create, ptr @.str.13, ptr @.str.297, i32 534, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_check, ptr @.str.13, ptr @.str.297, i32 5748, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @create_file_fallback_truncate, ptr @.str.13, ptr @.str.297, i32 563, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_debug_event, ptr @.str.13, ptr @.str.297, i32 6721, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_enter, ptr @.str.13, ptr @.str.297, i32 7561, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_graph_wrunlock_ctx, ptr @.str.294, ptr @.str.298, i32 140, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_get_info, ptr @.str.13, ptr @.str.297, i32 6662, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_is_inserted, ptr @.str.294, ptr @.str.295, i32 69, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_is_inserted, ptr @.str.296, ptr @.str.295, i32 69, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_create_opts_simple, ptr @.str.13, ptr @.str.297, i32 631, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_new_open, ptr @.str.13, ptr @.str.300, i32 40, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_refresh_total_sectors, ptr @.str.294, ptr @.str.301, i32 131, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_refresh_total_sectors, ptr @.str.296, ptr @.str.301, i32 131, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_is_inserted, ptr @.str.13, ptr @.str.297, i32 7184, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_delete_file_noerr, ptr @.str.13, ptr @.str.297, i32 770, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_has_zero_init, ptr @.str.296, ptr @.str.297, i32 6618, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_eject, ptr @.str.13, ptr @.str.297, i32 7208, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_activate, ptr @.str.294, ptr @.str.297, i32 6937, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_graph_wrlock, ptr @.str.294, ptr @.str.298, i32 120, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_flush, ptr @.str.294, ptr @.str.302, i32 372, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_flush, ptr @.str.296, ptr @.str.302, i32 372, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_blockdev_ref, ptr @.str.294, ptr @.str.297, i32 3835, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_lock, ptr @.str.13, ptr @.str.297, i32 7586, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open, ptr @.str.294, ptr @.str.297, i32 4267, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_create_file, ptr @.str.13, ptr @.str.297, i32 693, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_invalidate_cache, ptr @.str.294, ptr @.str.302, i32 370, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_invalidate_cache, ptr @.str.296, ptr @.str.302, i32 370, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_inherit, ptr @.str.294, ptr @.str.297, i32 3962, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @qemu_co_mutex_unlock, ptr @.str.13, ptr @.str.303, i32 152, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_unref, ptr @.str.13, ptr @.str.300, i32 47, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_getlength, ptr @.str.13, ptr @.str.295, i32 80, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_nb_sectors, ptr @.str.13, ptr @.str.297, i32 6160, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_unlock, ptr @.str.13, ptr @.str.297, i32 7603, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_get_allocated_file_size, ptr @.str.13, ptr @.str.297, i32 6092, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_refresh_total_sectors, ptr @.str.13, ptr @.str.297, i32 1051, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_change_backing_file, ptr @.str.294, ptr @.str.302, i32 218, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_pwrite_zeroes, ptr @.str.13, ptr @.str.295, i32 190, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_invalidate_cache, ptr @.str.13, ptr @.str.297, i32 7012, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_getlength, ptr @.str.13, ptr @.str.297, i32 6204, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_nb_sectors, ptr @.str.296, ptr @.str.297, i32 6182, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_pread, ptr @.str.294, ptr @.str.295, i32 138, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_pread, ptr @.str.296, ptr @.str.295, i32 138, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_create, ptr @.str.294, ptr @.str.304, i32 65, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_getlength, ptr @.str.294, ptr @.str.302, i32 85, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_getlength, ptr @.str.296, ptr @.str.302, i32 85, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_delete_file, ptr @.str.13, ptr @.str.297, i32 742, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_leave, ptr @.str.13, ptr @.str.297, i32 7579, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @qemu_co_mutex_lock, ptr @.str.13, ptr @.str.303, i32 146, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_sum_allocated_file_size, ptr @.str.13, ptr @.str.297, i32 6068, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_truncate, ptr @.str.13, ptr @.str.295, i32 226, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_lock_medium, ptr @.str.13, ptr @.str.297, i32 7223, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_unref, ptr @.str.294, ptr @.str.300, i32 46, ptr null }], section "llvm.metadata"

; Function Attrs: mustprogress nofree nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local i64 @bdrv_opt_mem_align(ptr noundef readonly %bs) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then, label %do.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call.i = tail call i32 @getpagesize() #27
  %1 = tail call i32 @llvm.umax.i32(i32 %call.i, i32 4096)
  %cond = sext i32 %1 to i64
  br label %return

do.end:                                           ; preds = %lor.lhs.false
  %opt_mem_alignment = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 10
  %2 = load i64, ptr %opt_mem_alignment, align 8
  br label %return

return:                                           ; preds = %do.end, %if.then
  %retval.0 = phi i64 [ %2, %do.end ], [ %cond, %if.then ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local i64 @bdrv_min_mem_align(ptr noundef readonly %bs) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then, label %do.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call.i = tail call i32 @getpagesize() #27
  %1 = tail call i32 @llvm.umax.i32(i32 %call.i, i32 4096)
  %cond = sext i32 %1 to i64
  br label %return

do.end:                                           ; preds = %lor.lhs.false
  %min_mem_alignment = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 9
  %2 = load i64, ptr %min_mem_alignment, align 8
  br label %return

return:                                           ; preds = %do.end, %if.then
  %retval.0 = phi i64 [ %2, %do.end ], [ %cond, %if.then ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local i32 @path_has_protocol(ptr nocapture noundef readonly %path) local_unnamed_addr #1 {
entry:
  %call = tail call i64 @strcspn(ptr noundef %path, ptr noundef nonnull @.str) #28
  %add.ptr = getelementptr i8, ptr %path, i64 %call
  %0 = load i8, ptr %add.ptr, align 1
  %cmp = icmp eq i8 %0, 58
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strcspn(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local i32 @path_is_absolute(ptr nocapture noundef readonly %path) local_unnamed_addr #3 {
entry:
  %0 = load i8, ptr %path, align 1
  %cmp = icmp eq i8 %0, 47
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @path_combine(ptr noundef %base_path, ptr noundef %filename) local_unnamed_addr #4 {
entry:
  %0 = load i8, ptr %filename, align 1
  %cmp.i.not = icmp eq i8 %0, 47
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call noalias ptr @g_strdup(ptr noundef nonnull %filename) #29
  br label %return

if.end:                                           ; preds = %entry
  %call.i = tail call i64 @strcspn(ptr noundef %base_path, ptr noundef nonnull @.str) #28
  %add.ptr.i = getelementptr i8, ptr %base_path, i64 %call.i
  %1 = load i8, ptr %add.ptr.i, align 1
  %cmp.i20.not = icmp eq i8 %1, 58
  br i1 %cmp.i20.not, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.end
  %call5 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %base_path, i32 noundef 58) #28
  %tobool6.not = icmp eq ptr %call5, null
  %incdec.ptr = getelementptr i8, ptr %call5, i64 1
  %spec.select = select i1 %tobool6.not, ptr null, ptr %incdec.ptr
  br label %if.end9

if.end9:                                          ; preds = %if.then4, %if.end
  %protocol_stripped.0 = phi ptr [ null, %if.end ], [ %spec.select, %if.then4 ]
  %tobool10.not = icmp eq ptr %protocol_stripped.0, null
  %cond = select i1 %tobool10.not, ptr %base_path, ptr %protocol_stripped.0
  %call11 = tail call ptr @strrchr(ptr noundef nonnull dereferenceable(1) %base_path, i32 noundef 47) #28
  %tobool12.not = icmp eq ptr %call11, null
  %incdec.ptr14 = getelementptr i8, ptr %call11, i64 1
  %p1.0 = select i1 %tobool12.not, ptr %base_path, ptr %incdec.ptr14
  %cmp = icmp ugt ptr %p1.0, %cond
  %p.0 = select i1 %cmp, ptr %p1.0, ptr %cond
  %sub.ptr.lhs.cast = ptrtoint ptr %p.0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %base_path to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sext = shl i64 %sub.ptr.sub, 32
  %conv18 = ashr exact i64 %sext, 32
  %call19 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %filename) #28
  %add = add i64 %call19, 1
  %add20 = add i64 %add, %conv18
  %call21 = tail call noalias ptr @g_malloc(i64 noundef %add20) #30
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call21, ptr nonnull align 1 %base_path, i64 %conv18, i1 false)
  %add.ptr = getelementptr i8, ptr %call21, i64 %conv18
  %call23 = tail call ptr @strcpy(ptr noundef nonnull dereferenceable(1) %add.ptr, ptr noundef nonnull dereferenceable(1) %filename) #29
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %retval.0 = phi ptr [ %call1, %if.then ], [ %call21, %if.end9 ]
  ret ptr %retval.0
}

declare noalias ptr @g_strdup(ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strchr(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strrchr(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc(i64 noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #7

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: readwrite)
declare ptr @strcpy(ptr noalias noundef returned writeonly, ptr noalias nocapture noundef readonly) local_unnamed_addr #8

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_parse_filename_strip_prefix(ptr noundef %filename, ptr noundef %prefix, ptr noundef %options) local_unnamed_addr #4 {
entry:
  %filename.addr = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  %call = call i32 @strstart(ptr noundef %filename, ptr noundef %prefix, ptr noundef nonnull %filename.addr) #29
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end19, label %if.then

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr %filename.addr, align 8
  %call.i = call i64 @strcspn(ptr noundef %0, ptr noundef nonnull @.str) #28
  %add.ptr.i = getelementptr i8, ptr %0, i64 %call.i
  %1 = load i8, ptr %add.ptr.i, align 1
  %cmp.i.not = icmp eq i8 %1, 58
  br i1 %cmp.i.not, label %if.then3, label %if.else17

if.then3:                                         ; preds = %if.then
  %2 = load i8, ptr %0, align 1
  %cmp.i5.not = icmp eq i8 %2, 47
  br i1 %cmp.i5.not, label %if.else, label %if.end

if.else:                                          ; preds = %if.then3
  call void @__assert_fail(ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2, i32 noundef 253, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parse_filename_strip_prefix) #31
  unreachable

if.end:                                           ; preds = %if.then3
  %call7 = call ptr @g_string_new(ptr noundef nonnull @.str.3) #29
  %3 = load ptr, ptr %filename.addr, align 8
  %call8 = call ptr @g_string_append(ptr noundef %call7, ptr noundef %3) #29
  %4 = load ptr, ptr %call7, align 8
  %call.i7 = call i64 @strcspn(ptr noundef %4, ptr noundef nonnull @.str) #28
  %add.ptr.i8 = getelementptr i8, ptr %4, i64 %call.i7
  %5 = load i8, ptr %add.ptr.i8, align 1
  %cmp.i9.not = icmp eq i8 %5, 58
  br i1 %cmp.i9.not, label %if.else12, label %if.end13

if.else12:                                        ; preds = %if.end
  call void @__assert_fail(ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.2, i32 noundef 260, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parse_filename_strip_prefix) #31
  unreachable

if.end13:                                         ; preds = %if.end
  %call14 = call ptr @qstring_from_gstring(ptr noundef nonnull %call7) #29
  call void @qdict_put_obj(ptr noundef %options, ptr noundef nonnull @.str.5, ptr noundef %call14) #29
  br label %if.end19

if.else17:                                        ; preds = %if.then
  call void @qdict_put_str(ptr noundef %options, ptr noundef nonnull @.str.5, ptr noundef nonnull %0) #29
  br label %if.end19

if.end19:                                         ; preds = %if.end13, %if.else17, %entry
  ret void
}

declare i32 @strstart(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: noreturn nounwind
declare void @__assert_fail(ptr noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #9

declare ptr @g_string_new(ptr noundef) local_unnamed_addr #5

declare ptr @g_string_append(ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @qdict_put_obj(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qstring_from_gstring(ptr noundef) local_unnamed_addr #5

declare void @qdict_put_str(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local zeroext i1 @bdrv_is_read_only(ptr nocapture noundef readonly %bs) local_unnamed_addr #3 {
entry:
  %0 = load i32, ptr %bs, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  ret i1 %tobool.not
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_apply_auto_read_only(ptr noundef %bs, ptr noundef %errmsg, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %0 = load i32, ptr %bs, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and2 = and i32 %0, 131072
  %tobool3.not = icmp eq i32 %and2, 0
  br i1 %tobool3.not, label %fail, label %if.end5

if.end5:                                          ; preds = %if.end
  %copy_on_read.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 42
  %1 = load i32, ptr %copy_on_read.i, align 8
  %tobool.not.i.not = icmp eq i32 %1, 0
  br i1 %tobool.not.i.not, label %if.end7, label %if.then.i

if.then.i:                                        ; preds = %if.end5
  %parents.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.07.i.i.i = load ptr, ptr %parents.i.i.i, align 8
  %tobool.not8.i.i.i = icmp eq ptr %c.07.i.i.i, null
  br i1 %tobool.not8.i.i.i, label %bdrv_can_set_read_only.exit.thread, label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %if.then.i, %for.inc.i.i.i
  %c.09.i.i.i = phi ptr [ %c.0.i.i.i, %for.inc.i.i.i ], [ %c.07.i.i.i, %if.then.i ]
  %klass.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i, i64 0, i32 2
  %2 = load ptr, ptr %klass.i.i.i, align 8
  %get_name.i.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %2, i64 0, i32 15
  %3 = load ptr, ptr %get_name.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i.i, label %for.inc.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %for.body.i.i.i
  %call.i.i.i = tail call ptr %3(ptr noundef nonnull %c.09.i.i.i) #29
  %tobool4.not.i.i.i = icmp eq ptr %call.i.i.i, null
  br i1 %tobool4.not.i.i.i, label %for.inc.i.i.i, label %land.lhs.true.i.i.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i.i
  %4 = load i8, ptr %call.i.i.i, align 1
  %tobool5.not.i.i.i = icmp eq i8 %4, 0
  br i1 %tobool5.not.i.i.i, label %for.inc.i.i.i, label %bdrv_can_set_read_only.exit.thread

for.inc.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %if.then.i.i.i, %for.body.i.i.i
  %next_parent.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i, i64 0, i32 10
  %c.0.i.i.i = load ptr, ptr %next_parent.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %c.0.i.i.i, null
  br i1 %tobool.not.i.i.i, label %bdrv_can_set_read_only.exit.thread, label %for.body.i.i.i, !llvm.loop !5

bdrv_can_set_read_only.exit.thread:               ; preds = %land.lhs.true.i.i.i, %for.inc.i.i.i, %if.then.i
  %retval.0.i.i.i = phi ptr [ null, %if.then.i ], [ %call.i.i.i, %land.lhs.true.i.i.i ], [ null, %for.inc.i.i.i ]
  %tobool.not.i.i = icmp eq ptr %retval.0.i.i.i, null
  %node_name.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 22
  %cond.i.i = select i1 %tobool.not.i.i, ptr %node_name.i.i, ptr %retval.0.i.i.i
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 291, ptr noundef nonnull @__func__.bdrv_can_set_read_only, ptr noundef nonnull @.str.156, ptr noundef nonnull %cond.i.i) #29
  br label %fail

if.end7:                                          ; preds = %if.end5
  %and9 = and i32 %0, -3
  store i32 %and9, ptr %bs, align 8
  br label %return

fail:                                             ; preds = %bdrv_can_set_read_only.exit.thread, %if.end
  %tobool10.not = icmp eq ptr %errmsg, null
  %..str.7 = select i1 %tobool10.not, ptr @.str.7, ptr %errmsg
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 340, ptr noundef nonnull @__func__.bdrv_apply_auto_read_only, ptr noundef nonnull @.str.6, ptr noundef nonnull %..str.7) #29
  br label %return

return:                                           ; preds = %entry, %fail, %if.end7
  %retval.0 = phi i32 [ -13, %fail ], [ 0, %if.end7 ], [ 0, %entry ]
  ret i32 %retval.0
}

declare void @error_setg_internal(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef, ...) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_full_backing_filename_from_filename(ptr noundef %backed, ptr noundef %backing, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %0 = load i8, ptr %backing, align 1
  %cmp = icmp eq i8 %0, 0
  br i1 %cmp, label %return, label %if.else

if.else:                                          ; preds = %entry
  %call.i = tail call i64 @strcspn(ptr noundef nonnull %backing, ptr noundef nonnull @.str) #28
  %add.ptr.i = getelementptr i8, ptr %backing, i64 %call.i
  %1 = load i8, ptr %add.ptr.i, align 1
  %cmp.i.not = icmp eq i8 %1, 58
  %cmp.i8.not = icmp eq i8 %0, 47
  %or.cond = or i1 %cmp.i8.not, %cmp.i.not
  br i1 %or.cond, label %if.then4, label %if.else6

if.then4:                                         ; preds = %if.else
  %call5 = tail call noalias ptr @g_strdup(ptr noundef nonnull %backing) #29
  br label %return

if.else6:                                         ; preds = %if.else
  %2 = load i8, ptr %backed, align 1
  %cmp9 = icmp eq i8 %2, 0
  br i1 %cmp9, label %if.then14, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.else6
  %call12 = tail call i32 @strstart(ptr noundef nonnull %backed, ptr noundef nonnull @.str.8, ptr noundef null) #29
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.else15, label %if.then14

if.then14:                                        ; preds = %lor.lhs.false11, %if.else6
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 363, ptr noundef nonnull @__func__.bdrv_get_full_backing_filename_from_filename, ptr noundef nonnull @.str.9, ptr noundef nonnull %backed) #29
  br label %return

if.else15:                                        ; preds = %lor.lhs.false11
  %call16 = tail call ptr @path_combine(ptr noundef nonnull %backed, ptr noundef nonnull %backing)
  br label %return

return:                                           ; preds = %entry, %if.else15, %if.then14, %if.then4
  %retval.0 = phi ptr [ %call5, %if.then4 ], [ null, %if.then14 ], [ %call16, %if.else15 ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local noalias ptr @bdrv_get_full_backing_filename(ptr noundef %bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 399, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_full_backing_filename) #31
  unreachable

do.end:                                           ; preds = %entry
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 12
  %0 = load i8, ptr %backing_file, align 1
  %cmp.i = icmp eq i8 %0, 0
  br i1 %cmp.i, label %bdrv_make_absolute_filename.exit, label %if.else.i

if.else.i:                                        ; preds = %do.end
  %call.i.i = tail call i64 @strcspn(ptr noundef nonnull %backing_file, ptr noundef nonnull @.str) #28
  %add.ptr.i.i = getelementptr i8, ptr %backing_file, i64 %call.i.i
  %1 = load i8, ptr %add.ptr.i.i, align 1
  %cmp.i.not.i = icmp eq i8 %1, 58
  %cmp.i8.not.i = icmp eq i8 %0, 47
  %or.cond.i = or i1 %cmp.i8.not.i, %cmp.i.not.i
  br i1 %or.cond.i, label %if.then6.i, label %if.end8.i

if.then6.i:                                       ; preds = %if.else.i
  %call7.i = tail call noalias ptr @g_strdup(ptr noundef nonnull %backing_file) #29
  br label %bdrv_make_absolute_filename.exit

if.end8.i:                                        ; preds = %if.else.i
  %call9.i = tail call ptr @bdrv_dirname(ptr noundef nonnull %bs, ptr noundef %errp)
  %tobool10.not.i = icmp eq ptr %call9.i, null
  br i1 %tobool10.not.i, label %bdrv_make_absolute_filename.exit, label %if.end12.i

if.end12.i:                                       ; preds = %if.end8.i
  %call13.i = tail call noalias ptr (ptr, ...) @g_strconcat(ptr noundef nonnull %call9.i, ptr noundef nonnull %backing_file, ptr noundef null) #29
  tail call void @g_free(ptr noundef nonnull %call9.i) #29
  br label %bdrv_make_absolute_filename.exit

bdrv_make_absolute_filename.exit:                 ; preds = %do.end, %if.then6.i, %if.end8.i, %if.end12.i
  %retval.0.i = phi ptr [ %call7.i, %if.then6.i ], [ %call13.i, %if.end12.i ], [ null, %do.end ], [ null, %if.end8.i ]
  ret ptr %retval.0.i
}

declare zeroext i1 @qemu_in_main_thread() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_register(ptr noundef %bdrv) local_unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %bdrv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.else, label %do.body

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.11, ptr noundef nonnull @.str.2, i32 noundef 405, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_register) #31
  unreachable

do.body:                                          ; preds = %entry
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.body4, label %if.else2

if.else2:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 406, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_register) #31
  unreachable

do.body4:                                         ; preds = %do.body
  %1 = load ptr, ptr @bdrv_drivers, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %bdrv, i64 0, i32 61
  store ptr %1, ptr %list, align 8
  %cmp.not = icmp eq ptr %1, null
  br i1 %cmp.not, label %if.end9, label %if.then5

if.then5:                                         ; preds = %do.body4
  %le_prev = getelementptr inbounds %struct.BlockDriver, ptr %1, i64 0, i32 61, i32 1
  store ptr %list, ptr %le_prev, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %do.body4
  store ptr %bdrv, ptr @bdrv_drivers, align 8
  %le_prev11 = getelementptr inbounds %struct.BlockDriver, ptr %bdrv, i64 0, i32 61, i32 1
  store ptr @bdrv_drivers, ptr %le_prev11, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_new() local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 415, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_new) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call noalias dereferenceable_or_null(17144) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 17144) #32
  %dirty_bitmaps = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 40
  store ptr null, ptr %dirty_bitmaps, align 8
  %scevgep = getelementptr i8, ptr %call1, i64 16688
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(128) %scevgep, i8 0, i64 128, i1 false)
  %reqs_lock = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 48
  tail call void @qemu_mutex_init(ptr noundef nonnull %reqs_lock) #29
  %dirty_bitmap_mutex = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 39
  tail call void @qemu_mutex_init(ptr noundef nonnull %dirty_bitmap_mutex) #29
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 26
  store i32 1, ptr %refcnt, align 8
  %call7 = tail call ptr @qemu_get_aio_context() #29
  %aio_context = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 8
  store ptr %call7, ptr %aio_context, align 8
  %flush_queue = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 50
  tail call void @qemu_co_queue_init(ptr noundef nonnull %flush_queue) #29
  %bsc_modify_lock = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 54
  tail call void @qemu_co_mutex_init(ptr noundef nonnull %bsc_modify_lock) #29
  %call8 = tail call noalias dereferenceable_or_null(40) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 40) #32
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 55
  store ptr %call8, ptr %block_status_cache, align 8
  %0 = load i32, ptr @bdrv_drain_all_count, align 4
  %cmp1020.not = icmp eq i32 %0, 0
  br i1 %cmp1020.not, label %do.body15, label %for.body11

for.body11:                                       ; preds = %do.end, %for.body11
  %i.121 = phi i32 [ %inc13, %for.body11 ], [ 0, %do.end ]
  tail call void @bdrv_drained_begin(ptr noundef %call1) #29
  %inc13 = add nuw i32 %i.121, 1
  %1 = load i32, ptr @bdrv_drain_all_count, align 4
  %cmp10 = icmp ult i32 %inc13, %1
  br i1 %cmp10, label %for.body11, label %do.body15, !llvm.loop !7

do.body15:                                        ; preds = %for.body11, %do.end
  %bs_list = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 24
  store ptr null, ptr %bs_list, align 8
  %2 = load ptr, ptr getelementptr inbounds (%union.anon.11, ptr @all_bdrv_states, i64 0, i32 0, i32 1), align 8
  %tql_prev = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 24, i32 0, i32 1
  store ptr %2, ptr %tql_prev, align 8
  store ptr %call1, ptr %2, align 8
  store ptr %bs_list, ptr getelementptr inbounds (%union.anon.11, ptr @all_bdrv_states, i64 0, i32 0, i32 1), align 8
  ret ptr %call1
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc0_n(i64 noundef, i64 noundef) local_unnamed_addr #10

declare void @qemu_mutex_init(ptr noundef) local_unnamed_addr #5

declare ptr @qemu_get_aio_context() local_unnamed_addr #5

declare void @qemu_co_queue_init(ptr noundef) local_unnamed_addr #5

declare void @qemu_co_mutex_init(ptr noundef) local_unnamed_addr #5

declare void @bdrv_drained_begin(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_format(ptr nocapture noundef readonly %format_name) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_format) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %for.cond.preheader.i, label %if.else.i

for.cond.preheader.i:                             ; preds = %do.end
  %drv1.04.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not5.i = icmp eq ptr %drv1.04.i, null
  br i1 %tobool.not5.i, label %bdrv_do_find_format.exit, label %for.body.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 444, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_format) #31
  unreachable

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %drv1.06.i = phi ptr [ %drv1.0.i, %for.inc.i ], [ %drv1.04.i, %for.cond.preheader.i ]
  %0 = load ptr, ptr %drv1.06.i, align 8
  %call2.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull dereferenceable(1) %format_name) #28
  %tobool3.not.i = icmp eq i32 %call2.i, 0
  br i1 %tobool3.not.i, label %bdrv_do_find_format.exit, label %for.inc.i

for.inc.i:                                        ; preds = %for.body.i
  %list.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i, i64 0, i32 61
  %drv1.0.i = load ptr, ptr %list.i, align 8
  %tobool.not.i = icmp eq ptr %drv1.0.i, null
  br i1 %tobool.not.i, label %bdrv_do_find_format.exit, label %for.body.i, !llvm.loop !8

bdrv_do_find_format.exit:                         ; preds = %for.body.i, %for.inc.i, %for.cond.preheader.i
  %drv1.0.lcssa.i = phi ptr [ null, %for.cond.preheader.i ], [ %drv1.06.i, %for.body.i ], [ null, %for.inc.i ]
  ret ptr %drv1.0.lcssa.i
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #2

declare void @error_report_err(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_is_whitelisted(ptr nocapture noundef readnone %drv, i1 noundef zeroext %read_only) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 517, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_is_whitelisted) #31
  unreachable

do.end:                                           ; preds = %entry
  ret i32 1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local zeroext i1 @bdrv_uses_whitelist() local_unnamed_addr #11 {
entry:
  %.b = load i1, ptr @use_bdrv_whitelist, align 4
  ret i1 %.b
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_create(ptr noundef %drv, ptr noundef %filename, ptr noundef %opts, ptr noundef %errp) #4 {
entry:
  %_auto_errp_prop = alloca %struct.ErrorPropagator, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 538, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_create) #31
  unreachable

do.end:                                           ; preds = %entry
  store ptr null, ptr %_auto_errp_prop, align 8
  %errp1 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i64 0, i32 1
  store ptr %errp, ptr %errp1, align 8
  %tobool = icmp eq ptr %errp, null
  %cmp = icmp eq ptr %errp, @error_fatal
  %or.cond = or i1 %tobool, %cmp
  %spec.select = select i1 %or.cond, ptr %_auto_errp_prop, ptr %errp
  %bdrv_co_create_opts = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 27
  %0 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_create_opts, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 259, ptr null)
  %1 = load ptr, ptr %0, align 8
  %tobool7.not = icmp eq ptr %1, null
  br i1 %tobool7.not, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.end
  %2 = load ptr, ptr %drv, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %spec.select, ptr noundef nonnull @.str.2, i32 noundef 543, ptr noundef nonnull @__func__.bdrv_co_create, ptr noundef nonnull @.str.15, ptr noundef %2) #29
  br label %cleanup

if.end9:                                          ; preds = %do.end
  %3 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_create_opts, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 259, ptr null)
  %4 = load ptr, ptr %3, align 8
  %call11 = call i32 %4(ptr noundef %drv, ptr noundef %filename, ptr noundef %opts, ptr noundef nonnull %spec.select) #29
  %cmp12 = icmp slt i32 %call11, 0
  br i1 %cmp12, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end9
  %5 = load ptr, ptr %spec.select, align 8
  %tobool13.not = icmp eq ptr %5, null
  br i1 %tobool13.not, label %if.then14, label %cleanup

if.then14:                                        ; preds = %land.lhs.true
  %sub = sub i32 0, %call11
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef nonnull %spec.select, ptr noundef nonnull @.str.2, i32 noundef 549, ptr noundef nonnull @__func__.bdrv_co_create, i32 noundef %sub, ptr noundef nonnull @.str.16) #29
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %land.lhs.true, %if.then14, %if.then8
  %retval.0 = phi i32 [ -95, %if.then8 ], [ %call11, %if.then14 ], [ %call11, %land.lhs.true ], [ %call11, %if.end9 ]
  %_auto_errp_prop.val = load ptr, ptr %_auto_errp_prop, align 8
  %_auto_errp_prop.val12 = load ptr, ptr %errp1, align 8
  call void @error_propagate(ptr noundef %_auto_errp_prop.val12, ptr noundef %_auto_errp_prop.val) #29
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare ptr @llvm.ptr.annotation.p0.p0(ptr, ptr, ptr, i32, ptr) #12

declare void @error_setg_errno_internal(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_create_opts_simple(ptr nocapture noundef readonly %drv, ptr noundef %filename, ptr noundef %opts, ptr noundef %errp) #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 644, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_create_opts_simple) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call i64 @qemu_opt_get_size_del(ptr noundef %opts, ptr noundef nonnull @.str.17, i64 noundef 0) #29
  %call2 = tail call ptr @qemu_opt_get_del(ptr noundef %opts, ptr noundef nonnull @.str.18) #29
  %call3 = call i32 @qapi_enum_parse(ptr noundef nonnull @PreallocMode_lookup, ptr noundef %call2, i32 noundef 0, ptr noundef nonnull %local_err) #29
  call void @g_free(ptr noundef %call2) #29
  %0 = load ptr, ptr %local_err, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end5, label %if.then4

if.then4:                                         ; preds = %do.end
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %0) #29
  br label %return

if.end5:                                          ; preds = %do.end
  %cmp.not = icmp eq i32 %call3, 0
  br i1 %cmp.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end5
  %call7 = call ptr @qapi_enum_lookup(ptr noundef nonnull @PreallocMode_lookup, i32 noundef %call3) #29
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 658, ptr noundef nonnull @__func__.bdrv_co_create_opts_simple, ptr noundef nonnull @.str.19, ptr noundef %call7) #29
  br label %return

if.end8:                                          ; preds = %if.end5
  %call9 = call ptr @qdict_new() #29
  %1 = load ptr, ptr %drv, align 8
  call void @qdict_put_str(ptr noundef %call9, ptr noundef nonnull @.str.20, ptr noundef %1) #29
  %call10 = call ptr @blk_co_new_open(ptr noundef %filename, ptr noundef null, ptr noundef %call9, i32 noundef 6, ptr noundef %errp) #29
  %tobool11.not = icmp eq ptr %call10, null
  br i1 %tobool11.not, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %2 = load ptr, ptr %drv, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %errp, ptr noundef nonnull @.str.21, ptr noundef %2) #29
  br label %return

if.end14:                                         ; preds = %if.end8
  %call15 = call i64 @create_file_fallback_truncate(ptr noundef nonnull %call10, i64 noundef %call1, ptr noundef %errp)
  %cmp16 = icmp slt i64 %call15, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %conv = trunc i64 %call15 to i32
  br label %out

if.end18:                                         ; preds = %if.end14
  %call.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.end18
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 611, ptr noundef nonnull @__PRETTY_FUNCTION__.create_file_fallback_zero_first_sector) #31
  unreachable

do.end.i:                                         ; preds = %if.end18
  %tobool.not.i = icmp eq i64 %call15, 0
  br i1 %tobool.not.i, label %out, label %if.then1.i

if.then1.i:                                       ; preds = %do.end.i
  %cond.i = call i64 @llvm.umin.i64(i64 %call15, i64 512)
  %call2.i = call i32 @blk_co_pwrite_zeroes(ptr noundef nonnull %call10, i64 noundef 0, i64 noundef %cond.i, i32 noundef 4) #29
  %cmp3.i = icmp slt i32 %call2.i, 0
  br i1 %cmp3.i, label %if.then4.i, label %out

if.then4.i:                                       ; preds = %if.then1.i
  %sub.i = sub i32 0, %call2.i
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 618, ptr noundef nonnull @__func__.create_file_fallback_zero_first_sector, i32 noundef %sub.i, ptr noundef nonnull @.str.159) #29
  br label %out

out:                                              ; preds = %if.then4.i, %if.then1.i, %do.end.i, %if.then17
  %ret.0 = phi i32 [ %conv, %if.then17 ], [ %call2.i, %if.then4.i ], [ 0, %if.then1.i ], [ 0, %do.end.i ]
  call void @blk_co_unref(ptr noundef nonnull %call10) #29
  br label %return

return:                                           ; preds = %out, %if.then12, %if.then6, %if.then4
  %retval.0 = phi i32 [ -22, %if.then4 ], [ -95, %if.then6 ], [ %ret.0, %out ], [ -22, %if.then12 ]
  ret i32 %retval.0
}

declare i64 @qemu_opt_get_size_del(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #5

declare ptr @qemu_opt_get_del(ptr noundef, ptr noundef) local_unnamed_addr #5

declare i32 @qapi_enum_parse(ptr noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #5

declare void @g_free(ptr noundef) #5

declare void @error_propagate(ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qapi_enum_lookup(ptr noundef, i32 noundef) local_unnamed_addr #5

declare ptr @qdict_new() local_unnamed_addr #5

declare ptr @blk_co_new_open(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef) #5

declare void @error_prepend(ptr noundef, ptr noundef, ...) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @create_file_fallback_truncate(ptr noundef %blk, i64 noundef %minimum_size, ptr noundef %errp) #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 570, ptr noundef nonnull @__PRETTY_FUNCTION__.create_file_fallback_truncate) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = call i32 @blk_co_truncate(ptr noundef %blk, i64 noundef %minimum_size, i1 noundef zeroext false, i32 noundef 0, i32 noundef 0, ptr noundef nonnull %local_err) #29
  %cmp = icmp slt i32 %call1, 0
  %cmp2 = icmp ne i32 %call1, -95
  %or.cond = and i1 %cmp, %cmp2
  br i1 %or.cond, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.end
  %0 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %0) #29
  %conv = sext i32 %call1 to i64
  br label %return

if.end4:                                          ; preds = %do.end
  %call5 = call i64 @blk_co_getlength(ptr noundef %blk) #29
  %cmp6 = icmp slt i64 %call5, 0
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end4
  %1 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %1) #29
  %2 = trunc i64 %call5 to i32
  %conv9 = sub i32 0, %2
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 583, ptr noundef nonnull @__func__.create_file_fallback_truncate, i32 noundef %conv9, ptr noundef nonnull @.str.158) #29
  br label %return

if.end10:                                         ; preds = %if.end4
  %cmp11 = icmp slt i64 %call5, %minimum_size
  %3 = load ptr, ptr %local_err, align 8
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  call void @error_propagate(ptr noundef %errp, ptr noundef %3) #29
  br label %return

if.end14:                                         ; preds = %if.end10
  call void @error_free(ptr noundef %3) #29
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then8, %if.then3
  %retval.0 = phi i64 [ %conv, %if.then3 ], [ %call5, %if.then8 ], [ -95, %if.then13 ], [ %call5, %if.end14 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @create_file_fallback_zero_first_sector(ptr noundef %blk, i64 noundef %current_size, ptr noundef %errp) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 611, ptr noundef nonnull @__PRETTY_FUNCTION__.create_file_fallback_zero_first_sector) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq i64 %current_size, 0
  br i1 %tobool.not, label %return, label %if.then1

if.then1:                                         ; preds = %do.end
  %cond = tail call i64 @llvm.umin.i64(i64 %current_size, i64 512)
  %call2 = tail call i32 @blk_co_pwrite_zeroes(ptr noundef %blk, i64 noundef 0, i64 noundef %cond, i32 noundef 4) #29
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %return

if.then4:                                         ; preds = %if.then1
  %sub = sub i32 0, %call2
  tail call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 618, ptr noundef nonnull @__func__.create_file_fallback_zero_first_sector, i32 noundef %sub, ptr noundef nonnull @.str.159) #29
  br label %return

return:                                           ; preds = %do.end, %if.then1, %if.then4
  %retval.0 = phi i32 [ %call2, %if.then4 ], [ 0, %if.then1 ], [ 0, %do.end ]
  ret i32 %retval.0
}

declare void @blk_co_unref(ptr noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_create_file(ptr noundef %filename, ptr noundef %opts, ptr noundef %errp) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 701, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_create_file) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call ptr @bdrv_find_protocol(ptr noundef %filename, i1 noundef zeroext true, ptr noundef %errp)
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %return, label %if.end3

if.end3:                                          ; preds = %do.end
  %create_opts = getelementptr inbounds %struct.BlockDriver, ptr %call1, i64 0, i32 9
  %0 = load ptr, ptr %create_opts, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end3
  %1 = load ptr, ptr %call1, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 710, ptr noundef nonnull @__func__.bdrv_co_create_file, ptr noundef nonnull @.str.15, ptr noundef %1) #29
  br label %return

if.end5:                                          ; preds = %if.end3
  %call6 = tail call ptr @qemu_opts_to_qdict(ptr noundef %opts, ptr noundef null) #29
  %2 = load ptr, ptr %create_opts, align 8
  %call8 = tail call ptr @qemu_opts_from_qdict(ptr noundef %2, ptr noundef %call6, ptr noundef %errp) #29
  %cmp9 = icmp eq ptr %call8, null
  br i1 %cmp9, label %out, label %if.end11

if.end11:                                         ; preds = %if.end5
  %call12 = tail call i32 @bdrv_co_create(ptr noundef nonnull %call1, ptr noundef %filename, ptr noundef nonnull %call8, ptr noundef %errp)
  br label %out

out:                                              ; preds = %if.end5, %if.end11
  %ret.0 = phi i32 [ %call12, %if.end11 ], [ -22, %if.end5 ]
  tail call void @qemu_opts_del(ptr noundef %call8) #29
  %tobool13.not = icmp eq ptr %call6, null
  br i1 %tobool13.not, label %return, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %out
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %call6, i64 0, i32 1
  %3 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %3, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %3, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %return

if.then5.i:                                       ; preds = %land.lhs.true.i
  tail call void @qobject_destroy(ptr noundef nonnull %call6) #29
  br label %return

return:                                           ; preds = %if.then5.i, %land.lhs.true.i, %out, %do.end, %if.then4
  %retval.0 = phi i32 [ -95, %if.then4 ], [ -2, %do.end ], [ %ret.0, %out ], [ %ret.0, %land.lhs.true.i ], [ %ret.0, %if.then5.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_protocol(ptr noundef %filename, i1 noundef zeroext %allow_protocol_prefix, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %protocol = alloca [128 x i8], align 16
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 927, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_protocol) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %for.cond.preheader.i, label %if.else.i

for.cond.preheader.i:                             ; preds = %do.end
  %d.07.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not8.i = icmp eq ptr %d.07.i, null
  br i1 %tobool.not8.i, label %if.end3, label %for.body.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 888, ptr noundef nonnull @__PRETTY_FUNCTION__.find_hdev_driver) #31
  unreachable

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %d.011.i = phi ptr [ %d.0.i, %for.inc.i ], [ %d.07.i, %for.cond.preheader.i ]
  %drv.010.i = phi ptr [ %drv.1.i, %for.inc.i ], [ null, %for.cond.preheader.i ]
  %score_max.09.i = phi i32 [ %score_max.1.i, %for.inc.i ], [ 0, %for.cond.preheader.i ]
  %bdrv_probe_device.i = getelementptr inbounds %struct.BlockDriver, ptr %d.011.i, i64 0, i32 16
  %0 = load ptr, ptr %bdrv_probe_device.i, align 8
  %tobool1.not.i = icmp eq ptr %0, null
  br i1 %tobool1.not.i, label %for.inc.i, label %if.then2.i

if.then2.i:                                       ; preds = %for.body.i
  %call4.i = tail call i32 %0(ptr noundef %filename) #29
  %cmp.i = icmp sgt i32 %call4.i, %score_max.09.i
  %spec.select.i = tail call i32 @llvm.smax.i32(i32 %call4.i, i32 %score_max.09.i)
  %spec.select6.i = select i1 %cmp.i, ptr %d.011.i, ptr %drv.010.i
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then2.i, %for.body.i
  %score_max.1.i = phi i32 [ %score_max.09.i, %for.body.i ], [ %spec.select.i, %if.then2.i ]
  %drv.1.i = phi ptr [ %drv.010.i, %for.body.i ], [ %spec.select6.i, %if.then2.i ]
  %list.i = getelementptr inbounds %struct.BlockDriver, ptr %d.011.i, i64 0, i32 61
  %d.0.i = load ptr, ptr %list.i, align 8
  %tobool.not.i = icmp eq ptr %d.0.i, null
  br i1 %tobool.not.i, label %find_hdev_driver.exit, label %for.body.i, !llvm.loop !9

find_hdev_driver.exit:                            ; preds = %for.inc.i
  %tobool.not = icmp eq ptr %drv.1.i, null
  br i1 %tobool.not, label %if.end3, label %return

if.end3:                                          ; preds = %for.cond.preheader.i, %find_hdev_driver.exit
  %call.i19 = tail call i64 @strcspn(ptr noundef %filename, ptr noundef nonnull @.str) #28
  %add.ptr.i = getelementptr i8, ptr %filename, i64 %call.i19
  %1 = load i8, ptr %add.ptr.i, align 1
  %cmp.i20 = icmp eq i8 %1, 58
  %brmerge.not = and i1 %cmp.i20, %allow_protocol_prefix
  br i1 %brmerge.not, label %if.end8, label %return

if.end8:                                          ; preds = %if.end3
  %call9 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %filename, i32 noundef 58) #28
  %cmp.not = icmp eq ptr %call9, null
  br i1 %cmp.not, label %if.else11, label %if.end12

if.else11:                                        ; preds = %if.end8
  tail call void @__assert_fail(ptr noundef nonnull @.str.29, ptr noundef nonnull @.str.2, i32 noundef 947, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_protocol) #31
  unreachable

if.end12:                                         ; preds = %if.end8
  %sub.ptr.lhs.cast = ptrtoint ptr %call9 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %filename to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %2 = and i64 %sub.ptr.sub, 4294967168
  %cmp14.not = icmp eq i64 %2, 0
  %sext = shl i64 %sub.ptr.sub, 32
  %3 = ashr exact i64 %sext, 32
  %conv18 = select i1 %cmp14.not, i64 %3, i64 127
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 16 %protocol, ptr nonnull align 1 %filename, i64 %conv18, i1 false)
  %arrayidx = getelementptr [128 x i8], ptr %protocol, i64 0, i64 %conv18
  store i8 0, ptr %arrayidx, align 1
  %call.i21 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i21, label %for.cond.preheader.i23, label %if.else.i22

for.cond.preheader.i23:                           ; preds = %if.end12
  %drv1.05.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not6.i = icmp eq ptr %drv1.05.i, null
  br i1 %tobool.not6.i, label %if.then52, label %for.body.i24

if.else.i22:                                      ; preds = %if.end12
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 906, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_protocol) #31
  unreachable

for.body.i24:                                     ; preds = %for.cond.preheader.i23, %for.inc.i26
  %drv1.07.i = phi ptr [ %drv1.0.i, %for.inc.i26 ], [ %drv1.05.i, %for.cond.preheader.i23 ]
  %protocol_name.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.07.i, i64 0, i32 8
  %4 = load ptr, ptr %protocol_name.i, align 8
  %tobool1.not.i25 = icmp eq ptr %4, null
  br i1 %tobool1.not.i25, label %for.inc.i26, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %for.body.i24
  %call3.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %4, ptr noundef nonnull dereferenceable(1) %protocol) #28
  %tobool4.not.i = icmp eq i32 %call3.i, 0
  br i1 %tobool4.not.i, label %return, label %for.inc.i26

for.inc.i26:                                      ; preds = %land.lhs.true.i, %for.body.i24
  %list.i27 = getelementptr inbounds %struct.BlockDriver, ptr %drv1.07.i, i64 0, i32 61
  %drv1.0.i = load ptr, ptr %list.i27, align 8
  %tobool.not.i28 = icmp eq ptr %drv1.0.i, null
  br i1 %tobool.not.i28, label %if.then52, label %for.body.i24, !llvm.loop !10

if.then52:                                        ; preds = %for.inc.i26, %for.cond.preheader.i23
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 973, ptr noundef nonnull @__func__.bdrv_find_protocol, ptr noundef nonnull @.str.30, ptr noundef nonnull %protocol) #29
  br label %return

return:                                           ; preds = %land.lhs.true.i, %if.end3, %find_hdev_driver.exit, %if.then52
  %retval.0 = phi ptr [ null, %if.then52 ], [ %drv.1.i, %find_hdev_driver.exit ], [ @bdrv_file, %if.end3 ], [ %drv1.07.i, %land.lhs.true.i ]
  ret ptr %retval.0
}

declare ptr @qemu_opts_to_qdict(ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qemu_opts_from_qdict(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @qemu_opts_del(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @qobject_unref_impl(ptr noundef %obj) unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %obj, null
  br i1 %tobool.not, label %if.end6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %refcnt = getelementptr inbounds %struct.QObjectBase_, ptr %obj, i64 0, i32 1
  %0 = load i64, ptr %refcnt, align 8
  %tobool1.not = icmp eq i64 %0, 0
  br i1 %tobool1.not, label %if.else, label %land.lhs.true

if.else:                                          ; preds = %lor.lhs.false
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true:                                    ; preds = %lor.lhs.false
  %dec = add i64 %0, -1
  store i64 %dec, ptr %refcnt, align 8
  %cmp = icmp eq i64 %dec, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  tail call void @qobject_destroy(ptr noundef nonnull %obj) #29
  br label %if.end6

if.end6:                                          ; preds = %entry, %if.then5, %land.lhs.true
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_delete_file(ptr noundef %bs, ptr noundef %errp) #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %cmp.not = icmp eq ptr %bs, null
  br i1 %cmp.not, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.22, ptr noundef nonnull @.str.2, i32 noundef 748, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_delete_file) #31
  unreachable

if.end:                                           ; preds = %entry
  tail call void @assert_bdrv_graph_readable() #29
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 752, ptr noundef nonnull @__func__.bdrv_co_delete_file, ptr noundef nonnull @.str.23, ptr noundef nonnull %filename) #29
  br label %return

if.end2:                                          ; preds = %if.end
  %bdrv_co_delete_file = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 84
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_delete_file, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 679, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool4.not = icmp eq ptr %2, null
  br i1 %tobool4.not, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end2
  %3 = load ptr, ptr %0, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 758, ptr noundef nonnull @__func__.bdrv_co_delete_file, ptr noundef nonnull @.str.24, ptr noundef %3) #29
  br label %return

if.end7:                                          ; preds = %if.end2
  %4 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_delete_file, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 679, ptr null)
  %5 = load ptr, ptr %4, align 8
  %call = call i32 %5(ptr noundef nonnull %bs, ptr noundef nonnull %local_err) #29
  %cmp10 = icmp slt i32 %call, 0
  br i1 %cmp10, label %if.then11, label %return

if.then11:                                        ; preds = %if.end7
  %6 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %6) #29
  br label %return

return:                                           ; preds = %if.end7, %if.then11, %if.then5, %if.then1
  %retval.0 = phi i32 [ -95, %if.then5 ], [ -123, %if.then1 ], [ %call, %if.then11 ], [ %call, %if.end7 ]
  ret i32 %retval.0
}

declare void @assert_bdrv_graph_readable() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_delete_file_noerr(ptr noundef %bs) #4 {
entry:
  %local_err.i = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %if.end5, label %if.end.i

if.end.i:                                         ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %local_err.i)
  store ptr null, ptr %local_err.i, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %if.else.thread11, label %if.end2.i

if.else.thread11:                                 ; preds = %if.end.i
  %filename.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 752, ptr noundef nonnull @__func__.bdrv_co_delete_file, ptr noundef nonnull @.str.23, ptr noundef nonnull %filename.i) #29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i)
  br label %if.then3

if.end2.i:                                        ; preds = %if.end.i
  %bdrv_co_delete_file.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 84
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_delete_file.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 679, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool4.not.i = icmp eq ptr %2, null
  br i1 %tobool4.not.i, label %bdrv_co_delete_file.exit.thread6, label %if.end7.i

bdrv_co_delete_file.exit.thread6:                 ; preds = %if.end2.i
  %3 = load ptr, ptr %0, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 758, ptr noundef nonnull @__func__.bdrv_co_delete_file, ptr noundef nonnull @.str.24, ptr noundef %3) #29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i)
  br label %if.then1

if.end7.i:                                        ; preds = %if.end2.i
  %4 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_delete_file.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 679, ptr null)
  %5 = load ptr, ptr %4, align 8
  %call.i = call i32 %5(ptr noundef nonnull %bs, ptr noundef nonnull %local_err.i) #29
  %cmp10.i = icmp slt i32 %call.i, 0
  br i1 %cmp10.i, label %bdrv_co_delete_file.exit, label %if.else

bdrv_co_delete_file.exit:                         ; preds = %if.end7.i
  %6 = load ptr, ptr %local_err.i, align 8
  call void @error_propagate(ptr noundef nonnull %local_err, ptr noundef %6) #29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i)
  %cmp = icmp eq i32 %call.i, -95
  br i1 %cmp, label %if.then1, label %if.then3

if.then1:                                         ; preds = %bdrv_co_delete_file.exit.thread6, %bdrv_co_delete_file.exit
  %7 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %7) #29
  br label %if.end5

if.else:                                          ; preds = %if.end7.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i)
  br label %if.end5

if.then3:                                         ; preds = %bdrv_co_delete_file.exit, %if.else.thread11
  %8 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %8) #29
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then3, %entry, %if.then1
  ret void
}

declare void @error_free(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_probe_blocksizes(ptr noundef %bs, ptr noundef %bsz) local_unnamed_addr #4 {
lor.lhs.false.i.i:
  br label %tailrecurse

tailrecurse:                                      ; preds = %if.else7, %lor.lhs.false.i.i
  %bs.tr = phi ptr [ %bs, %lor.lhs.false.i.i ], [ %cond.i.i, %if.else7 ]
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %tobool1.not.i.i = icmp eq ptr %0, null
  br i1 %tobool1.not.i.i, label %bdrv_filter_bs.exit.thread, label %if.end.i.i

if.end.i.i:                                       ; preds = %tailrecurse
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter.i.i, align 4
  %2 = and i8 %1, 1
  %tobool3.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool3.not.i.i, label %bdrv_filter_bs.exit, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 30
  %3 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %3, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 31
  %4 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %4, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %bdrv_filter_bs.exit, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %4, %cond.end.i.i ], [ %3, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %5 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %5, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %cond.true.i.i

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.true.i.i:                                    ; preds = %if.end15.i.i
  %6 = load ptr, ptr %cond12.i.i, align 8
  br label %bdrv_filter_bs.exit

bdrv_filter_bs.exit:                              ; preds = %if.end.i.i, %cond.end.i.i, %cond.true.i.i
  %cond.i.i = phi ptr [ %6, %cond.true.i.i ], [ null, %if.end.i.i ], [ null, %cond.end.i.i ]
  %call2 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call2, label %land.lhs.true, label %if.else

bdrv_filter_bs.exit.thread:                       ; preds = %tailrecurse
  %call29 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call29, label %return, label %if.else

if.else:                                          ; preds = %bdrv_filter_bs.exit, %bdrv_filter_bs.exit.thread
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 803, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_probe_blocksizes) #31
  unreachable

land.lhs.true:                                    ; preds = %bdrv_filter_bs.exit
  %bdrv_probe_blocksizes = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 51
  %7 = load ptr, ptr %bdrv_probe_blocksizes, align 8
  %tobool3.not = icmp eq ptr %7, null
  br i1 %tobool3.not, label %if.else7, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %call6 = tail call i32 %7(ptr noundef nonnull %bs.tr, ptr noundef %bsz) #29
  br label %return

if.else7:                                         ; preds = %land.lhs.true
  %tobool8.not = icmp eq ptr %cond.i.i, null
  br i1 %tobool8.not, label %return, label %tailrecurse

return:                                           ; preds = %if.else7, %bdrv_filter_bs.exit.thread, %if.then4
  %retval.0 = phi i32 [ %call6, %if.then4 ], [ -95, %bdrv_filter_bs.exit.thread ], [ -95, %if.else7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_probe_geometry(ptr noundef %bs, ptr noundef %geo) local_unnamed_addr #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 825, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_probe_geometry) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %lor.lhs.false.i.i, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end
  %bdrv_probe_geometry = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 52
  %1 = load ptr, ptr %bdrv_probe_geometry, align 8
  %tobool3.not = icmp eq ptr %1, null
  br i1 %tobool3.not, label %lor.lhs.false.i.i, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %call6 = tail call i32 %1(ptr noundef nonnull %bs, ptr noundef %geo) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

lor.lhs.false.i.i:                                ; preds = %do.end, %land.lhs.true
  %2 = load ptr, ptr %drv1, align 8
  %tobool1.not.i.i = icmp eq ptr %2, null
  br i1 %tobool1.not.i.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %lor.lhs.false.i.i
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %2, i64 0, i32 2
  %3 = load i8, ptr %is_filter.i.i, align 4
  %4 = and i8 %3, 1
  %tobool3.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool3.not.i.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %5 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %5, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 31
  %6 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %6, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %6, %cond.end.i.i ], [ %5, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %7 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %7, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %bdrv_filter_bs.exit

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

bdrv_filter_bs.exit:                              ; preds = %if.end15.i.i
  %8 = load ptr, ptr %cond12.i.i, align 8
  %tobool9.not = icmp eq ptr %8, null
  br i1 %tobool9.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.then10

if.then10:                                        ; preds = %bdrv_filter_bs.exit
  %call11 = tail call i32 @bdrv_probe_geometry(ptr noundef nonnull %8, ptr noundef %geo)
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %cond.end.i.i, %if.end.i.i, %lor.lhs.false.i.i, %bdrv_filter_bs.exit, %if.then10, %if.then4
  %retval.0 = phi i32 [ %call6, %if.then4 ], [ %call11, %if.then10 ], [ -95, %bdrv_filter_bs.exit ], [ -95, %lor.lhs.false.i.i ], [ -95, %if.end.i.i ], [ -95, %cond.end.i.i ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @create_tmp_file(ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @g_get_tmp_dir() #29
  %call1 = tail call i32 @g_strcmp0(ptr noundef %call, ptr noundef nonnull @.str.25) #29
  %tobool.not = icmp eq i32 %call1, 0
  %spec.select = select i1 %tobool.not, ptr @.str.26, ptr %call
  %call2 = tail call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef nonnull @.str.27, ptr noundef %spec.select) #29
  %call3 = tail call i32 @g_mkstemp(ptr noundef %call2) #29
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %if.then4, label %if.end6

if.then4:                                         ; preds = %entry
  %call5 = tail call ptr @__errno_location() #27
  %0 = load i32, ptr %call5, align 4
  tail call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 872, ptr noundef nonnull @__func__.create_tmp_file, i32 noundef %0, ptr noundef nonnull @.str.28, ptr noundef %call2) #29
  br label %cleanup

if.end6:                                          ; preds = %entry
  %call7 = tail call i32 @close(i32 noundef %call3) #29
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then4
  %filename.0 = phi ptr [ %call2, %if.then4 ], [ null, %if.end6 ]
  %retval.0 = phi ptr [ null, %if.then4 ], [ %call2, %if.end6 ]
  tail call void @g_free(ptr noundef %filename.0) #29
  ret ptr %retval.0
}

declare ptr @g_get_tmp_dir() local_unnamed_addr #5

declare i32 @g_strcmp0(ptr noundef, ptr noundef) local_unnamed_addr #5

declare noalias ptr @g_strdup_printf(ptr noundef, ...) local_unnamed_addr #5

declare i32 @g_mkstemp(ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #13

declare i32 @close(i32 noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_probe_all(ptr noundef %buf, i32 noundef %buf_size, ptr noundef %filename) local_unnamed_addr #4 {
entry:
  %d.07 = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not8 = icmp eq ptr %d.07, null
  br i1 %tobool.not8, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %d.011 = phi ptr [ %d.0, %for.inc ], [ %d.07, %entry ]
  %drv.010 = phi ptr [ %drv.1, %for.inc ], [ null, %entry ]
  %score_max.09 = phi i32 [ %score_max.1, %for.inc ], [ 0, %entry ]
  %bdrv_probe = getelementptr inbounds %struct.BlockDriver, ptr %d.011, i64 0, i32 62
  %0 = load ptr, ptr %bdrv_probe, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %call = tail call i32 %0(ptr noundef %buf, i32 noundef %buf_size, ptr noundef %filename) #29
  %cmp = icmp sgt i32 %call, %score_max.09
  %spec.select = tail call i32 @llvm.smax.i32(i32 %call, i32 %score_max.09)
  %spec.select6 = select i1 %cmp, ptr %d.011, ptr %drv.010
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %score_max.1 = phi i32 [ %score_max.09, %for.body ], [ %spec.select, %if.then ]
  %drv.1 = phi ptr [ %drv.010, %for.body ], [ %spec.select6, %if.then ]
  %list = getelementptr inbounds %struct.BlockDriver, ptr %d.011, i64 0, i32 61
  %d.0 = load ptr, ptr %list, align 8
  %tobool.not = icmp eq ptr %d.0, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !11

for.end:                                          ; preds = %for.inc, %entry
  %drv.0.lcssa = phi ptr [ null, %entry ], [ %drv.1, %for.inc ]
  ret ptr %drv.0.lcssa
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_refresh_total_sectors(ptr noundef %bs, i64 noundef %hint) #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sg.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 2
  %1 = load i8, ptr %sg.i, align 1
  %2 = and i8 %1, 1
  %tobool.i.not = icmp eq i8 %2, 0
  br i1 %tobool.i.not, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %bdrv_co_getlength = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 88
  %3 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_getlength, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 714, ptr null)
  %4 = load ptr, ptr %3, align 8
  %tobool4.not = icmp eq ptr %4, null
  br i1 %tobool4.not, label %if.end10, label %if.then5

if.then5:                                         ; preds = %if.end3
  %5 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_getlength, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 714, ptr null)
  %6 = load ptr, ptr %5, align 8
  %call7 = tail call i64 %6(ptr noundef nonnull %bs) #29
  %cmp = icmp slt i64 %call7, 0
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then5
  %conv = trunc i64 %call7 to i32
  br label %return

if.end9:                                          ; preds = %if.then5
  %sub = add nuw i64 %call7, 511
  %div9 = lshr i64 %sub, 9
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end3
  %hint.addr.0 = phi i64 [ %div9, %if.end9 ], [ %hint, %if.end3 ]
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  store i64 %hint.addr.0, ptr %total_sectors, align 8
  %mul = shl i64 %hint.addr.0, 9
  %cmp12 = icmp ugt i64 %mul, 9223372035781033984
  %. = select i1 %cmp12, i32 -27, i32 0
  br label %return

return:                                           ; preds = %if.end10, %if.end, %entry, %if.then8
  %retval.0 = phi i32 [ %conv, %if.then8 ], [ -123, %entry ], [ 0, %if.end ], [ %., %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local zeroext i1 @bdrv_is_sg(ptr nocapture noundef readonly %bs) local_unnamed_addr #3 {
entry:
  %sg = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 2
  %0 = load i8, ptr %sg, align 1
  %1 = and i8 %0, 1
  %tobool = icmp ne i8 %1, 0
  ret i1 %tobool
}

; Function Attrs: mustprogress nofree nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local i32 @bdrv_parse_aio(ptr nocapture noundef readonly %mode, ptr nocapture noundef %flags) local_unnamed_addr #14 {
entry:
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(8) @.str.31) #28
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.else

if.else:                                          ; preds = %entry
  %call1 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(7) @.str.32) #28
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %return.sink.split, label %if.else4

if.else4:                                         ; preds = %if.else
  %call5 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(9) @.str.33) #28
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %return.sink.split, label %return

return.sink.split:                                ; preds = %if.else4, %if.else
  %.sink4 = phi i32 [ 128, %if.else ], [ 262144, %if.else4 ]
  %0 = load i32, ptr %flags, align 4
  %or8 = or i32 %0, %.sink4
  store i32 %or8, ptr %flags, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %entry, %if.else4
  %retval.0 = phi i32 [ -1, %if.else4 ], [ 0, %entry ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local i32 @bdrv_parse_discard_flags(ptr nocapture noundef readonly %mode, ptr nocapture noundef %flags) local_unnamed_addr #14 {
entry:
  %0 = load i32, ptr %flags, align 4
  %and = and i32 %0, -16385
  store i32 %and, ptr %flags, align 4
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(4) @.str.34) #28
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call1 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(7) @.str.35) #28
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %return, label %if.else

if.else:                                          ; preds = %lor.lhs.false
  %call3 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(3) @.str.36) #28
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.then8, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %if.else
  %call6 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(6) @.str.37) #28
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.then8, label %return

if.then8:                                         ; preds = %lor.lhs.false5, %if.else
  %or = or i32 %0, 16384
  store i32 %or, ptr %flags, align 4
  br label %return

return:                                           ; preds = %if.then8, %lor.lhs.false, %entry, %lor.lhs.false5
  %retval.0 = phi i32 [ -1, %lor.lhs.false5 ], [ 0, %entry ], [ 0, %lor.lhs.false ], [ 0, %if.then8 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local i32 @bdrv_parse_cache_mode(ptr nocapture noundef readonly %mode, ptr nocapture noundef %flags, ptr nocapture noundef writeonly %writethrough) local_unnamed_addr #14 {
entry:
  %0 = load i32, ptr %flags, align 4
  %and = and i32 %0, -545
  store i32 %and, ptr %flags, align 4
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(4) @.str.34) #28
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call1 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(5) @.str.38) #28
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i8 0, ptr %writethrough, align 1
  %1 = load i32, ptr %flags, align 4
  %or = or i32 %1, 32
  store i32 %or, ptr %flags, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %call3 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(11) @.str.39) #28
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.else
  store i8 1, ptr %writethrough, align 1
  %2 = load i32, ptr %flags, align 4
  %or6 = or i32 %2, 32
  store i32 %or6, ptr %flags, align 4
  br label %return

if.else7:                                         ; preds = %if.else
  %call8 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(10) @.str.40) #28
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  store i8 0, ptr %writethrough, align 1
  br label %return

if.else11:                                        ; preds = %if.else7
  %call12 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(7) @.str.41) #28
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.then14, label %if.else16

if.then14:                                        ; preds = %if.else11
  store i8 0, ptr %writethrough, align 1
  %3 = load i32, ptr %flags, align 4
  %or15 = or i32 %3, 512
  store i32 %or15, ptr %flags, align 4
  br label %return

if.else16:                                        ; preds = %if.else11
  %call17 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %mode, ptr noundef nonnull dereferenceable(13) @.str.42) #28
  %tobool18.not = icmp eq i32 %call17, 0
  br i1 %tobool18.not, label %if.then19, label %return

if.then19:                                        ; preds = %if.else16
  store i8 1, ptr %writethrough, align 1
  br label %return

return:                                           ; preds = %if.then, %if.then10, %if.then19, %if.then14, %if.then5, %if.else16
  %retval.0 = phi i32 [ -1, %if.else16 ], [ 0, %if.then5 ], [ 0, %if.then14 ], [ 0, %if.then19 ], [ 0, %if.then10 ], [ 0, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @child_of_bds_get_parent_aio_context(ptr nocapture noundef readonly %c) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 8
  %1 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %1, %cond.true.i ], [ %call.i, %cond.false.i ]
  ret ptr %cond.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_aio_context(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %aio_context = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call ptr @qemu_get_aio_context() #29
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %0, %cond.true ], [ %call, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_inherited_options(i32 noundef %role, i1 noundef zeroext %parent_is_format, ptr nocapture noundef writeonly %child_flags, ptr noundef %child_options, i32 noundef %parent_flags, ptr noundef %parent_options) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1349, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_inherited_options) #31
  unreachable

do.end:                                           ; preds = %entry
  %and10 = and i32 %role, 8
  %tobool11.not = icmp eq i32 %and10, 0
  tail call void @qdict_copy_default(ptr noundef %child_options, ptr noundef %parent_options, ptr noundef nonnull @.str.47) #29
  tail call void @qdict_copy_default(ptr noundef %child_options, ptr noundef %parent_options, ptr noundef nonnull @.str.49) #29
  tail call void @qdict_copy_default(ptr noundef %child_options, ptr noundef %parent_options, ptr noundef nonnull @.str.59) #29
  br i1 %tobool11.not, label %if.else19, label %if.then18

if.then18:                                        ; preds = %do.end
  tail call void @qdict_set_default_str(ptr noundef %child_options, ptr noundef nonnull @.str.51, ptr noundef nonnull @.str.36) #29
  tail call void @qdict_set_default_str(ptr noundef %child_options, ptr noundef nonnull @.str.53, ptr noundef nonnull @.str.34) #29
  br label %if.end20

if.else19:                                        ; preds = %do.end
  tail call void @qdict_copy_default(ptr noundef %child_options, ptr noundef %parent_options, ptr noundef nonnull @.str.51) #29
  tail call void @qdict_copy_default(ptr noundef %child_options, ptr noundef %parent_options, ptr noundef nonnull @.str.53) #29
  br label %if.end20

if.end20:                                         ; preds = %if.else19, %if.then18
  %and12 = and i32 %role, 2
  %tobool13.not = icmp ne i32 %and12, 0
  %or.cond25 = and i1 %tobool11.not, %parent_is_format
  %or.cond26.not = or i1 %tobool13.not, %or.cond25
  %0 = and i32 %role, 7
  %1 = icmp ne i32 %0, 1
  %or.cond24.not = or i1 %1, %parent_is_format
  %and6 = and i32 %parent_flags, -32769
  %flags.0 = select i1 %or.cond24.not, i32 %parent_flags, i32 %and6
  %or = or i32 %flags.0, 32768
  %flags.1 = select i1 %or.cond26.not, i32 %or, i32 %flags.0
  tail call void @qdict_set_default_str(ptr noundef %child_options, ptr noundef nonnull @.str.57, ptr noundef nonnull @.str.37) #29
  %spec.select.v = select i1 %tobool13.not, i32 -66825, i32 -1289
  %spec.select = and i32 %flags.1, %spec.select.v
  %and30 = and i32 %spec.select, -1305
  %flags.3 = select i1 %tobool11.not, i32 %spec.select, i32 %and30
  store i32 %flags.3, ptr %child_flags, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal noalias ptr @bdrv_child_get_parent_desc(ptr nocapture noundef readonly %c) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 22
  %call1 = tail call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef nonnull @.str.162, ptr noundef nonnull %node_name.i) #29
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_child_cb_inactivate(ptr nocapture noundef readonly %child) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1223, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_inactivate) #31
  unreachable

do.end:                                           ; preds = %entry
  %1 = load i32, ptr %0, align 8
  %and = and i32 %1, 2048
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else2, label %if.end3

if.else2:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.163, ptr noundef nonnull @.str.2, i32 noundef 1224, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_inactivate) #31
  unreachable

if.end3:                                          ; preds = %do.end
  ret i32 0
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_attach(ptr noundef %child) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  tail call void @assert_bdrv_graph_writable() #29
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 29
  %1 = load ptr, ptr %children, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 9
  store ptr %1, ptr %next, align 8
  %cmp.not = icmp eq ptr %1, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %le_prev = getelementptr inbounds %struct.BdrvChild, ptr %1, i64 0, i32 9, i32 1
  store ptr %next, ptr %le_prev, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store ptr %child, ptr %children, align 8
  %le_prev11 = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 9, i32 1
  store ptr %children, ptr %le_prev11, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %2, i64 0, i32 2
  %3 = load i8, ptr %is_filter, align 4
  %4 = and i8 %3, 1
  %tobool.not = icmp eq i8 %4, 0
  %role = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 3
  %5 = load i32, ptr %role, align 8
  %and = and i32 %5, 4
  %tobool12.not = icmp eq i32 %and, 0
  %or.cond = select i1 %tobool.not, i1 %tobool12.not, i1 false
  %and54 = and i32 %5, 8
  %tobool55.not = icmp eq i32 %and54, 0
  br i1 %or.cond, label %if.else52, label %if.then13

if.then13:                                        ; preds = %if.end
  br i1 %tobool55.not, label %if.end18, label %if.else

if.else:                                          ; preds = %if.then13
  tail call void @__assert_fail(ptr noundef nonnull @.str.164, ptr noundef nonnull @.str.2, i32 noundef 1437, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end18:                                         ; preds = %if.then13
  %and20 = and i32 %5, 16
  %tobool21.not = icmp eq i32 %and20, 0
  %and46 = and i32 %5, 4
  %tobool47.not = icmp eq i32 %and46, 0
  br i1 %tobool21.not, label %if.else44, label %if.then22

if.then22:                                        ; preds = %if.end18
  br i1 %tobool47.not, label %if.else27, label %if.end28

if.else27:                                        ; preds = %if.then22
  tail call void @__assert_fail(ptr noundef nonnull @.str.165, ptr noundef nonnull @.str.2, i32 noundef 1439, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end28:                                         ; preds = %if.then22
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 30
  %6 = load ptr, ptr %backing, align 8
  %tobool29.not = icmp eq ptr %6, null
  br i1 %tobool29.not, label %if.end32, label %if.else31

if.else31:                                        ; preds = %if.end28
  tail call void @__assert_fail(ptr noundef nonnull @.str.166, ptr noundef nonnull @.str.2, i32 noundef 1440, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end32:                                         ; preds = %if.end28
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 31
  %7 = load ptr, ptr %file, align 8
  %tobool33.not = icmp eq ptr %7, null
  br i1 %tobool33.not, label %if.end36, label %if.else35

if.else35:                                        ; preds = %if.end32
  tail call void @__assert_fail(ptr noundef nonnull @.str.167, ptr noundef nonnull @.str.2, i32 noundef 1441, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end36:                                         ; preds = %if.end32
  %filtered_child_is_backing = getelementptr inbounds %struct.BlockDriver, ptr %2, i64 0, i32 3
  %8 = load i8, ptr %filtered_child_is_backing, align 1
  %9 = and i8 %8, 1
  %tobool38.not = icmp eq i8 %9, 0
  %file.backing = select i1 %tobool38.not, ptr %file, ptr %backing
  br label %if.end87.sink.split

if.else44:                                        ; preds = %if.end18
  br i1 %tobool47.not, label %if.end87, label %if.else49

if.else49:                                        ; preds = %if.else44
  tail call void @__assert_fail(ptr noundef nonnull @.str.168, ptr noundef nonnull @.str.2, i32 noundef 1449, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.else52:                                        ; preds = %if.end
  br i1 %tobool55.not, label %if.else74, label %if.then56

if.then56:                                        ; preds = %if.else52
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %2, i64 0, i32 7
  %10 = load i8, ptr %supports_backing, align 1
  %11 = and i8 %10, 1
  %tobool58.not = icmp eq i8 %11, 0
  br i1 %tobool58.not, label %if.else60, label %if.end61

if.else60:                                        ; preds = %if.then56
  tail call void @__assert_fail(ptr noundef nonnull @.str.169, ptr noundef nonnull @.str.2, i32 noundef 1452, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end61:                                         ; preds = %if.then56
  %and63 = and i32 %5, 16
  %tobool64.not = icmp eq i32 %and63, 0
  br i1 %tobool64.not, label %if.end67, label %if.else66

if.else66:                                        ; preds = %if.end61
  tail call void @__assert_fail(ptr noundef nonnull @.str.170, ptr noundef nonnull @.str.2, i32 noundef 1453, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end67:                                         ; preds = %if.end61
  %backing68 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 30
  %12 = load ptr, ptr %backing68, align 8
  %tobool69.not = icmp eq ptr %12, null
  br i1 %tobool69.not, label %if.end72, label %if.else71

if.else71:                                        ; preds = %if.end67
  tail call void @__assert_fail(ptr noundef nonnull @.str.166, ptr noundef nonnull @.str.2, i32 noundef 1454, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end72:                                         ; preds = %if.end67
  store ptr %child, ptr %backing68, align 8
  %child.val = load ptr, ptr %child, align 8
  %child.val32 = load ptr, ptr %opaque, align 8
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.end72
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1265, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_attach) #31
  unreachable

do.end.i:                                         ; preds = %if.end72
  %backing_blocker.i = getelementptr inbounds %struct.BlockDriverState, ptr %child.val32, i64 0, i32 36
  %13 = load ptr, ptr %backing_blocker.i, align 8
  %tobool.not.i = icmp eq ptr %13, null
  br i1 %tobool.not.i, label %if.end3.i, label %if.else2.i

if.else2.i:                                       ; preds = %do.end.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.171, ptr noundef nonnull @.str.2, i32 noundef 1266, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_attach) #31
  unreachable

if.end3.i:                                        ; preds = %do.end.i
  %parents.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %child.val32, i64 0, i32 32
  %c.07.i.i.i = load ptr, ptr %parents.i.i.i, align 8
  %tobool.not8.i.i.i = icmp eq ptr %c.07.i.i.i, null
  br i1 %tobool.not8.i.i.i, label %bdrv_get_device_or_node_name.exit.i, label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %if.end3.i, %for.inc.i.i.i
  %c.09.i.i.i = phi ptr [ %c.0.i.i.i, %for.inc.i.i.i ], [ %c.07.i.i.i, %if.end3.i ]
  %klass.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i, i64 0, i32 2
  %14 = load ptr, ptr %klass.i.i.i, align 8
  %get_name.i.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %14, i64 0, i32 15
  %15 = load ptr, ptr %get_name.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq ptr %15, null
  br i1 %tobool1.not.i.i.i, label %for.inc.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %for.body.i.i.i
  %call.i.i.i = tail call ptr %15(ptr noundef nonnull %c.09.i.i.i) #29
  %tobool4.not.i.i.i = icmp eq ptr %call.i.i.i, null
  br i1 %tobool4.not.i.i.i, label %for.inc.i.i.i, label %land.lhs.true.i.i.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i.i
  %16 = load i8, ptr %call.i.i.i, align 1
  %tobool5.not.i.i.i = icmp eq i8 %16, 0
  br i1 %tobool5.not.i.i.i, label %for.inc.i.i.i, label %bdrv_get_device_or_node_name.exit.i

for.inc.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %if.then.i.i.i, %for.body.i.i.i
  %next_parent.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i, i64 0, i32 10
  %c.0.i.i.i = load ptr, ptr %next_parent.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %c.0.i.i.i, null
  br i1 %tobool.not.i.i.i, label %bdrv_get_device_or_node_name.exit.i, label %for.body.i.i.i, !llvm.loop !5

bdrv_get_device_or_node_name.exit.i:              ; preds = %for.inc.i.i.i, %land.lhs.true.i.i.i, %if.end3.i
  %retval.0.i.i.i = phi ptr [ null, %if.end3.i ], [ %call.i.i.i, %land.lhs.true.i.i.i ], [ null, %for.inc.i.i.i ]
  %tobool.not.i.i = icmp eq ptr %retval.0.i.i.i, null
  %node_name.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %child.val32, i64 0, i32 22
  %cond.i.i = select i1 %tobool.not.i.i, ptr %node_name.i.i, ptr %retval.0.i.i.i
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %backing_blocker.i, ptr noundef nonnull @.str.2, i32 noundef 1269, ptr noundef nonnull @__func__.bdrv_backing_attach, ptr noundef nonnull @.str.172, ptr noundef nonnull %cond.i.i) #29
  tail call void @bdrv_refresh_filename(ptr noundef %child.val)
  %17 = load i32, ptr %child.val32, align 8
  %and.i = and i32 %17, -257
  store i32 %and.i, ptr %child.val32, align 8
  %18 = load ptr, ptr %backing_blocker.i, align 8
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %for.body.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %bdrv_get_device_or_node_name.exit.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7331, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_block_all) #31
  unreachable

for.body.i.i:                                     ; preds = %bdrv_get_device_or_node_name.exit.i, %bdrv_op_block.exit.i.i
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %bdrv_op_block.exit.i.i ], [ 0, %bdrv_get_device_or_node_name.exit.i ]
  %call.i.i15.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i15.i, label %if.end4.i.i.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %for.body.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7307, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_block) #31
  unreachable

if.end4.i.i.i:                                    ; preds = %for.body.i.i
  %call5.i.i.i = tail call noalias dereferenceable_or_null(24) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #32
  store ptr %18, ptr %call5.i.i.i, align 8
  %arrayidx.i.i.i = getelementptr %struct.BlockDriverState, ptr %child.val, i64 0, i32 27, i64 %indvars.iv.i.i
  %19 = load ptr, ptr %arrayidx.i.i.i, align 8
  %list.i.i.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %call5.i.i.i, i64 0, i32 1
  store ptr %19, ptr %list.i.i.i, align 8
  %cmp8.not.i.i.i = icmp eq ptr %19, null
  br i1 %cmp8.not.i.i.i, label %bdrv_op_block.exit.i.i, label %if.then9.i.i.i

if.then9.i.i.i:                                   ; preds = %if.end4.i.i.i
  %le_prev.i.i.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %19, i64 0, i32 1, i32 1
  store ptr %list.i.i.i, ptr %le_prev.i.i.i, align 8
  br label %bdrv_op_block.exit.i.i

bdrv_op_block.exit.i.i:                           ; preds = %if.then9.i.i.i, %if.end4.i.i.i
  store ptr %call5.i.i.i, ptr %arrayidx.i.i.i, align 8
  %le_prev27.i.i.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %call5.i.i.i, i64 0, i32 1, i32 1
  store ptr %arrayidx.i.i.i, ptr %le_prev27.i.i.i, align 8
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next.i.i, 16
  br i1 %exitcond.not.i.i, label %bdrv_op_block_all.exit.i, label %for.body.i.i, !llvm.loop !12

bdrv_op_block_all.exit.i:                         ; preds = %bdrv_op_block.exit.i.i
  %20 = load ptr, ptr %backing_blocker.i, align 8
  %call.i16.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i16.i, label %do.end.i.i, label %if.else.i17.i

if.else.i17.i:                                    ; preds = %bdrv_op_block_all.exit.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7318, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

do.end.i.i:                                       ; preds = %bdrv_op_block_all.exit.i
  %arrayidx.i.i = getelementptr %struct.BlockDriverState, ptr %child.val, i64 0, i32 27, i64 4
  %21 = load ptr, ptr %arrayidx.i.i, align 8
  %tobool.not13.i.i = icmp eq ptr %21, null
  br i1 %tobool.not13.i.i, label %bdrv_op_unblock.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %do.end.i.i, %for.inc.i.i
  %blocker.014.i.i = phi ptr [ %22, %for.inc.i.i ], [ %21, %do.end.i.i ]
  %list.i.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i.i, i64 0, i32 1
  %22 = load ptr, ptr %list.i.i, align 8
  %23 = load ptr, ptr %blocker.014.i.i, align 8
  %cmp6.i.i = icmp eq ptr %23, %20
  br i1 %cmp6.i.i, label %do.body8.i.i, label %for.inc.i.i

do.body8.i.i:                                     ; preds = %land.rhs.i.i
  %cmp11.not.i.i = icmp eq ptr %22, null
  %le_prev22.phi.trans.insert.i.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i.i, i64 0, i32 1, i32 1
  %.pre15.i.i = load ptr, ptr %le_prev22.phi.trans.insert.i.i, align 8
  br i1 %cmp11.not.i.i, label %if.end18.i.i, label %if.then12.i.i

if.then12.i.i:                                    ; preds = %do.body8.i.i
  %le_prev17.i.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %22, i64 0, i32 1, i32 1
  store ptr %.pre15.i.i, ptr %le_prev17.i.i, align 8
  %.pre.i.i = load ptr, ptr %list.i.i, align 8
  br label %if.end18.i.i

if.end18.i.i:                                     ; preds = %if.then12.i.i, %do.body8.i.i
  %24 = phi ptr [ %.pre.i.i, %if.then12.i.i ], [ null, %do.body8.i.i ]
  store ptr %24, ptr %.pre15.i.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i.i, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %blocker.014.i.i) #29
  br label %for.inc.i.i

for.inc.i.i:                                      ; preds = %if.end18.i.i, %land.rhs.i.i
  %tobool.not.i18.i = icmp eq ptr %22, null
  br i1 %tobool.not.i18.i, label %bdrv_op_unblock.exit.i, label %land.rhs.i.i, !llvm.loop !13

bdrv_op_unblock.exit.i:                           ; preds = %for.inc.i.i, %do.end.i.i
  %25 = load ptr, ptr %backing_blocker.i, align 8
  %call.i19.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i19.i, label %do.end.i21.i, label %if.else.i20.i

if.else.i20.i:                                    ; preds = %bdrv_op_unblock.exit.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7318, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

do.end.i21.i:                                     ; preds = %bdrv_op_unblock.exit.i
  %arrayidx.i22.i = getelementptr %struct.BlockDriverState, ptr %child.val, i64 0, i32 27, i64 14
  %26 = load ptr, ptr %arrayidx.i22.i, align 8
  %tobool.not13.i23.i = icmp eq ptr %26, null
  br i1 %tobool.not13.i23.i, label %bdrv_op_unblock.exit38.i, label %land.rhs.i24.i

land.rhs.i24.i:                                   ; preds = %do.end.i21.i, %for.inc.i28.i
  %blocker.014.i25.i = phi ptr [ %27, %for.inc.i28.i ], [ %26, %do.end.i21.i ]
  %list.i26.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i25.i, i64 0, i32 1
  %27 = load ptr, ptr %list.i26.i, align 8
  %28 = load ptr, ptr %blocker.014.i25.i, align 8
  %cmp6.i27.i = icmp eq ptr %28, %25
  br i1 %cmp6.i27.i, label %do.body8.i30.i, label %for.inc.i28.i

do.body8.i30.i:                                   ; preds = %land.rhs.i24.i
  %cmp11.not.i31.i = icmp eq ptr %27, null
  %le_prev22.phi.trans.insert.i32.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i25.i, i64 0, i32 1, i32 1
  %.pre15.i33.i = load ptr, ptr %le_prev22.phi.trans.insert.i32.i, align 8
  br i1 %cmp11.not.i31.i, label %if.end18.i37.i, label %if.then12.i34.i

if.then12.i34.i:                                  ; preds = %do.body8.i30.i
  %le_prev17.i35.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %27, i64 0, i32 1, i32 1
  store ptr %.pre15.i33.i, ptr %le_prev17.i35.i, align 8
  %.pre.i36.i = load ptr, ptr %list.i26.i, align 8
  br label %if.end18.i37.i

if.end18.i37.i:                                   ; preds = %if.then12.i34.i, %do.body8.i30.i
  %29 = phi ptr [ %.pre.i36.i, %if.then12.i34.i ], [ null, %do.body8.i30.i ]
  store ptr %29, ptr %.pre15.i33.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i26.i, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %blocker.014.i25.i) #29
  br label %for.inc.i28.i

for.inc.i28.i:                                    ; preds = %if.end18.i37.i, %land.rhs.i24.i
  %tobool.not.i29.i = icmp eq ptr %27, null
  br i1 %tobool.not.i29.i, label %bdrv_op_unblock.exit38.i, label %land.rhs.i24.i, !llvm.loop !13

bdrv_op_unblock.exit38.i:                         ; preds = %for.inc.i28.i, %do.end.i21.i
  %30 = load ptr, ptr %backing_blocker.i, align 8
  %call.i39.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i39.i, label %do.end.i41.i, label %if.else.i40.i

if.else.i40.i:                                    ; preds = %bdrv_op_unblock.exit38.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7318, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

do.end.i41.i:                                     ; preds = %bdrv_op_unblock.exit38.i
  %arrayidx.i42.i = getelementptr %struct.BlockDriverState, ptr %child.val, i64 0, i32 27, i64 0
  %31 = load ptr, ptr %arrayidx.i42.i, align 8
  %tobool.not13.i43.i = icmp eq ptr %31, null
  br i1 %tobool.not13.i43.i, label %bdrv_op_unblock.exit58.i, label %land.rhs.i44.i

land.rhs.i44.i:                                   ; preds = %do.end.i41.i, %for.inc.i48.i
  %blocker.014.i45.i = phi ptr [ %32, %for.inc.i48.i ], [ %31, %do.end.i41.i ]
  %list.i46.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i45.i, i64 0, i32 1
  %32 = load ptr, ptr %list.i46.i, align 8
  %33 = load ptr, ptr %blocker.014.i45.i, align 8
  %cmp6.i47.i = icmp eq ptr %33, %30
  br i1 %cmp6.i47.i, label %do.body8.i50.i, label %for.inc.i48.i

do.body8.i50.i:                                   ; preds = %land.rhs.i44.i
  %cmp11.not.i51.i = icmp eq ptr %32, null
  %le_prev22.phi.trans.insert.i52.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i45.i, i64 0, i32 1, i32 1
  %.pre15.i53.i = load ptr, ptr %le_prev22.phi.trans.insert.i52.i, align 8
  br i1 %cmp11.not.i51.i, label %if.end18.i57.i, label %if.then12.i54.i

if.then12.i54.i:                                  ; preds = %do.body8.i50.i
  %le_prev17.i55.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %32, i64 0, i32 1, i32 1
  store ptr %.pre15.i53.i, ptr %le_prev17.i55.i, align 8
  %.pre.i56.i = load ptr, ptr %list.i46.i, align 8
  br label %if.end18.i57.i

if.end18.i57.i:                                   ; preds = %if.then12.i54.i, %do.body8.i50.i
  %34 = phi ptr [ %.pre.i56.i, %if.then12.i54.i ], [ null, %do.body8.i50.i ]
  store ptr %34, ptr %.pre15.i53.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i46.i, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %blocker.014.i45.i) #29
  br label %for.inc.i48.i

for.inc.i48.i:                                    ; preds = %if.end18.i57.i, %land.rhs.i44.i
  %tobool.not.i49.i = icmp eq ptr %32, null
  br i1 %tobool.not.i49.i, label %bdrv_op_unblock.exit58.i, label %land.rhs.i44.i, !llvm.loop !13

bdrv_op_unblock.exit58.i:                         ; preds = %for.inc.i48.i, %do.end.i41.i
  %35 = load ptr, ptr %backing_blocker.i, align 8
  %call.i59.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i59.i, label %do.end.i61.i, label %if.else.i60.i

if.else.i60.i:                                    ; preds = %bdrv_op_unblock.exit58.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7318, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

do.end.i61.i:                                     ; preds = %bdrv_op_unblock.exit58.i
  %arrayidx.i62.i = getelementptr %struct.BlockDriverState, ptr %child.val, i64 0, i32 27, i64 1
  %36 = load ptr, ptr %arrayidx.i62.i, align 8
  %tobool.not13.i63.i = icmp eq ptr %36, null
  br i1 %tobool.not13.i63.i, label %if.end87, label %land.rhs.i64.i

land.rhs.i64.i:                                   ; preds = %do.end.i61.i, %for.inc.i68.i
  %blocker.014.i65.i = phi ptr [ %37, %for.inc.i68.i ], [ %36, %do.end.i61.i ]
  %list.i66.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i65.i, i64 0, i32 1
  %37 = load ptr, ptr %list.i66.i, align 8
  %38 = load ptr, ptr %blocker.014.i65.i, align 8
  %cmp6.i67.i = icmp eq ptr %38, %35
  br i1 %cmp6.i67.i, label %do.body8.i70.i, label %for.inc.i68.i

do.body8.i70.i:                                   ; preds = %land.rhs.i64.i
  %cmp11.not.i71.i = icmp eq ptr %37, null
  %le_prev22.phi.trans.insert.i72.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i65.i, i64 0, i32 1, i32 1
  %.pre15.i73.i = load ptr, ptr %le_prev22.phi.trans.insert.i72.i, align 8
  br i1 %cmp11.not.i71.i, label %if.end18.i77.i, label %if.then12.i74.i

if.then12.i74.i:                                  ; preds = %do.body8.i70.i
  %le_prev17.i75.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %37, i64 0, i32 1, i32 1
  store ptr %.pre15.i73.i, ptr %le_prev17.i75.i, align 8
  %.pre.i76.i = load ptr, ptr %list.i66.i, align 8
  br label %if.end18.i77.i

if.end18.i77.i:                                   ; preds = %if.then12.i74.i, %do.body8.i70.i
  %39 = phi ptr [ %.pre.i76.i, %if.then12.i74.i ], [ null, %do.body8.i70.i ]
  store ptr %39, ptr %.pre15.i73.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i66.i, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %blocker.014.i65.i) #29
  br label %for.inc.i68.i

for.inc.i68.i:                                    ; preds = %if.end18.i77.i, %land.rhs.i64.i
  %tobool.not.i69.i = icmp eq ptr %37, null
  br i1 %tobool.not.i69.i, label %if.end87, label %land.rhs.i64.i, !llvm.loop !13

if.else74:                                        ; preds = %if.else52
  %and76 = and i32 %5, 16
  %tobool77.not = icmp eq i32 %and76, 0
  br i1 %tobool77.not, label %if.end87, label %if.then78

if.then78:                                        ; preds = %if.else74
  %file79 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 31
  %40 = load ptr, ptr %file79, align 8
  %tobool80.not = icmp eq ptr %40, null
  br i1 %tobool80.not, label %if.end87.sink.split, label %if.else82

if.else82:                                        ; preds = %if.then78
  tail call void @__assert_fail(ptr noundef nonnull @.str.167, ptr noundef nonnull @.str.2, i32 noundef 1458, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #31
  unreachable

if.end87.sink.split:                              ; preds = %if.then78, %if.end36
  %file79.sink = phi ptr [ %file.backing, %if.end36 ], [ %file79, %if.then78 ]
  store ptr %child, ptr %file79.sink, align 8
  br label %if.end87

if.end87:                                         ; preds = %for.inc.i68.i, %if.end87.sink.split, %do.end.i61.i, %if.else74, %if.else44
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_detach(ptr noundef %child) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 3
  %1 = load i32, ptr %role, align 8
  %and = and i32 %1, 8
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.then
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1304, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_detach) #31
  unreachable

do.end.i:                                         ; preds = %if.then
  %backing_blocker.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 36
  %2 = load ptr, ptr %backing_blocker.i, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %if.else2.i, label %bdrv_backing_detach.exit

if.else2.i:                                       ; preds = %do.end.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.174, ptr noundef nonnull @.str.2, i32 noundef 1305, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_detach) #31
  unreachable

bdrv_backing_detach.exit:                         ; preds = %do.end.i
  %3 = load ptr, ptr %child, align 8
  tail call void @bdrv_op_unblock_all(ptr noundef %3, ptr noundef nonnull %2)
  %4 = load ptr, ptr %backing_blocker.i, align 8
  tail call void @error_free(ptr noundef %4) #29
  store ptr null, ptr %backing_blocker.i, align 8
  br label %if.end

if.end:                                           ; preds = %bdrv_backing_detach.exit, %entry
  tail call void @assert_bdrv_graph_writable() #29
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 9
  %5 = load ptr, ptr %next, align 8
  %cmp.not = icmp eq ptr %5, null
  %le_prev11.phi.trans.insert = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 9, i32 1
  %.pre17 = load ptr, ptr %le_prev11.phi.trans.insert, align 8
  br i1 %cmp.not, label %if.end7, label %if.then1

if.then1:                                         ; preds = %if.end
  %le_prev6 = getelementptr inbounds %struct.BdrvChild, ptr %5, i64 0, i32 9, i32 1
  store ptr %.pre17, ptr %le_prev6, align 8
  %.pre = load ptr, ptr %next, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then1
  %6 = phi ptr [ %.pre, %if.then1 ], [ null, %if.end ]
  store ptr %6, ptr %.pre17, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 30
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %next, i8 0, i64 16, i1 false)
  %7 = load ptr, ptr %backing, align 8
  %cmp16 = icmp eq ptr %7, %child
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 31
  %8 = load ptr, ptr %file, align 8
  %cmp18.not = icmp eq ptr %8, %child
  br i1 %cmp16, label %if.then17, label %if.else22

if.then17:                                        ; preds = %if.end7
  br i1 %cmp18.not, label %if.else, label %if.end28.sink.split

if.else:                                          ; preds = %if.then17
  tail call void @__assert_fail(ptr noundef nonnull @.str.173, ptr noundef nonnull @.str.2, i32 noundef 1474, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_cb_detach) #31
  unreachable

if.else22:                                        ; preds = %if.end7
  br i1 %cmp18.not, label %if.end28.sink.split, label %if.end28

if.end28.sink.split:                              ; preds = %if.else22, %if.then17
  %file23.sink = phi ptr [ %backing, %if.then17 ], [ %file, %if.else22 ]
  store ptr null, ptr %file23.sink, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.end28.sink.split, %if.else22
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_drained_begin(ptr nocapture noundef readonly %child) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  tail call void @bdrv_do_drained_begin_quiesce(ptr noundef %0, ptr noundef null) #29
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_drained_end(ptr nocapture noundef readonly %child) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  tail call void @bdrv_drained_end(ptr noundef %0) #29
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_child_cb_drained_poll(ptr nocapture noundef readonly %child) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  %call = tail call zeroext i1 @bdrv_drain_poll(ptr noundef %0, ptr noundef null, i1 noundef zeroext false) #29
  ret i1 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_child_cb_update_filename(ptr nocapture noundef readonly %c, ptr nocapture noundef readonly %base, ptr noundef %filename, ptr noundef %errp) #4 {
entry:
  %role = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 3
  %0 = load i32, ptr %role, align 8
  %and = and i32 %0, 8
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr i8, ptr %c, i64 32
  %c.val = load ptr, ptr %1, align 8
  %2 = load i32, ptr %c.val, align 8
  %and.i.i = and i32 %2, 2
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  %call1.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.then
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1317, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_update_filename) #31
  unreachable

do.end.i:                                         ; preds = %if.then
  br i1 %tobool.not.i.i, label %if.then2.i, label %if.end6.i

if.then2.i:                                       ; preds = %do.end.i
  %call.i.i = tail call ptr @qdict_new() #29
  %call1.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1.i.i, label %bdrv_reopen_set_read_only.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then2.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4719, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_set_read_only) #31
  unreachable

bdrv_reopen_set_read_only.exit.i:                 ; preds = %if.then2.i
  tail call void @qdict_put_bool(ptr noundef %call.i.i, ptr noundef nonnull @.str.51, i1 noundef zeroext false) #29
  %call2.i.i = tail call i32 @bdrv_reopen(ptr noundef nonnull %c.val, ptr noundef %call.i.i, i1 noundef zeroext true, ptr noundef %errp), !range !14
  %cmp.i = icmp slt i32 %call2.i.i, 0
  br i1 %cmp.i, label %return, label %if.end6.i

if.end6.i:                                        ; preds = %bdrv_reopen_set_read_only.exit.i, %do.end.i
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %base, i64 0, i32 6
  %3 = load ptr, ptr %drv.i, align 8
  %tobool7.not.i = icmp eq ptr %3, null
  br i1 %tobool7.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end6.i
  %4 = load ptr, ptr %3, align 8
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end6.i
  %cond.i = phi ptr [ %4, %cond.true.i ], [ @.str.95, %if.end6.i ]
  %call9.i = tail call i32 @bdrv_change_backing_file(ptr noundef nonnull %c.val, ptr noundef %filename, ptr noundef %cond.i, i1 noundef zeroext false) #29
  %cmp10.i = icmp slt i32 %call9.i, 0
  br i1 %cmp10.i, label %if.then11.i, label %if.end12.i

if.then11.i:                                      ; preds = %cond.end.i
  %sub.i = sub i32 0, %call9.i
  tail call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 1330, ptr noundef nonnull @__func__.bdrv_backing_update_filename, i32 noundef %sub.i, ptr noundef nonnull @.str.175) #29
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.then11.i, %cond.end.i
  br i1 %tobool.not.i.i, label %if.then14.i, label %return

if.then14.i:                                      ; preds = %if.end12.i
  %call.i11.i = tail call ptr @qdict_new() #29
  %call1.i12.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1.i12.i, label %bdrv_reopen_set_read_only.exit15.i, label %if.else.i13.i

if.else.i13.i:                                    ; preds = %if.then14.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4719, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_set_read_only) #31
  unreachable

bdrv_reopen_set_read_only.exit15.i:               ; preds = %if.then14.i
  tail call void @qdict_put_bool(ptr noundef %call.i11.i, ptr noundef nonnull @.str.51, i1 noundef zeroext true) #29
  %call2.i14.i = tail call i32 @bdrv_reopen(ptr noundef nonnull %c.val, ptr noundef %call.i11.i, i1 noundef zeroext true, ptr noundef null), !range !14
  br label %return

return:                                           ; preds = %bdrv_reopen_set_read_only.exit15.i, %if.end12.i, %bdrv_reopen_set_read_only.exit.i, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %call2.i.i, %bdrv_reopen_set_read_only.exit.i ], [ %call9.i, %bdrv_reopen_set_read_only.exit15.i ], [ %call9.i, %if.end12.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_child_cb_change_aio_ctx(ptr nocapture noundef readonly %child, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) #4 {
entry:
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 4
  %0 = load ptr, ptr %opaque, align 8
  %call = tail call fastcc zeroext i1 @bdrv_change_aio_context(ptr noundef %0, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp)
  ret i1 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_child_get_parent_aio_context(ptr noundef %c) local_unnamed_addr #4 {
entry:
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 2
  %0 = load ptr, ptr %klass, align 8
  %get_parent_aio_context = getelementptr inbounds %struct.BdrvChildClass, ptr %0, i64 0, i32 16
  %1 = load ptr, ptr %get_parent_aio_context, align 8
  %call = tail call ptr %1(ptr noundef %c) #29
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_new_open_driver_opts(ptr noundef %drv, ptr noundef %node_name, ptr noundef %options, i32 noundef %flags, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1739, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_new_open_driver_opts) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call ptr @bdrv_new()
  store i32 %flags, ptr %call1, align 8
  %tobool.not = icmp eq ptr %options, null
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %do.end
  %call2 = tail call ptr @qdict_new() #29
  br label %cond.end

cond.end:                                         ; preds = %do.end, %cond.false
  %cond = phi ptr [ %call2, %cond.false ], [ %options, %do.end ]
  %options3 = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 33
  store ptr %cond, ptr %options3, align 8
  %call5 = tail call ptr @qdict_clone_shallow(ptr noundef %cond) #29
  %explicit_options = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 34
  store ptr %call5, ptr %explicit_options, align 8
  %opaque = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 7
  store ptr null, ptr %opaque, align 8
  %0 = load ptr, ptr %options3, align 8
  tail call fastcc void @update_options_from_flags(ptr noundef %0, i32 noundef %flags)
  %1 = load ptr, ptr %options3, align 8
  %call8 = tail call i32 @bdrv_open_driver(ptr noundef nonnull %call1, ptr noundef %drv, ptr noundef %node_name, ptr noundef %1, i32 noundef %flags, ptr noundef %errp), !range !14
  %cmp = icmp slt i32 %call8, 0
  br i1 %cmp, label %if.then9, label %return

if.then9:                                         ; preds = %cond.end
  %2 = load ptr, ptr %explicit_options, align 8
  %tobool11.not = icmp eq ptr %2, null
  br i1 %tobool11.not, label %qobject_unref_impl.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.then9
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %2, i64 0, i32 1
  %3 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %3, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %3, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %qobject_unref_impl.exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  tail call void @qobject_destroy(ptr noundef nonnull %2) #29
  br label %qobject_unref_impl.exit

qobject_unref_impl.exit:                          ; preds = %if.then9, %land.lhs.true.i, %if.then5.i
  store ptr null, ptr %explicit_options, align 8
  %4 = load ptr, ptr %options3, align 8
  %tobool20.not = icmp eq ptr %4, null
  br i1 %tobool20.not, label %qobject_unref_impl.exit27, label %lor.lhs.false.i19

lor.lhs.false.i19:                                ; preds = %qobject_unref_impl.exit
  %refcnt.i20 = getelementptr inbounds %struct.QObjectBase_, ptr %4, i64 0, i32 1
  %5 = load i64, ptr %refcnt.i20, align 8
  %tobool1.not.i21 = icmp eq i64 %5, 0
  br i1 %tobool1.not.i21, label %if.else.i26, label %land.lhs.true.i22

if.else.i26:                                      ; preds = %lor.lhs.false.i19
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i22:                                ; preds = %lor.lhs.false.i19
  %dec.i23 = add i64 %5, -1
  store i64 %dec.i23, ptr %refcnt.i20, align 8
  %cmp.i24 = icmp eq i64 %dec.i23, 0
  br i1 %cmp.i24, label %if.then5.i25, label %qobject_unref_impl.exit27

if.then5.i25:                                     ; preds = %land.lhs.true.i22
  tail call void @qobject_destroy(ptr noundef nonnull %4) #29
  br label %qobject_unref_impl.exit27

qobject_unref_impl.exit27:                        ; preds = %qobject_unref_impl.exit, %land.lhs.true.i22, %if.then5.i25
  store ptr null, ptr %options3, align 8
  tail call void @bdrv_unref(ptr noundef nonnull %call1)
  br label %return

return:                                           ; preds = %cond.end, %qobject_unref_impl.exit27
  %retval.0 = phi ptr [ null, %qobject_unref_impl.exit27 ], [ %call1, %cond.end ]
  ret ptr %retval.0
}

declare ptr @qdict_clone_shallow(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @update_options_from_flags(ptr noundef %options, i32 noundef %flags) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1558, ptr noundef nonnull @__PRETTY_FUNCTION__.update_options_from_flags) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call i32 @qdict_haskey(ptr noundef %options, ptr noundef nonnull @.str.47) #29
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.then2, label %if.end4

if.then2:                                         ; preds = %do.end
  %and = and i32 %flags, 32
  %tobool3 = icmp ne i32 %and, 0
  tail call void @qdict_put_bool(ptr noundef %options, ptr noundef nonnull @.str.47, i1 noundef zeroext %tobool3) #29
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %do.end
  %call5 = tail call i32 @qdict_haskey(ptr noundef %options, ptr noundef nonnull @.str.49) #29
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end4
  %and8 = and i32 %flags, 512
  %tobool9 = icmp ne i32 %and8, 0
  tail call void @qdict_put_bool(ptr noundef %options, ptr noundef nonnull @.str.49, i1 noundef zeroext %tobool9) #29
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end4
  %call11 = tail call i32 @qdict_haskey(ptr noundef %options, ptr noundef nonnull @.str.51) #29
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end10
  %and14 = and i32 %flags, 2
  %tobool15.not = icmp eq i32 %and14, 0
  tail call void @qdict_put_bool(ptr noundef %options, ptr noundef nonnull @.str.51, i1 noundef zeroext %tobool15.not) #29
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end10
  %call17 = tail call i32 @qdict_haskey(ptr noundef %options, ptr noundef nonnull @.str.53) #29
  %tobool18.not = icmp eq i32 %call17, 0
  br i1 %tobool18.not, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end16
  %and20 = and i32 %flags, 131072
  %tobool21 = icmp ne i32 %and20, 0
  tail call void @qdict_put_bool(ptr noundef %options, ptr noundef nonnull @.str.53, i1 noundef zeroext %tobool21) #29
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end16
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_open_driver(ptr noundef %bs, ptr noundef %drv, ptr noundef %node_name, ptr noundef %options, i32 noundef %open_flags, ptr noundef %errp) #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1631, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1580, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_assign_node_name) #31
  unreachable

do.end.i:                                         ; preds = %do.end
  %tobool.not.i = icmp eq ptr %node_name, null
  br i1 %tobool.not.i, label %if.then1.i, label %if.else3.i

if.then1.i:                                       ; preds = %do.end.i
  %call2.i = tail call ptr @id_generate(i32 noundef 1) #29
  br label %if.end7.i

if.else3.i:                                       ; preds = %do.end.i
  %call4.i = tail call zeroext i1 @id_wellformed(ptr noundef nonnull %node_name) #29
  br i1 %call4.i, label %if.end7.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.else3.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1589, ptr noundef nonnull @__func__.bdrv_assign_node_name, ptr noundef nonnull @.str.184, ptr noundef nonnull %node_name) #29
  br label %bdrv_assign_node_name.exit

if.end7.i:                                        ; preds = %if.else3.i, %if.then1.i
  %node_name.addr.0.i = phi ptr [ %node_name, %if.else3.i ], [ %call2.i, %if.then1.i ]
  %gen_node_name.0.i = phi ptr [ null, %if.else3.i ], [ %call2.i, %if.then1.i ]
  %call8.i = tail call ptr @blk_by_name(ptr noundef %node_name.addr.0.i) #29
  %tobool9.not.i = icmp eq ptr %call8.i, null
  br i1 %tobool9.not.i, label %if.end11.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end7.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1596, ptr noundef nonnull @__func__.bdrv_assign_node_name, ptr noundef nonnull @.str.185, ptr noundef %node_name.addr.0.i) #29
  br label %out.i

if.end11.i:                                       ; preds = %if.end7.i
  %tobool.not.i.i = icmp eq ptr %node_name.addr.0.i, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %do.body.i.i

if.else.i.i:                                      ; preds = %if.end11.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.99, ptr noundef nonnull @.str.2, i32 noundef 6328, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

do.body.i.i:                                      ; preds = %if.end11.i
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %for.cond.preheader.i.i, label %if.else2.i.i

for.cond.preheader.i.i:                           ; preds = %do.body.i.i
  %bs.05.i.i = load ptr, ptr @graph_bdrv_states, align 8
  %tobool4.not6.i.i = icmp eq ptr %bs.05.i.i, null
  br i1 %tobool4.not6.i.i, label %if.end15.i, label %for.body.i.i

if.else2.i.i:                                     ; preds = %do.body.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6329, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

for.body.i.i:                                     ; preds = %for.cond.preheader.i.i, %for.inc.i.i
  %bs.07.i.i = phi ptr [ %bs.0.i.i, %for.inc.i.i ], [ %bs.05.i.i, %for.cond.preheader.i.i ]
  %node_name5.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07.i.i, i64 0, i32 22
  %call6.i.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %node_name.addr.0.i, ptr noundef nonnull dereferenceable(1) %node_name5.i.i) #28
  %tobool7.not.i.i = icmp eq i32 %call6.i.i, 0
  br i1 %tobool7.not.i.i, label %if.then14.i, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %node_list.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07.i.i, i64 0, i32 23
  %bs.0.i.i = load ptr, ptr %node_list.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %bs.0.i.i, null
  br i1 %tobool4.not.i.i, label %if.end15.i, label %for.body.i.i, !llvm.loop !15

if.then14.i:                                      ; preds = %for.body.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1602, ptr noundef nonnull @__func__.bdrv_assign_node_name, ptr noundef nonnull @.str.186, ptr noundef nonnull %node_name.addr.0.i) #29
  br label %out.i

if.end15.i:                                       ; preds = %for.inc.i.i, %for.cond.preheader.i.i
  %call16.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %node_name.addr.0.i) #28
  %cmp.i = icmp ugt i64 %call16.i, 31
  br i1 %cmp.i, label %if.then17.i, label %if.end18.i

if.then17.i:                                      ; preds = %if.end15.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1608, ptr noundef nonnull @__func__.bdrv_assign_node_name, ptr noundef nonnull @.str.187) #29
  br label %out.i

if.end18.i:                                       ; preds = %if.end15.i
  %node_name19.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 22
  tail call void @pstrcpy(ptr noundef nonnull %node_name19.i, i32 noundef 32, ptr noundef nonnull %node_name.addr.0.i) #29
  %node_list.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 23
  store ptr null, ptr %node_list.i, align 8
  %0 = load ptr, ptr getelementptr inbounds (%union.anon.20, ptr @graph_bdrv_states, i64 0, i32 0, i32 1), align 8
  %tql_prev.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 23, i32 0, i32 1
  store ptr %0, ptr %tql_prev.i, align 8
  store ptr %bs, ptr %0, align 8
  store ptr %node_list.i, ptr getelementptr inbounds (%union.anon.20, ptr @graph_bdrv_states, i64 0, i32 0, i32 1), align 8
  br label %out.i

out.i:                                            ; preds = %if.end18.i, %if.then17.i, %if.then14.i, %if.then10.i
  call void @g_free(ptr noundef %gen_node_name.0.i) #29
  br label %bdrv_assign_node_name.exit

bdrv_assign_node_name.exit:                       ; preds = %if.then5.i, %out.i
  %1 = load ptr, ptr %local_err, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end2, label %if.then1

if.then1:                                         ; preds = %bdrv_assign_node_name.exit
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %1) #29
  br label %return

if.end2:                                          ; preds = %bdrv_assign_node_name.exit
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  store ptr %drv, ptr %drv3, align 8
  %instance_size = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 1
  %2 = load i32, ptr %instance_size, align 8
  %conv = sext i32 %2 to i64
  %call4 = call noalias ptr @g_malloc0(i64 noundef %conv) #30
  %opaque = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 7
  store ptr %call4, ptr %opaque, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 24
  %3 = load ptr, ptr %bdrv_file_open, align 8
  %tobool5.not = icmp eq ptr %3, null
  br i1 %tobool5.not, label %if.else15, label %if.then6

if.then6:                                         ; preds = %if.end2
  %bdrv_needs_filename = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 6
  %4 = load i8, ptr %bdrv_needs_filename, align 8
  %5 = and i8 %4, 1
  %tobool7.not = icmp eq i8 %5, 0
  br i1 %tobool7.not, label %if.end22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then6
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  %6 = load i8, ptr %filename, align 1
  %tobool9.not = icmp eq i8 %6, 0
  br i1 %tobool9.not, label %if.else11, label %if.end22

if.else11:                                        ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef nonnull @.str.176, ptr noundef nonnull @.str.2, i32 noundef 1643, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

if.else15:                                        ; preds = %if.end2
  %bdrv_open = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 23
  %7 = load ptr, ptr %bdrv_open, align 8
  %tobool16.not = icmp eq ptr %7, null
  br i1 %tobool16.not, label %if.end37, label %if.end22

if.end22:                                         ; preds = %if.else15, %lor.lhs.false, %if.then6
  %.sink = phi ptr [ %3, %if.then6 ], [ %3, %lor.lhs.false ], [ %7, %if.else15 ]
  %call19 = call i32 %.sink(ptr noundef nonnull %bs, ptr noundef %options, i32 noundef %open_flags, ptr noundef nonnull %local_err) #29
  %cmp = icmp slt i32 %call19, 0
  br i1 %cmp, label %if.then24, label %if.end37

if.then24:                                        ; preds = %if.end22
  %8 = load ptr, ptr %local_err, align 8
  %tobool25.not = icmp eq ptr %8, null
  br i1 %tobool25.not, label %if.else27, label %if.then26

if.then26:                                        ; preds = %if.then24
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %8) #29
  br label %open_failed

if.else27:                                        ; preds = %if.then24
  %filename28 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  %9 = load i8, ptr %filename28, align 1
  %tobool30.not = icmp eq i8 %9, 0
  %sub34 = sub i32 0, %call19
  br i1 %tobool30.not, label %if.else33, label %if.then31

if.then31:                                        ; preds = %if.else27
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 1655, ptr noundef nonnull @__func__.bdrv_open_driver, i32 noundef %sub34, ptr noundef nonnull @.str.177, ptr noundef nonnull %filename28) #29
  br label %open_failed

if.else33:                                        ; preds = %if.else27
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 1657, ptr noundef nonnull @__func__.bdrv_open_driver, i32 noundef %sub34, ptr noundef nonnull @.str.178) #29
  br label %open_failed

if.end37:                                         ; preds = %if.else15, %if.end22
  %supported_read_flags = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 18
  %10 = load i32, ptr %supported_read_flags, align 8
  %tobool38.not = icmp ult i32 %10, 2048
  br i1 %tobool38.not, label %if.end41, label %if.else40

if.else40:                                        ; preds = %if.end37
  call void @__assert_fail(ptr noundef nonnull @.str.179, ptr noundef nonnull @.str.2, i32 noundef 1662, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

if.end41:                                         ; preds = %if.end37
  %supported_write_flags = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 19
  %11 = load i32, ptr %supported_write_flags, align 4
  %tobool43.not = icmp ult i32 %11, 2048
  br i1 %tobool43.not, label %bdrv_get_aio_context.exit, label %if.else45

if.else45:                                        ; preds = %if.end41
  call void @__assert_fail(ptr noundef nonnull @.str.180, ptr noundef nonnull @.str.2, i32 noundef 1663, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

bdrv_get_aio_context.exit:                        ; preds = %if.end41
  %or = or i32 %10, 8
  store i32 %or, ptr %supported_read_flags, align 8
  %or49 = or i32 %11, 8
  store i32 %or49, ptr %supported_write_flags, align 4
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %12 = load ptr, ptr %aio_context.i, align 8
  call void @aio_context_acquire(ptr noundef %12) #29
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %13 = load i64, ptr %total_sectors, align 8
  %call51 = call i32 @bdrv_refresh_total_sectors(ptr noundef nonnull %bs, i64 noundef %13) #29
  %cmp52 = icmp slt i32 %call51, 0
  br i1 %cmp52, label %if.then54, label %if.end56

if.then54:                                        ; preds = %bdrv_get_aio_context.exit
  %sub55 = sub i32 0, %call51
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 1682, ptr noundef nonnull @__func__.bdrv_open_driver, i32 noundef %sub55, ptr noundef nonnull @.str.102) #29
  call void @aio_context_release(ptr noundef %12) #29
  br label %return

if.end56:                                         ; preds = %bdrv_get_aio_context.exit
  call void @bdrv_graph_rdlock_main_loop() #29
  call void @bdrv_refresh_limits(ptr noundef nonnull %bs, ptr noundef null, ptr noundef nonnull %local_err) #29
  call void @bdrv_graph_rdunlock_main_loop() #29
  call void @aio_context_release(ptr noundef %12) #29
  %14 = load ptr, ptr %local_err, align 8
  %tobool57.not = icmp eq ptr %14, null
  br i1 %tobool57.not, label %lor.lhs.false.i, label %if.then58

if.then58:                                        ; preds = %if.end56
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %14) #29
  br label %return

lor.lhs.false.i:                                  ; preds = %if.end56
  %15 = load ptr, ptr %drv3, align 8
  %tobool1.not.i = icmp eq ptr %15, null
  br i1 %tobool1.not.i, label %if.end71, label %bdrv_opt_mem_align.exit

bdrv_opt_mem_align.exit:                          ; preds = %lor.lhs.false.i
  %opt_mem_alignment.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 10
  %16 = load i64, ptr %opt_mem_alignment.i, align 8
  %cmp61.not = icmp eq i64 %16, 0
  br i1 %cmp61.not, label %if.else64, label %bdrv_min_mem_align.exit

if.else64:                                        ; preds = %bdrv_opt_mem_align.exit
  call void @__assert_fail(ptr noundef nonnull @.str.181, ptr noundef nonnull @.str.2, i32 noundef 1697, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

bdrv_min_mem_align.exit:                          ; preds = %bdrv_opt_mem_align.exit
  %min_mem_alignment.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 9
  %17 = load i64, ptr %min_mem_alignment.i, align 8
  %cmp67.not = icmp eq i64 %17, 0
  br i1 %cmp67.not, label %if.else70, label %if.end71

if.else70:                                        ; preds = %bdrv_min_mem_align.exit
  call void @__assert_fail(ptr noundef nonnull @.str.182, ptr noundef nonnull @.str.2, i32 noundef 1698, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

if.end71:                                         ; preds = %lor.lhs.false.i, %bdrv_min_mem_align.exit
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17
  %18 = load i32, ptr %bl, align 8
  %19 = call i32 @llvm.ctpop.i32(i32 %18), !range !16
  %or.cond = icmp eq i32 %19, 1
  br i1 %or.cond, label %for.cond.preheader, label %if.else75

for.cond.preheader:                               ; preds = %if.end71
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 46
  %20 = load i32, ptr %quiesce_counter, align 8
  %cmp7787 = icmp sgt i32 %20, 0
  br i1 %cmp7787, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %bdrv_drain_begin = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 49
  %21 = load ptr, ptr %bdrv_drain_begin, align 8
  %22 = icmp eq ptr %21, null
  br i1 %22, label %return, label %for.body

if.else75:                                        ; preds = %if.end71
  call void @__assert_fail(ptr noundef nonnull @.str.183, ptr noundef nonnull @.str.2, i32 noundef 1699, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

for.bodythread-pre-split:                         ; preds = %for.inc
  %.pr = load ptr, ptr %bdrv_drain_begin, align 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.bodythread-pre-split
  %23 = phi ptr [ %.pr, %for.bodythread-pre-split ], [ %21, %for.body.lr.ph ]
  %24 = phi i32 [ %25, %for.bodythread-pre-split ], [ %20, %for.body.lr.ph ]
  %i.088 = phi i32 [ %inc, %for.bodythread-pre-split ], [ 0, %for.body.lr.ph ]
  %tobool79.not = icmp eq ptr %23, null
  br i1 %tobool79.not, label %for.inc, label %if.then80

if.then80:                                        ; preds = %for.body
  call void %23(ptr noundef nonnull %bs) #29
  %.pre = load i32, ptr %quiesce_counter, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then80
  %25 = phi i32 [ %24, %for.body ], [ %.pre, %if.then80 ]
  %inc = add nuw nsw i32 %i.088, 1
  %cmp77 = icmp slt i32 %inc, %25
  br i1 %cmp77, label %for.bodythread-pre-split, label %return, !llvm.loop !17

open_failed:                                      ; preds = %if.then26, %if.else33, %if.then31
  store ptr null, ptr %drv3, align 8
  call void @bdrv_graph_wrlock(ptr noundef null) #29
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 31
  %26 = load ptr, ptr %file, align 8
  %cmp84.not = icmp eq ptr %26, null
  br i1 %cmp84.not, label %if.end93, label %if.then86

if.then86:                                        ; preds = %open_failed
  %call.i75 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i75, label %bdrv_unref_child.exit, label %if.else.i76

if.else.i76:                                      ; preds = %if.then86
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3382, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unref_child) #31
  unreachable

bdrv_unref_child.exit:                            ; preds = %if.then86
  call fastcc void @bdrv_unset_inherits_from(ptr noundef nonnull %bs, ptr noundef nonnull %26, ptr noundef null)
  call void @bdrv_root_unref_child(ptr noundef nonnull %26)
  %27 = load ptr, ptr %file, align 8
  %tobool89.not = icmp eq ptr %27, null
  br i1 %tobool89.not, label %if.end93, label %if.else91

if.else91:                                        ; preds = %bdrv_unref_child.exit
  call void @__assert_fail(ptr noundef nonnull @.str.167, ptr noundef nonnull @.str.2, i32 noundef 1714, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_driver) #31
  unreachable

if.end93:                                         ; preds = %bdrv_unref_child.exit, %open_failed
  call void @bdrv_graph_wrunlock(ptr noundef null) #29
  %28 = load ptr, ptr %opaque, align 8
  call void @g_free(ptr noundef %28) #29
  store ptr null, ptr %opaque, align 8
  br label %return

return:                                           ; preds = %for.inc, %for.body.lr.ph, %for.cond.preheader, %if.end93, %if.then58, %if.then54, %if.then1
  %retval.0 = phi i32 [ -22, %if.then1 ], [ %call19, %if.end93 ], [ %call51, %if.then54 ], [ -22, %if.then58 ], [ 0, %for.cond.preheader ], [ 0, %for.body.lr.ph ], [ 0, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_unref(ptr noundef %bs) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7247, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unref) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %if.end9, label %if.end2

if.end2:                                          ; preds = %do.end
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 26
  %0 = load i32, ptr %refcnt, align 8
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.end5, label %if.else4

if.else4:                                         ; preds = %if.end2
  tail call void @__assert_fail(ptr noundef nonnull @.str.104, ptr noundef nonnull @.str.2, i32 noundef 7251, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unref) #31
  unreachable

if.end5:                                          ; preds = %if.end2
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %refcnt, align 8
  %cmp7 = icmp eq i32 %dec, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %for.body.i.preheader.i, label %if.else.i.i

for.body.i.preheader.i:                           ; preds = %if.then8
  %arrayidx.i28.i = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 0
  %1 = load ptr, ptr %arrayidx.i28.i, align 8
  %cmp1.i29.i = icmp eq ptr %1, null
  br i1 %cmp1.i29.i, label %for.cond.i.i, label %if.else.i

if.else.i.i:                                      ; preds = %if.then8
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7349, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_blocker_is_empty) #31
  unreachable

for.cond.i.i:                                     ; preds = %for.body.i.preheader.i, %for.body.i.i
  %indvars.iv.i30.i = phi i64 [ %indvars.iv.next.i.i, %for.body.i.i ], [ 0, %for.body.i.preheader.i ]
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i30.i, 1
  %exitcond.i.i = icmp eq i64 %indvars.iv.next.i.i, 16
  br i1 %exitcond.i.i, label %if.end.i, label %for.body.i.i, !llvm.loop !19

for.body.i.i:                                     ; preds = %for.cond.i.i
  %arrayidx.i.i = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %indvars.iv.next.i.i
  %2 = load ptr, ptr %arrayidx.i.i, align 8
  %cmp1.i.i = icmp eq ptr %2, null
  br i1 %cmp1.i.i, label %for.cond.i.i, label %bdrv_op_blocker_is_empty.exit.i, !llvm.loop !19

bdrv_op_blocker_is_empty.exit.i:                  ; preds = %for.body.i.i
  %cmp.i.le.i = icmp ugt i64 %indvars.iv.i30.i, 14
  br i1 %cmp.i.le.i, label %if.end.i, label %if.else.i

if.else.i:                                        ; preds = %bdrv_op_blocker_is_empty.exit.i, %for.body.i.preheader.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.284, ptr noundef nonnull @.str.2, i32 noundef 5644, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_delete) #31
  unreachable

if.end.i:                                         ; preds = %for.cond.i.i, %bdrv_op_blocker_is_empty.exit.i
  %3 = load i32, ptr %refcnt, align 8
  %tobool.not.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i, label %do.body.i, label %if.else2.i

if.else2.i:                                       ; preds = %if.end.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.285, ptr noundef nonnull @.str.2, i32 noundef 5645, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_delete) #31
  unreachable

do.body.i:                                        ; preds = %if.end.i
  %call4.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call4.i, label %do.end.i, label %if.else6.i

if.else6.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5646, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_delete) #31
  unreachable

do.end.i:                                         ; preds = %do.body.i
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 22
  %4 = load i8, ptr %node_name.i, align 8
  %cmp.not.i = icmp eq i8 %4, 0
  br i1 %cmp.not.i, label %do.body32.i, label %do.body10.i

do.body10.i:                                      ; preds = %do.end.i
  %node_list.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 23
  %5 = load ptr, ptr %node_list.i, align 8
  %cmp11.not.i = icmp eq ptr %5, null
  %tql_prev20.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 23, i32 0, i32 1
  %6 = load ptr, ptr %tql_prev20.i, align 8
  br i1 %cmp11.not.i, label %if.else18.i, label %if.then13.i

if.then13.i:                                      ; preds = %do.body10.i
  %tql_prev17.i = getelementptr inbounds %struct.BlockDriverState, ptr %5, i64 0, i32 23, i32 0, i32 1
  store ptr %6, ptr %tql_prev17.i, align 8
  %.pre.i = load ptr, ptr %node_list.i, align 8
  br label %if.end21.i

if.else18.i:                                      ; preds = %do.body10.i
  store ptr %6, ptr getelementptr inbounds (%union.anon.20, ptr @graph_bdrv_states, i64 0, i32 0, i32 1), align 8
  br label %if.end21.i

if.end21.i:                                       ; preds = %if.else18.i, %if.then13.i
  %7 = phi ptr [ null, %if.else18.i ], [ %.pre.i, %if.then13.i ]
  store ptr %7, ptr %6, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %node_list.i, i8 0, i64 16, i1 false)
  br label %do.body32.i

do.body32.i:                                      ; preds = %if.end21.i, %do.end.i
  %bs_list.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 24
  %8 = load ptr, ptr %bs_list.i, align 8
  %cmp33.not.i = icmp eq ptr %8, null
  %tql_prev43.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 24, i32 0, i32 1
  %9 = load ptr, ptr %tql_prev43.i, align 8
  br i1 %cmp33.not.i, label %if.else41.i, label %if.then35.i

if.then35.i:                                      ; preds = %do.body32.i
  %tql_prev40.i = getelementptr inbounds %struct.BlockDriverState, ptr %8, i64 0, i32 24, i32 0, i32 1
  store ptr %9, ptr %tql_prev40.i, align 8
  %.pre32.i = load ptr, ptr %bs_list.i, align 8
  br label %if.end44.i

if.else41.i:                                      ; preds = %do.body32.i
  store ptr %9, ptr getelementptr inbounds (%union.anon.11, ptr @all_bdrv_states, i64 0, i32 0, i32 1), align 8
  br label %if.end44.i

if.end44.i:                                       ; preds = %if.else41.i, %if.then35.i
  %10 = phi ptr [ null, %if.else41.i ], [ %.pre32.i, %if.then35.i ]
  store ptr %10, ptr %9, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %bs_list.i, i8 0, i64 16, i1 false)
  %call.i25.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i25.i, label %do.end.i.i, label %if.else.i26.i

if.else.i26.i:                                    ; preds = %if.end44.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5197, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close) #31
  unreachable

do.end.i.i:                                       ; preds = %if.end44.i
  %11 = load i32, ptr %refcnt, align 8
  %tobool.not.i.i = icmp eq i32 %11, 0
  br i1 %tobool.not.i.i, label %if.end3.i.i, label %if.else2.i.i

if.else2.i.i:                                     ; preds = %do.end.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.285, ptr noundef nonnull @.str.2, i32 noundef 5198, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close) #31
  unreachable

if.end3.i.i:                                      ; preds = %do.end.i.i
  tail call void @bdrv_drained_begin(ptr noundef nonnull %bs) #29
  %call4.i.i = tail call i32 @bdrv_flush(ptr noundef nonnull %bs) #29
  tail call void @bdrv_drain(ptr noundef nonnull %bs) #29
  %drv.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %12 = load ptr, ptr %drv.i.i, align 8
  %tobool5.not.i.i = icmp eq ptr %12, null
  br i1 %tobool5.not.i.i, label %if.end14.i.i, label %if.then6.i.i

if.then6.i.i:                                     ; preds = %if.end3.i.i
  %bdrv_close.i.i = getelementptr inbounds %struct.BlockDriver, ptr %12, i64 0, i32 25
  %13 = load ptr, ptr %bdrv_close.i.i, align 8
  %tobool8.not.i.i = icmp eq ptr %13, null
  br i1 %tobool8.not.i.i, label %if.end12.i.i, label %if.then9.i.i

if.then9.i.i:                                     ; preds = %if.then6.i.i
  tail call void %13(ptr noundef nonnull %bs) #29
  br label %if.end12.i.i

if.end12.i.i:                                     ; preds = %if.then9.i.i, %if.then6.i.i
  store ptr null, ptr %drv.i.i, align 8
  br label %if.end14.i.i

if.end14.i.i:                                     ; preds = %if.end12.i.i, %if.end3.i.i
  tail call void @bdrv_graph_wrlock(ptr noundef nonnull %bs) #29
  %children.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %14 = load ptr, ptr %children.i.i, align 8
  %tobool15.not69.i.i = icmp eq ptr %14, null
  br i1 %tobool15.not69.i.i, label %for.end.i.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.end14.i.i, %bdrv_unref_child.exit.i.i
  %child.070.i.i = phi ptr [ %15, %bdrv_unref_child.exit.i.i ], [ %14, %if.end14.i.i ]
  %next16.i.i = getelementptr inbounds %struct.BdrvChild, ptr %child.070.i.i, i64 0, i32 9
  %15 = load ptr, ptr %next16.i.i, align 8
  %call.i.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i.i, label %bdrv_unref_child.exit.i.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %land.rhs.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3382, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unref_child) #31
  unreachable

bdrv_unref_child.exit.i.i:                        ; preds = %land.rhs.i.i
  tail call fastcc void @bdrv_unset_inherits_from(ptr noundef %bs, ptr noundef nonnull %child.070.i.i, ptr noundef null)
  tail call void @bdrv_root_unref_child(ptr noundef nonnull %child.070.i.i)
  %tobool15.not.i.i = icmp eq ptr %15, null
  br i1 %tobool15.not.i.i, label %for.end.i.i, label %land.rhs.i.i, !llvm.loop !20

for.end.i.i:                                      ; preds = %bdrv_unref_child.exit.i.i, %if.end14.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %16 = load ptr, ptr %backing.i.i, align 8
  %tobool17.not.i.i = icmp eq ptr %16, null
  br i1 %tobool17.not.i.i, label %if.end20.i.i, label %if.else19.i.i

if.else19.i.i:                                    ; preds = %for.end.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.166, ptr noundef nonnull @.str.2, i32 noundef 5217, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close) #31
  unreachable

if.end20.i.i:                                     ; preds = %for.end.i.i
  %file.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 31
  %17 = load ptr, ptr %file.i.i, align 8
  %tobool21.not.i.i = icmp eq ptr %17, null
  br i1 %tobool21.not.i.i, label %if.end24.i.i, label %if.else23.i.i

if.else23.i.i:                                    ; preds = %if.end20.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.167, ptr noundef nonnull @.str.2, i32 noundef 5218, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close) #31
  unreachable

if.end24.i.i:                                     ; preds = %if.end20.i.i
  tail call void @bdrv_graph_wrunlock(ptr noundef nonnull %bs) #29
  %opaque.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 7
  %18 = load ptr, ptr %opaque.i.i, align 8
  tail call void @g_free(ptr noundef %18) #29
  store ptr null, ptr %opaque.i.i, align 8
  %copy_on_read.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 42
  store atomic i32 0, ptr %copy_on_read.i.i monotonic, align 8
  %backing_file.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 12
  store i8 0, ptr %backing_file.i.i, align 1
  %backing_format.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 14
  store i8 0, ptr %backing_format.i.i, align 1
  %total_sectors.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  store i64 0, ptr %total_sectors.i.i, align 8
  %encrypted.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 1
  store i8 0, ptr %encrypted.i.i, align 4
  %sg.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 2
  store i8 0, ptr %sg.i.i, align 1
  %options.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 33
  %19 = load ptr, ptr %options.i.i, align 8
  %tobool31.not.i.i = icmp eq ptr %19, null
  br i1 %tobool31.not.i.i, label %qobject_unref_impl.exit.i.i, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.end24.i.i
  %refcnt.i.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %19, i64 0, i32 1
  %20 = load i64, ptr %refcnt.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq i64 %20, 0
  br i1 %tobool1.not.i.i.i, label %if.else.i50.i.i, label %land.lhs.true.i.i.i

if.else.i50.i.i:                                  ; preds = %lor.lhs.false.i.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i.i.i:                              ; preds = %lor.lhs.false.i.i.i
  %dec.i.i.i = add i64 %20, -1
  store i64 %dec.i.i.i, ptr %refcnt.i.i.i, align 8
  %cmp.i49.i.i = icmp eq i64 %dec.i.i.i, 0
  br i1 %cmp.i49.i.i, label %if.then5.i.i.i, label %qobject_unref_impl.exit.i.i

if.then5.i.i.i:                                   ; preds = %land.lhs.true.i.i.i
  tail call void @qobject_destroy(ptr noundef nonnull %19) #29
  br label %qobject_unref_impl.exit.i.i

qobject_unref_impl.exit.i.i:                      ; preds = %if.then5.i.i.i, %land.lhs.true.i.i.i, %if.end24.i.i
  %explicit_options.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 34
  %21 = load ptr, ptr %explicit_options.i.i, align 8
  %tobool34.not.i.i = icmp eq ptr %21, null
  br i1 %tobool34.not.i.i, label %qobject_unref_impl.exit59.i.i, label %lor.lhs.false.i51.i.i

lor.lhs.false.i51.i.i:                            ; preds = %qobject_unref_impl.exit.i.i
  %refcnt.i52.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %21, i64 0, i32 1
  %22 = load i64, ptr %refcnt.i52.i.i, align 8
  %tobool1.not.i53.i.i = icmp eq i64 %22, 0
  br i1 %tobool1.not.i53.i.i, label %if.else.i58.i.i, label %land.lhs.true.i54.i.i

if.else.i58.i.i:                                  ; preds = %lor.lhs.false.i51.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i54.i.i:                            ; preds = %lor.lhs.false.i51.i.i
  %dec.i55.i.i = add i64 %22, -1
  store i64 %dec.i55.i.i, ptr %refcnt.i52.i.i, align 8
  %cmp.i56.i.i = icmp eq i64 %dec.i55.i.i, 0
  br i1 %cmp.i56.i.i, label %if.then5.i57.i.i, label %qobject_unref_impl.exit59.i.i

if.then5.i57.i.i:                                 ; preds = %land.lhs.true.i54.i.i
  tail call void @qobject_destroy(ptr noundef nonnull %21) #29
  br label %qobject_unref_impl.exit59.i.i

qobject_unref_impl.exit59.i.i:                    ; preds = %if.then5.i57.i.i, %land.lhs.true.i54.i.i, %qobject_unref_impl.exit.i.i
  %full_open_options.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 15
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %options.i.i, i8 0, i64 16, i1 false)
  %23 = load ptr, ptr %full_open_options.i.i, align 8
  %tobool46.not.i.i = icmp eq ptr %23, null
  br i1 %tobool46.not.i.i, label %qobject_unref_impl.exit68.i.i, label %lor.lhs.false.i60.i.i

lor.lhs.false.i60.i.i:                            ; preds = %qobject_unref_impl.exit59.i.i
  %refcnt.i61.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %23, i64 0, i32 1
  %24 = load i64, ptr %refcnt.i61.i.i, align 8
  %tobool1.not.i62.i.i = icmp eq i64 %24, 0
  br i1 %tobool1.not.i62.i.i, label %if.else.i67.i.i, label %land.lhs.true.i63.i.i

if.else.i67.i.i:                                  ; preds = %lor.lhs.false.i60.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i63.i.i:                            ; preds = %lor.lhs.false.i60.i.i
  %dec.i64.i.i = add i64 %24, -1
  store i64 %dec.i64.i.i, ptr %refcnt.i61.i.i, align 8
  %cmp.i65.i.i = icmp eq i64 %dec.i64.i.i, 0
  br i1 %cmp.i65.i.i, label %if.then5.i66.i.i, label %qobject_unref_impl.exit68.i.i

if.then5.i66.i.i:                                 ; preds = %land.lhs.true.i63.i.i
  tail call void @qobject_destroy(ptr noundef nonnull %23) #29
  br label %qobject_unref_impl.exit68.i.i

qobject_unref_impl.exit68.i.i:                    ; preds = %if.then5.i66.i.i, %land.lhs.true.i63.i.i, %qobject_unref_impl.exit59.i.i
  store ptr null, ptr %full_open_options.i.i, align 8
  %block_status_cache.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 55
  %25 = load ptr, ptr %block_status_cache.i.i, align 8
  tail call void @g_free(ptr noundef %25) #29
  store ptr null, ptr %block_status_cache.i.i, align 8
  tail call void @bdrv_release_named_dirty_bitmaps(ptr noundef nonnull %bs) #29
  %dirty_bitmaps.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 40
  %26 = load ptr, ptr %dirty_bitmaps.i.i, align 8
  %cmp.i27.i = icmp eq ptr %26, null
  br i1 %cmp.i27.i, label %if.end60.i.i, label %if.else59.i.i

if.else59.i.i:                                    ; preds = %qobject_unref_impl.exit68.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.286, ptr noundef nonnull @.str.2, i32 noundef 5239, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close) #31
  unreachable

if.end60.i.i:                                     ; preds = %qobject_unref_impl.exit68.i.i
  %aio_notifiers.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 9
  %27 = load ptr, ptr %aio_notifiers.i.i, align 8
  %tobool63.not71.i.i = icmp eq ptr %27, null
  br i1 %tobool63.not71.i.i, label %do.body70.i.i, label %land.rhs64.i.i

land.rhs64.i.i:                                   ; preds = %if.end60.i.i, %land.rhs64.i.i
  %ban.072.i.i = phi ptr [ %28, %land.rhs64.i.i ], [ %27, %if.end60.i.i ]
  %list.i.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.072.i.i, i64 0, i32 4
  %28 = load ptr, ptr %list.i.i, align 8
  tail call void @g_free(ptr noundef nonnull %ban.072.i.i) #29
  %tobool63.not.i.i = icmp eq ptr %28, null
  br i1 %tobool63.not.i.i, label %do.body70.i.i, label %land.rhs64.i.i, !llvm.loop !21

do.body70.i.i:                                    ; preds = %land.rhs64.i.i, %if.end60.i.i
  store ptr null, ptr %aio_notifiers.i.i, align 8
  tail call void @bdrv_drained_end(ptr noundef %bs) #29
  %quiesce_counter.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 46
  %29 = load i32, ptr %quiesce_counter.i.i, align 8
  %tobool74.not.i.i = icmp eq i32 %29, 0
  br i1 %tobool74.not.i.i, label %bdrv_delete.exit, label %if.then75.i.i

if.then75.i.i:                                    ; preds = %do.body70.i.i
  tail call void @bdrv_drain_all_end_quiesce(ptr noundef nonnull %bs) #29
  br label %bdrv_delete.exit

bdrv_delete.exit:                                 ; preds = %do.body70.i.i, %if.then75.i.i
  %reqs_lock.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 48
  tail call void @qemu_mutex_destroy(ptr noundef nonnull %reqs_lock.i) #29
  tail call void @g_free(ptr noundef nonnull %bs) #29
  br label %if.end9

if.end9:                                          ; preds = %do.end, %bdrv_delete.exit, %if.end5
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_new_open_driver(ptr noundef %drv, ptr noundef %node_name, i32 noundef %flags, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1766, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_new_open_driver) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call ptr @bdrv_new_open_driver_opts(ptr noundef %drv, ptr noundef %node_name, ptr noundef null, i32 noundef %flags, ptr noundef %errp)
  ret ptr %call1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local zeroext i1 @bdrv_is_writable(ptr nocapture noundef readonly %bs) local_unnamed_addr #3 {
entry:
  %retval.0.i.i = load i32, ptr %bs, align 8
  %and.i = and i32 %retval.0.i.i, 2050
  %cmp.i = icmp eq i32 %and.i, 2
  ret i1 %cmp.i
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_drv_set_perm_abort(ptr noundef %opaque) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2359, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_drv_set_perm_abort) #31
  unreachable

do.end:                                           ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %opaque, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %bdrv_abort_perm_update = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 57
  %1 = load ptr, ptr %bdrv_abort_perm_update, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end4, label %if.then1

if.then1:                                         ; preds = %do.end
  tail call void %1(ptr noundef nonnull %opaque) #29
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_drv_set_perm_commit(ptr noundef %opaque) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2347, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_drv_set_perm_commit) #31
  unreachable

do.end:                                           ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %opaque, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %bdrv_set_perm = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 56
  %1 = load ptr, ptr %bdrv_set_perm, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end4, label %if.then1

if.then1:                                         ; preds = %do.end
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.then1
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2620, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #31
  unreachable

do.end.i:                                         ; preds = %if.then1
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %opaque, i64 0, i32 32
  %c.06.i = load ptr, ptr %parents.i, align 8
  %tobool.not7.i = icmp eq ptr %c.06.i, null
  br i1 %tobool.not7.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i

for.body.i:                                       ; preds = %do.end.i, %for.body.i
  %c.010.i = phi ptr [ %c.0.i, %for.body.i ], [ %c.06.i, %do.end.i ]
  %cumulative_shared_perms.09.i = phi i64 [ %and.i, %for.body.i ], [ 15, %do.end.i ]
  %cumulative_perms.08.i = phi i64 [ %or.i, %for.body.i ], [ 0, %do.end.i ]
  %perm1.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 5
  %2 = load i64, ptr %perm1.i, align 8
  %or.i = or i64 %2, %cumulative_perms.08.i
  %shared_perm2.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 6
  %3 = load i64, ptr %shared_perm2.i, align 8
  %and.i = and i64 %3, %cumulative_shared_perms.09.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 10
  %c.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool.not.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i, !llvm.loop !22

bdrv_get_cumulative_perm.exit:                    ; preds = %for.body.i, %do.end.i
  %cumulative_perms.0.lcssa.i = phi i64 [ 0, %do.end.i ], [ %or.i, %for.body.i ]
  %cumulative_shared_perms.0.lcssa.i = phi i64 [ 15, %do.end.i ], [ %and.i, %for.body.i ]
  %4 = load ptr, ptr %drv, align 8
  %bdrv_set_perm3 = getelementptr inbounds %struct.BlockDriver, ptr %4, i64 0, i32 56
  %5 = load ptr, ptr %bdrv_set_perm3, align 8
  tail call void %5(ptr noundef %opaque, i64 noundef %cumulative_perms.0.lcssa.i, i64 noundef %cumulative_shared_perms.0.lcssa.i) #29
  br label %if.end4

if.end4:                                          ; preds = %bdrv_get_cumulative_perm.exit, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_get_cumulative_perm(ptr nocapture noundef readonly %bs, ptr nocapture noundef writeonly %perm, ptr nocapture noundef writeonly %shared_perm) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2620, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #31
  unreachable

do.end:                                           ; preds = %entry
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.06 = load ptr, ptr %parents, align 8
  %tobool.not7 = icmp eq ptr %c.06, null
  br i1 %tobool.not7, label %for.end, label %for.body

for.body:                                         ; preds = %do.end, %for.body
  %c.010 = phi ptr [ %c.0, %for.body ], [ %c.06, %do.end ]
  %cumulative_shared_perms.09 = phi i64 [ %and, %for.body ], [ 15, %do.end ]
  %cumulative_perms.08 = phi i64 [ %or, %for.body ], [ 0, %do.end ]
  %perm1 = getelementptr inbounds %struct.BdrvChild, ptr %c.010, i64 0, i32 5
  %0 = load i64, ptr %perm1, align 8
  %or = or i64 %0, %cumulative_perms.08
  %shared_perm2 = getelementptr inbounds %struct.BdrvChild, ptr %c.010, i64 0, i32 6
  %1 = load i64, ptr %shared_perm2, align 8
  %and = and i64 %1, %cumulative_shared_perms.09
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %c.010, i64 0, i32 10
  %c.0 = load ptr, ptr %next_parent, align 8
  %tobool.not = icmp eq ptr %c.0, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !22

for.end:                                          ; preds = %for.body, %do.end
  %cumulative_perms.0.lcssa = phi i64 [ 0, %do.end ], [ %or, %for.body ]
  %cumulative_shared_perms.0.lcssa = phi i64 [ 15, %do.end ], [ %and, %for.body ]
  store i64 %cumulative_perms.0.lcssa, ptr %perm, align 8
  store i64 %cumulative_shared_perms.0.lcssa, ptr %shared_perm, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_perm_names(i64 noundef %perm) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @g_string_sized_new(i64 noundef 30) #29
  %len = getelementptr inbounds %struct._GString, ptr %call, i64 0, i32 1
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %0 = phi ptr [ @.str.66, %entry ], [ %3, %for.inc ]
  %p.07 = phi ptr [ @__const.bdrv_perm_names.permissions, %entry ], [ %incdec.ptr, %for.inc ]
  %1 = load i64, ptr %p.07, align 8
  %and = and i64 %1, %perm
  %tobool2.not = icmp eq i64 %and, 0
  br i1 %tobool2.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %2 = load i64, ptr %len, align 8
  %cmp.not = icmp eq i64 %2, 0
  br i1 %cmp.not, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %call4 = tail call ptr @g_string_append(ptr noundef nonnull %call, ptr noundef nonnull @.str.70) #29
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %call6 = tail call ptr @g_string_append(ptr noundef nonnull %call, ptr noundef nonnull %0) #29
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %incdec.ptr = getelementptr %struct.perm_name, ptr %p.07, i64 1
  %name = getelementptr %struct.perm_name, ptr %p.07, i64 1, i32 1
  %3 = load ptr, ptr %name, align 8
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !23

for.end:                                          ; preds = %for.inc
  %call8 = tail call ptr @g_string_free(ptr noundef %call, i32 noundef 0) #29
  ret ptr %call8
}

declare ptr @g_string_sized_new(i64 noundef) local_unnamed_addr #5

declare ptr @g_string_free(ptr noundef, i32 noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_child_try_set_perm(ptr noundef %c, i64 noundef %perm, i64 noundef %shared, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call ptr @tran_new() #29
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2694, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_try_set_perm) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call noalias dereferenceable_or_null(24) ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #32
  %call1.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1.i, label %bdrv_child_set_perm.exit, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2329, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_set_perm) #31
  unreachable

bdrv_child_set_perm.exit:                         ; preds = %do.end
  %perm2.i = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 5
  %shared_perm.i = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 6
  store ptr %c, ptr %call.i, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %call.i, i64 8
  %0 = load <2 x i64>, ptr %perm2.i, align 8
  store <2 x i64> %0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 8
  store i64 %perm, ptr %perm2.i, align 8
  store i64 %shared, ptr %shared_perm.i, align 8
  tail call void @tran_add(ptr noundef %call, ptr noundef nonnull @bdrv_child_set_pem_drv, ptr noundef nonnull %call.i) #29
  %1 = load ptr, ptr %c, align 8
  %call2 = call fastcc i32 @bdrv_refresh_perms(ptr noundef %1, ptr noundef %call, ptr noundef nonnull %local_err), !range !14
  %cmp.i = icmp slt i32 %call2, 0
  br i1 %cmp.i, label %if.then3, label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %bdrv_child_set_perm.exit
  call void @tran_commit(ptr noundef %call) #29
  br label %if.end11

if.then3:                                         ; preds = %bdrv_child_set_perm.exit
  call void @tran_abort(ptr noundef %call) #29
  %2 = load i64, ptr %perm2.i, align 8
  %not = xor i64 %2, -1
  %and = and i64 %not, %perm
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %lor.lhs.false, label %if.then8

lor.lhs.false:                                    ; preds = %if.then3
  %3 = load i64, ptr %shared_perm.i, align 8
  %not5 = xor i64 %shared, -1
  %and6 = and i64 %3, %not5
  %tobool7.not = icmp eq i64 %and6, 0
  br i1 %tobool7.not, label %if.else9, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.then3
  %4 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %4) #29
  br label %if.end11

if.else9:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %5) #29
  br label %if.end11

if.end11:                                         ; preds = %tran_finalize.exit, %if.then8, %if.else9
  %ret.0 = phi i32 [ %call2, %if.then8 ], [ 0, %if.else9 ], [ 0, %tran_finalize.exit ]
  ret i32 %ret.0
}

declare ptr @tran_new() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_refresh_perms(ptr noundef %bs, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %call = tail call fastcc ptr @bdrv_topological_dfs(ptr noundef null, ptr noundef null, ptr noundef %bs)
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2672, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_refresh_perms) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %tran, null
  br i1 %tobool.not, label %if.end4, label %if.end4.thread

if.end4.thread:                                   ; preds = %do.end
  %call56 = tail call fastcc i32 @bdrv_do_refresh_perms(ptr noundef %call, ptr noundef null, ptr noundef nonnull %tran, ptr noundef %errp), !range !14
  br label %if.end8

if.end4:                                          ; preds = %do.end
  %call3 = tail call ptr @tran_new() #29
  %call5 = tail call fastcc i32 @bdrv_do_refresh_perms(ptr noundef %call, ptr noundef null, ptr noundef %call3, ptr noundef %errp), !range !14
  %tobool6.not = icmp eq ptr %call3, null
  br i1 %tobool6.not, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end4
  %cmp.i = icmp slt i32 %call5, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then7
  tail call void @tran_abort(ptr noundef nonnull %call3) #29
  br label %if.end8

if.else.i:                                        ; preds = %if.then7
  tail call void @tran_commit(ptr noundef nonnull %call3) #29
  br label %if.end8

if.end8:                                          ; preds = %if.else.i, %if.then.i, %if.end4.thread, %if.end4
  %call58 = phi i32 [ %call56, %if.end4.thread ], [ %call5, %if.end4 ], [ %call5, %if.then.i ], [ 0, %if.else.i ]
  %tobool.not.i.i = icmp eq ptr %call, null
  br i1 %tobool.not.i.i, label %glib_autoptr_cleanup_GSList.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end8
  tail call void @g_slist_free(ptr noundef nonnull %call) #29
  br label %glib_autoptr_cleanup_GSList.exit

glib_autoptr_cleanup_GSList.exit:                 ; preds = %if.end8, %if.then.i.i
  ret i32 %call58
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_child_refresh_perms(ptr noundef %bs, ptr noundef %c, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %perms = alloca i64, align 8
  %shared = alloca i64, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2726, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_refresh_perms) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2620, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #31
  unreachable

do.end.i:                                         ; preds = %do.end
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.06.i = load ptr, ptr %parents.i, align 8
  %tobool.not7.i = icmp eq ptr %c.06.i, null
  br i1 %tobool.not7.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i

for.body.i:                                       ; preds = %do.end.i, %for.body.i
  %c.010.i = phi ptr [ %c.0.i, %for.body.i ], [ %c.06.i, %do.end.i ]
  %cumulative_shared_perms.09.i = phi i64 [ %and.i, %for.body.i ], [ 15, %do.end.i ]
  %cumulative_perms.08.i = phi i64 [ %or.i, %for.body.i ], [ 0, %do.end.i ]
  %perm1.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 5
  %0 = load i64, ptr %perm1.i, align 8
  %or.i = or i64 %0, %cumulative_perms.08.i
  %shared_perm2.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 6
  %1 = load i64, ptr %shared_perm2.i, align 8
  %and.i = and i64 %1, %cumulative_shared_perms.09.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 10
  %c.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool.not.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i, !llvm.loop !22

bdrv_get_cumulative_perm.exit:                    ; preds = %for.body.i, %do.end.i
  %cumulative_perms.0.lcssa.i = phi i64 [ 0, %do.end.i ], [ %or.i, %for.body.i ]
  %cumulative_shared_perms.0.lcssa.i = phi i64 [ 15, %do.end.i ], [ %and.i, %for.body.i ]
  %2 = load ptr, ptr %c, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 3
  %3 = load i32, ptr %role, align 8
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %4 = load ptr, ptr %drv.i, align 8
  %tobool.not.i5 = icmp eq ptr %4, null
  br i1 %tobool.not.i5, label %if.else.i8, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %bdrv_get_cumulative_perm.exit
  %bdrv_child_perm.i = getelementptr inbounds %struct.BlockDriver, ptr %4, i64 0, i32 58
  %5 = load ptr, ptr %bdrv_child_perm.i, align 8
  %tobool2.not.i = icmp eq ptr %5, null
  br i1 %tobool2.not.i, label %if.else.i8, label %do.body.i

if.else.i8:                                       ; preds = %land.lhs.true.i, %bdrv_get_cumulative_perm.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.196, ptr noundef nonnull @.str.2, i32 noundef 2257, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_perm) #31
  unreachable

do.body.i:                                        ; preds = %land.lhs.true.i
  %call.i6 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i6, label %do.end.i7, label %if.else4.i

if.else4.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2258, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_perm) #31
  unreachable

do.end.i7:                                        ; preds = %do.body.i
  %6 = load ptr, ptr %drv.i, align 8
  %bdrv_child_perm7.i = getelementptr inbounds %struct.BlockDriver, ptr %6, i64 0, i32 58
  %7 = load ptr, ptr %bdrv_child_perm7.i, align 8
  call void %7(ptr noundef nonnull %bs, ptr noundef nonnull %c, i32 noundef %3, ptr noundef null, i64 noundef %cumulative_perms.0.lcssa.i, i64 noundef %cumulative_shared_perms.0.lcssa.i, ptr noundef nonnull %perms, ptr noundef nonnull %shared) #29
  %tobool8.not.i = icmp eq ptr %2, null
  br i1 %tobool8.not.i, label %bdrv_child_perm.exit, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %do.end.i7
  %force_share.i = getelementptr inbounds %struct.BlockDriverState, ptr %2, i64 0, i32 4
  %8 = load i8, ptr %force_share.i, align 1
  %9 = and i8 %8, 1
  %tobool10.not.i = icmp eq i8 %9, 0
  br i1 %tobool10.not.i, label %bdrv_child_perm.exit, label %if.then11.i

if.then11.i:                                      ; preds = %land.lhs.true9.i
  store i64 15, ptr %shared, align 8
  br label %bdrv_child_perm.exit

bdrv_child_perm.exit:                             ; preds = %do.end.i7, %land.lhs.true9.i, %if.then11.i
  %10 = load i64, ptr %perms, align 8
  %11 = load i64, ptr %shared, align 8
  %call2 = call i32 @bdrv_child_try_set_perm(ptr noundef nonnull %c, i64 noundef %10, i64 noundef %11, ptr noundef %errp)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_default_perms(ptr noundef readonly %bs, ptr nocapture noundef readnone %c, i32 noundef %role, ptr noundef readonly %reopen_queue, i64 noundef %perm, i64 noundef %shared, ptr nocapture noundef writeonly %nperm, ptr nocapture noundef writeonly %nshared) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2872, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_default_perms) #31
  unreachable

do.end:                                           ; preds = %entry
  %and = and i32 %role, 4
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else7, label %if.then1

if.then1:                                         ; preds = %do.end
  %and2 = and i32 %role, 11
  %tobool3.not = icmp eq i32 %and2, 0
  br i1 %tobool3.not, label %if.end6, label %if.else5

if.else5:                                         ; preds = %if.then1
  tail call void @__assert_fail(ptr noundef nonnull @.str.71, ptr noundef nonnull @.str.2, i32 noundef 2875, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_default_perms) #31
  unreachable

if.end6:                                          ; preds = %if.then1
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_filter_default_perms.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end6
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2746, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_default_perms) #31
  unreachable

bdrv_filter_default_perms.exit:                   ; preds = %if.end6
  %and.i = and i64 %perm, 15
  store i64 %and.i, ptr %nperm, align 8
  %and1.i = and i64 %shared, 15
  br label %if.end25

if.else7:                                         ; preds = %do.end
  %and8 = and i32 %role, 8
  %tobool9.not = icmp eq i32 %and8, 0
  %and17 = and i32 %role, 3
  %tobool18.not = icmp eq i32 %and17, 0
  br i1 %tobool9.not, label %if.else16, label %if.then10

if.then10:                                        ; preds = %if.else7
  br i1 %tobool18.not, label %do.body.i, label %if.else14

if.else14:                                        ; preds = %if.then10
  tail call void @__assert_fail(ptr noundef nonnull @.str.72, ptr noundef nonnull @.str.2, i32 noundef 2879, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_default_perms) #31
  unreachable

do.body.i:                                        ; preds = %if.then10
  %call.i23 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i23, label %bdrv_default_perms_for_cow.exit, label %if.else2.i

if.else2.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2758, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_default_perms_for_cow) #31
  unreachable

bdrv_default_perms_for_cow.exit:                  ; preds = %do.body.i
  %and5.i = and i64 %shared, 2
  %tobool6.not.i = icmp eq i64 %and5.i, 0
  %0 = load i32, ptr %bs, align 8
  %and10.i = and i32 %0, 2048
  %tobool11.not.i = icmp eq i32 %and10.i, 0
  %1 = and i1 %tobool6.not.i, %tobool11.not.i
  %shared.addr.1.i = select i1 %1, i64 5, i64 15
  %and4.i = and i64 %perm, 1
  store i64 %and4.i, ptr %nperm, align 8
  br label %if.end25

if.else16:                                        ; preds = %if.else7
  br i1 %tobool18.not, label %do.body21, label %if.then19

if.then19:                                        ; preds = %if.else16
  %call.i25 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i25, label %if.end3.i, label %if.else.i26

if.else.i26:                                      ; preds = %if.then19
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2795, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_default_perms_for_storage) #31
  unreachable

if.end3.i:                                        ; preds = %if.then19
  %cmp.not.i.i = icmp eq ptr %reopen_queue, null
  br i1 %cmp.not.i.i, label %bdrv_reopen_get_flags.exit.i, label %for.cond.preheader.i.i

for.cond.preheader.i.i:                           ; preds = %if.end3.i
  %entry1.07.i.i = load ptr, ptr %reopen_queue, align 8
  %tobool.not8.i.i = icmp eq ptr %entry1.07.i.i, null
  br i1 %tobool.not8.i.i, label %bdrv_reopen_get_flags.exit.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.cond.preheader.i.i, %for.inc.i.i
  %entry1.09.i.i = phi ptr [ %entry1.0.i.i, %for.inc.i.i ], [ %entry1.07.i.i, %for.cond.preheader.i.i ]
  %state.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i, i64 0, i32 1
  %2 = load ptr, ptr %state.i.i, align 8
  %cmp3.i.i = icmp eq ptr %2, %bs
  br i1 %cmp3.i.i, label %if.then4.i.i, label %for.inc.i.i

if.then4.i.i:                                     ; preds = %for.body.i.i
  %flags.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i, i64 0, i32 1, i32 1
  br label %bdrv_reopen_get_flags.exit.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %entry6.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i, i64 0, i32 2
  %entry1.0.i.i = load ptr, ptr %entry6.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %entry1.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_reopen_get_flags.exit.i, label %for.body.i.i, !llvm.loop !24

bdrv_reopen_get_flags.exit.i:                     ; preds = %for.inc.i.i, %if.then4.i.i, %for.cond.preheader.i.i, %if.end3.i
  %retval.0.in.i.i = phi ptr [ %flags.i.i, %if.then4.i.i ], [ %bs, %if.end3.i ], [ %bs, %for.cond.preheader.i.i ], [ %bs, %for.inc.i.i ]
  %retval.0.i.i = load i32, ptr %retval.0.in.i.i, align 8
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %bdrv_filter_default_perms.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %bdrv_reopen_get_flags.exit.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2746, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_default_perms) #31
  unreachable

bdrv_filter_default_perms.exit.i:                 ; preds = %bdrv_reopen_get_flags.exit.i
  %and.i.i = and i64 %perm, 15
  %and1.i.i = and i64 %shared, 15
  %and5.i29 = and i32 %role, 2
  %tobool6.not.i30 = icmp eq i32 %and5.i29, 0
  br i1 %tobool6.not.i30, label %if.end17.i, label %if.then7.i

if.then7.i:                                       ; preds = %bdrv_filter_default_perms.exit.i
  br i1 %cmp.not.i.i, label %bdrv_is_writable_after_reopen.exit.i, label %for.cond.preheader.i.i.i

for.cond.preheader.i.i.i:                         ; preds = %if.then7.i
  %entry1.07.i.i.i = load ptr, ptr %reopen_queue, align 8
  %tobool.not8.i.i.i = icmp eq ptr %entry1.07.i.i.i, null
  br i1 %tobool.not8.i.i.i, label %bdrv_is_writable_after_reopen.exit.i, label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %for.cond.preheader.i.i.i, %for.inc.i.i.i
  %entry1.09.i.i.i = phi ptr [ %entry1.0.i.i.i, %for.inc.i.i.i ], [ %entry1.07.i.i.i, %for.cond.preheader.i.i.i ]
  %state.i.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i.i, i64 0, i32 1
  %3 = load ptr, ptr %state.i.i.i, align 8
  %cmp3.i.i.i = icmp eq ptr %3, %bs
  br i1 %cmp3.i.i.i, label %if.then4.i.i.i, label %for.inc.i.i.i

if.then4.i.i.i:                                   ; preds = %for.body.i.i.i
  %flags.i.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i.i, i64 0, i32 1, i32 1
  br label %bdrv_is_writable_after_reopen.exit.i

for.inc.i.i.i:                                    ; preds = %for.body.i.i.i
  %entry6.i.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i.i, i64 0, i32 2
  %entry1.0.i.i.i = load ptr, ptr %entry6.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %entry1.0.i.i.i, null
  br i1 %tobool.not.i.i.i, label %bdrv_is_writable_after_reopen.exit.i, label %for.body.i.i.i, !llvm.loop !24

bdrv_is_writable_after_reopen.exit.i:             ; preds = %for.inc.i.i.i, %if.then4.i.i.i, %for.cond.preheader.i.i.i, %if.then7.i
  %retval.0.in.i.i.i = phi ptr [ %flags.i.i.i, %if.then4.i.i.i ], [ %bs, %if.then7.i ], [ %bs, %for.cond.preheader.i.i.i ], [ %bs, %for.inc.i.i.i ]
  %retval.0.i.i.i = load i32, ptr %retval.0.in.i.i.i, align 8
  %and.i9.i = and i32 %retval.0.i.i.i, 2050
  %cmp.i.i = icmp eq i32 %and.i9.i, 2
  %or.i = or i64 %and.i.i, 10
  %spec.select.i = select i1 %cmp.i.i, i64 %or.i, i64 %and.i.i
  %and11.i = and i32 %retval.0.i.i, 65536
  %tobool12.not.i = icmp eq i32 %and11.i, 0
  %or14.i = zext i1 %tobool12.not.i to i64
  %perm.addr.1.i = or i64 %spec.select.i, %or14.i
  %and16.i = and i64 %shared, 5
  br label %if.end17.i

if.end17.i:                                       ; preds = %bdrv_is_writable_after_reopen.exit.i, %bdrv_filter_default_perms.exit.i
  %perm.addr.2.i = phi i64 [ %and.i.i, %bdrv_filter_default_perms.exit.i ], [ %perm.addr.1.i, %bdrv_is_writable_after_reopen.exit.i ]
  %shared.addr.0.i = phi i64 [ %and1.i.i, %bdrv_filter_default_perms.exit.i ], [ %and16.i, %bdrv_is_writable_after_reopen.exit.i ]
  %and18.i = and i32 %role, 1
  %tobool19.not.i = icmp eq i32 %and18.i, 0
  br i1 %tobool19.not.i, label %bdrv_default_perms_for_storage.exit, label %if.then20.i

if.then20.i:                                      ; preds = %if.end17.i
  %and21.i = and i64 %shared.addr.0.i, 7
  %and22.i = lshr i64 %perm.addr.2.i, 1
  %4 = and i64 %and22.i, 2
  %spec.select10.i = or i64 %4, %perm.addr.2.i
  %and27.i = shl nuw nsw i64 %spec.select10.i, 2
  %5 = and i64 %and27.i, 8
  %spec.select12.i = or i64 %5, %spec.select10.i
  br label %bdrv_default_perms_for_storage.exit

bdrv_default_perms_for_storage.exit:              ; preds = %if.end17.i, %if.then20.i
  %perm.addr.4.i = phi i64 [ %perm.addr.2.i, %if.end17.i ], [ %spec.select12.i, %if.then20.i ]
  %shared.addr.1.i31 = phi i64 [ %shared.addr.0.i, %if.end17.i ], [ %and21.i, %if.then20.i ]
  %6 = load i32, ptr %bs, align 8
  %and33.i = and i32 %6, 2048
  %tobool34.not.i = icmp eq i32 %and33.i, 0
  %or36.i = or i64 %shared.addr.1.i31, 10
  %spec.select11.i = select i1 %tobool34.not.i, i64 %shared.addr.1.i31, i64 %or36.i
  store i64 %perm.addr.4.i, ptr %nperm, align 8
  br label %if.end25

do.body21:                                        ; preds = %if.else16
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 2886, ptr noundef nonnull @__func__.bdrv_default_perms, ptr noundef null) #31
  unreachable

if.end25:                                         ; preds = %bdrv_default_perms_for_cow.exit, %bdrv_default_perms_for_storage.exit, %bdrv_filter_default_perms.exit
  %shared.addr.1.i.sink = phi i64 [ %shared.addr.1.i, %bdrv_default_perms_for_cow.exit ], [ %spec.select11.i, %bdrv_default_perms_for_storage.exit ], [ %and1.i, %bdrv_filter_default_perms.exit ]
  store i64 %shared.addr.1.i.sink, ptr %nshared, align 8
  ret void
}

; Function Attrs: noreturn
declare void @g_assertion_message_expr(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #15

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_qapi_perm_to_blk_perm(i32 noundef %qapi_perm) local_unnamed_addr #4 {
entry:
  %cmp = icmp ult i32 %qapi_perm, 4
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.73, ptr noundef nonnull @.str.2, i32 noundef 2902, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_qapi_perm_to_blk_perm) #31
  unreachable

if.end:                                           ; preds = %entry
  %idxprom = zext nneg i32 %qapi_perm to i64
  %arrayidx = getelementptr [4 x i64], ptr @bdrv_qapi_perm_to_blk_perm.permissions, i64 0, i64 %idxprom
  %0 = load i64, ptr %arrayidx, align 8
  ret i64 %0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_root_attach_child(ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, i64 noundef %perm, i64 noundef %shared_perm, ptr noundef %opaque, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @tran_new() #29
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3220, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_root_attach_child) #31
  unreachable

do.end:                                           ; preds = %entry
  %call2 = tail call fastcc ptr @bdrv_attach_child_common(ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, i64 noundef %perm, i64 noundef %shared_perm, ptr noundef %opaque, ptr noundef %call, ptr noundef %errp)
  %tobool.not = icmp eq ptr %call2, null
  br i1 %tobool.not, label %if.then.i, label %out

out:                                              ; preds = %do.end
  %call5 = tail call fastcc i32 @bdrv_refresh_perms(ptr noundef %child_bs, ptr noundef %call, ptr noundef %errp), !range !14
  %cmp.i = icmp slt i32 %call5, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %do.end, %out
  tail call void @tran_abort(ptr noundef %call) #29
  br label %tran_finalize.exit

if.else.i:                                        ; preds = %out
  tail call void @tran_commit(ptr noundef %call) #29
  br label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %if.then.i, %if.else.i
  %cmp.i10 = phi i1 [ true, %if.then.i ], [ false, %if.else.i ]
  %tobool.not.i = icmp eq ptr %child_bs, null
  br i1 %tobool.not.i, label %bdrv_schedule_unref.exit, label %if.end.i

if.end.i:                                         ; preds = %tran_finalize.exit
  %call.i = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_bh_schedule_oneshot_full(ptr noundef %call.i, ptr noundef nonnull @bdrv_schedule_unref_bh, ptr noundef nonnull %child_bs, ptr noundef nonnull @.str.105) #29
  br label %bdrv_schedule_unref.exit

bdrv_schedule_unref.exit:                         ; preds = %tran_finalize.exit, %if.end.i
  %cond = select i1 %cmp.i10, ptr null, ptr %call2
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_attach_child_common(ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, i64 noundef %perm, i64 noundef %shared_perm, ptr noundef %opaque, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %.compoundliteral.sroa.10 = alloca [22 x i8], align 2
  %local_err = alloca ptr, align 8
  %tobool.not.i = icmp eq ptr %child_bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %get_parent_desc = getelementptr inbounds %struct.BdrvChildClass, ptr %child_class, i64 0, i32 4
  %1 = load ptr, ptr %get_parent_desc, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.else, label %do.body

if.else:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.199, ptr noundef nonnull @.str.2, i32 noundef 3068, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child_common) #31
  unreachable

do.body:                                          ; preds = %bdrv_get_aio_context.exit
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else3

if.else3:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3069, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child_common) #31
  unreachable

do.end:                                           ; preds = %do.body
  %call5 = tail call noalias dereferenceable_or_null(96) ptr @g_malloc_n(i64 noundef 1, i64 noundef 96) #32
  %call6 = tail call noalias ptr @g_strdup(ptr noundef %child_name) #29
  %.compoundliteral.sroa.10.6.next.sroa_idx50 = getelementptr inbounds i8, ptr %.compoundliteral.sroa.10, i64 6
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 2 dereferenceable(16) %.compoundliteral.sroa.10.6.next.sroa_idx50, i8 0, i64 16, i1 false)
  store ptr null, ptr %call5, align 8
  %.compoundliteral.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 8
  store ptr %call6, ptr %.compoundliteral.sroa.2.0..sroa_idx, align 8
  %.compoundliteral.sroa.3.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 16
  store ptr %child_class, ptr %.compoundliteral.sroa.3.0..sroa_idx, align 8
  %.compoundliteral.sroa.4.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 24
  store i32 %child_role, ptr %.compoundliteral.sroa.4.0..sroa_idx, align 8
  %.compoundliteral.sroa.57.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 32
  store ptr %opaque, ptr %.compoundliteral.sroa.57.0..sroa_idx, align 8
  %.compoundliteral.sroa.6.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 40
  store i64 %perm, ptr %.compoundliteral.sroa.6.0..sroa_idx, align 8
  %.compoundliteral.sroa.7.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 48
  store i64 %shared_perm, ptr %.compoundliteral.sroa.7.0..sroa_idx, align 8
  %.compoundliteral.sroa.8.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 56
  store i8 0, ptr %.compoundliteral.sroa.8.0..sroa_idx, align 8
  %.compoundliteral.sroa.9.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 57
  store i8 0, ptr %.compoundliteral.sroa.9.0..sroa_idx, align 1
  %.compoundliteral.sroa.10.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 58
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 2 dereferenceable(22) %.compoundliteral.sroa.10.0..sroa_idx, ptr noundef nonnull align 2 dereferenceable(22) %.compoundliteral.sroa.10, i64 22, i1 false)
  %.compoundliteral.sroa.11.0..sroa_idx = getelementptr inbounds i8, ptr %call5, i64 80
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %.compoundliteral.sroa.11.0..sroa_idx, i8 0, i64 16, i1 false)
  %get_parent_aio_context.i = getelementptr inbounds %struct.BdrvChildClass, ptr %child_class, i64 0, i32 16
  %2 = load ptr, ptr %get_parent_aio_context.i, align 8
  %call.i34 = tail call ptr %2(ptr noundef nonnull %call5) #29
  %cmp.not = icmp eq ptr %cond.i, %call.i34
  br i1 %cmp.not, label %if.end35, label %if.then11

if.then11:                                        ; preds = %do.end
  store ptr null, ptr %local_err, align 8
  %call12 = call i32 @bdrv_try_change_aio_context(ptr noundef %child_bs, ptr noundef %call.i34, ptr noundef null, ptr noundef nonnull %local_err), !range !25
  %cmp13 = icmp slt i32 %call12, 0
  br i1 %cmp13, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.then11
  %change_aio_ctx = getelementptr inbounds %struct.BdrvChildClass, ptr %child_class, i64 0, i32 13
  %3 = load ptr, ptr %change_aio_ctx, align 8
  %tobool14.not = icmp eq ptr %3, null
  br i1 %tobool14.not, label %if.then33, label %if.then15

if.then15:                                        ; preds = %land.lhs.true
  %call16 = call ptr @tran_new() #29
  %call17 = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  %call18 = call i32 @g_hash_table_add(ptr noundef %call17, ptr noundef nonnull %call5) #29
  %4 = load ptr, ptr %change_aio_ctx, align 8
  %call20 = call zeroext i1 %4(ptr noundef nonnull %call5, ptr noundef %cond.i, ptr noundef %call17, ptr noundef %call16, ptr noundef null) #29
  br i1 %call20, label %tran_finalize.exit, label %tran_finalize.exit.thread

tran_finalize.exit.thread:                        ; preds = %if.then15
  call void @tran_abort(ptr noundef %call16) #29
  call void @g_hash_table_destroy(ptr noundef %call17) #29
  br label %if.then33

tran_finalize.exit:                               ; preds = %if.then15
  %5 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %5) #29
  call void @tran_commit(ptr noundef %call16) #29
  call void @g_hash_table_destroy(ptr noundef %call17) #29
  br label %if.end35

if.then33:                                        ; preds = %tran_finalize.exit.thread, %land.lhs.true
  %6 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %6) #29
  call fastcc void @bdrv_child_free(ptr noundef nonnull %call5)
  br label %return

if.end35:                                         ; preds = %tran_finalize.exit, %if.then11, %do.end
  br i1 %tobool.not.i, label %cond.false.i39, label %cond.true.i36

cond.true.i36:                                    ; preds = %if.end35
  %aio_context.i37 = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 8
  %7 = load ptr, ptr %aio_context.i37, align 8
  br label %bdrv_get_aio_context.exit41

cond.false.i39:                                   ; preds = %if.end35
  %call.i40 = call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit41

bdrv_get_aio_context.exit41:                      ; preds = %cond.true.i36, %cond.false.i39
  %cond.i38 = phi ptr [ %7, %cond.true.i36 ], [ %call.i40, %cond.false.i39 ]
  %cmp37.not = icmp eq ptr %cond.i38, %cond.i
  br i1 %cmp37.not, label %if.end46.critedge, label %if.then39

if.then39:                                        ; preds = %bdrv_get_aio_context.exit41
  call void @aio_context_release(ptr noundef %cond.i) #29
  call void @aio_context_acquire(ptr noundef %cond.i38) #29
  %call.i42 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i42, label %bdrv_ref.exit, label %if.else.i43

if.else.i43:                                      ; preds = %if.then39
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %if.then39
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 26
  %8 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %8, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  call void @bdrv_parent_drained_begin_single(ptr noundef nonnull %call5) #29
  call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %call5, ptr noundef %child_bs)
  %call41 = call noalias dereferenceable_or_null(24) ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #32
  store ptr %call5, ptr %call41, align 8
  %.compoundliteral42.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call41, i64 8
  store ptr %call.i34, ptr %.compoundliteral42.sroa.2.0..sroa_idx, align 8
  %.compoundliteral42.sroa.3.0..sroa_idx = getelementptr inbounds i8, ptr %call41, i64 16
  store ptr %cond.i, ptr %.compoundliteral42.sroa.3.0..sroa_idx, align 8
  call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_attach_child_common_drv, ptr noundef nonnull %call41) #29
  call void @aio_context_release(ptr noundef %cond.i38) #29
  call void @aio_context_acquire(ptr noundef %cond.i) #29
  br label %return

if.end46.critedge:                                ; preds = %bdrv_get_aio_context.exit41
  %call.i44 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i44, label %bdrv_ref.exit48, label %if.else.i45

if.else.i45:                                      ; preds = %if.end46.critedge
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit48:                                  ; preds = %if.end46.critedge
  %refcnt.i46 = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 26
  %9 = load i32, ptr %refcnt.i46, align 8
  %inc.i47 = add i32 %9, 1
  store i32 %inc.i47, ptr %refcnt.i46, align 8
  call void @bdrv_parent_drained_begin_single(ptr noundef nonnull %call5) #29
  call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %call5, ptr noundef %child_bs)
  %call41.c = call noalias dereferenceable_or_null(24) ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #32
  store ptr %call5, ptr %call41.c, align 8
  %.compoundliteral42.sroa.2.0..sroa_idx.c = getelementptr inbounds i8, ptr %call41.c, i64 8
  store ptr %call.i34, ptr %.compoundliteral42.sroa.2.0..sroa_idx.c, align 8
  %.compoundliteral42.sroa.3.0..sroa_idx.c = getelementptr inbounds i8, ptr %call41.c, i64 16
  store ptr %cond.i, ptr %.compoundliteral42.sroa.3.0..sroa_idx.c, align 8
  call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_attach_child_common_drv, ptr noundef nonnull %call41.c) #29
  br label %return

return:                                           ; preds = %bdrv_ref.exit, %bdrv_ref.exit48, %if.then33
  %retval.0 = phi ptr [ null, %if.then33 ], [ %call5, %bdrv_ref.exit48 ], [ %call5, %bdrv_ref.exit ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_schedule_unref(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_bh_schedule_oneshot_full(ptr noundef %call, ptr noundef nonnull @bdrv_schedule_unref_bh, ptr noundef nonnull %bs, ptr noundef nonnull @.str.105) #29
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_attach_child(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @tran_new() #29
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3262, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child) #31
  unreachable

do.end:                                           ; preds = %entry
  %call2 = tail call fastcc ptr @bdrv_attach_child_noperm(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %call, ptr noundef %errp)
  %tobool.not = icmp eq ptr %call2, null
  br i1 %tobool.not, label %if.then.i, label %out

out:                                              ; preds = %do.end
  %call5 = tail call fastcc i32 @bdrv_refresh_perms(ptr noundef %parent_bs, ptr noundef %call, ptr noundef %errp), !range !14
  %cmp.i = icmp slt i32 %call5, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %do.end, %out
  tail call void @tran_abort(ptr noundef %call) #29
  br label %tran_finalize.exit

if.else.i:                                        ; preds = %out
  tail call void @tran_commit(ptr noundef %call) #29
  br label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %if.then.i, %if.else.i
  %cmp.i10 = phi i1 [ true, %if.then.i ], [ false, %if.else.i ]
  %tobool.not.i = icmp eq ptr %child_bs, null
  br i1 %tobool.not.i, label %bdrv_schedule_unref.exit, label %if.end.i

if.end.i:                                         ; preds = %tran_finalize.exit
  %call.i = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_bh_schedule_oneshot_full(ptr noundef %call.i, ptr noundef nonnull @bdrv_schedule_unref_bh, ptr noundef nonnull %child_bs, ptr noundef nonnull @.str.105) #29
  br label %bdrv_schedule_unref.exit

bdrv_schedule_unref.exit:                         ; preds = %tran_finalize.exit, %if.end.i
  %cond = select i1 %cmp.i10, ptr null, ptr %call2
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_attach_child_noperm(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %perm = alloca i64, align 8
  %shared_perm = alloca i64, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.else, label %do.body

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.201, ptr noundef nonnull @.str.2, i32 noundef 3181, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child_noperm) #31
  unreachable

do.body:                                          ; preds = %entry
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else2

if.else2:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3182, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child_noperm) #31
  unreachable

do.end:                                           ; preds = %do.body
  %call4 = tail call fastcc zeroext i1 @bdrv_recurse_has_child(ptr noundef %child_bs, ptr noundef nonnull %parent_bs)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %do.end
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 22
  %node_name6 = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3186, ptr noundef nonnull @__func__.bdrv_attach_child_noperm, ptr noundef nonnull @.str.202, ptr noundef nonnull %node_name, ptr noundef %child_name, ptr noundef nonnull %node_name6) #29
  br label %return

if.end8:                                          ; preds = %do.end
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.end8
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2620, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #31
  unreachable

do.end.i:                                         ; preds = %if.end8
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 32
  %c.06.i = load ptr, ptr %parents.i, align 8
  %tobool.not7.i = icmp eq ptr %c.06.i, null
  br i1 %tobool.not7.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i

for.body.i:                                       ; preds = %do.end.i, %for.body.i
  %c.010.i = phi ptr [ %c.0.i, %for.body.i ], [ %c.06.i, %do.end.i ]
  %cumulative_shared_perms.09.i = phi i64 [ %and.i, %for.body.i ], [ 15, %do.end.i ]
  %cumulative_perms.08.i = phi i64 [ %or.i, %for.body.i ], [ 0, %do.end.i ]
  %perm1.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 5
  %1 = load i64, ptr %perm1.i, align 8
  %or.i = or i64 %1, %cumulative_perms.08.i
  %shared_perm2.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 6
  %2 = load i64, ptr %shared_perm2.i, align 8
  %and.i = and i64 %2, %cumulative_shared_perms.09.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 10
  %c.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool.not.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i, !llvm.loop !22

bdrv_get_cumulative_perm.exit:                    ; preds = %for.body.i, %do.end.i
  %cumulative_perms.0.lcssa.i = phi i64 [ 0, %do.end.i ], [ %or.i, %for.body.i ]
  %cumulative_shared_perms.0.lcssa.i = phi i64 [ 15, %do.end.i ], [ %and.i, %for.body.i ]
  store i64 %cumulative_perms.0.lcssa.i, ptr %perm, align 8
  store i64 %cumulative_shared_perms.0.lcssa.i, ptr %shared_perm, align 8
  %3 = load ptr, ptr %drv, align 8
  %tobool.not.i12 = icmp eq ptr %3, null
  br i1 %tobool.not.i12, label %if.else.i15, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %bdrv_get_cumulative_perm.exit
  %bdrv_child_perm.i = getelementptr inbounds %struct.BlockDriver, ptr %3, i64 0, i32 58
  %4 = load ptr, ptr %bdrv_child_perm.i, align 8
  %tobool2.not.i = icmp eq ptr %4, null
  br i1 %tobool2.not.i, label %if.else.i15, label %do.body.i

if.else.i15:                                      ; preds = %land.lhs.true.i, %bdrv_get_cumulative_perm.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.196, ptr noundef nonnull @.str.2, i32 noundef 2257, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_perm) #31
  unreachable

do.body.i:                                        ; preds = %land.lhs.true.i
  %call.i13 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i13, label %do.end.i14, label %if.else4.i

if.else4.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2258, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_perm) #31
  unreachable

do.end.i14:                                       ; preds = %do.body.i
  %5 = load ptr, ptr %drv, align 8
  %bdrv_child_perm7.i = getelementptr inbounds %struct.BlockDriver, ptr %5, i64 0, i32 58
  %6 = load ptr, ptr %bdrv_child_perm7.i, align 8
  call void %6(ptr noundef nonnull %parent_bs, ptr noundef null, i32 noundef %child_role, ptr noundef null, i64 noundef %cumulative_perms.0.lcssa.i, i64 noundef %cumulative_shared_perms.0.lcssa.i, ptr noundef nonnull %perm, ptr noundef nonnull %shared_perm) #29
  %tobool8.not.i = icmp eq ptr %child_bs, null
  br i1 %tobool8.not.i, label %bdrv_child_perm.exit, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %do.end.i14
  %force_share.i = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 4
  %7 = load i8, ptr %force_share.i, align 1
  %8 = and i8 %7, 1
  %tobool10.not.i = icmp eq i8 %8, 0
  br i1 %tobool10.not.i, label %bdrv_child_perm.exit, label %if.then11.i

if.then11.i:                                      ; preds = %land.lhs.true9.i
  store i64 15, ptr %shared_perm, align 8
  br label %bdrv_child_perm.exit

bdrv_child_perm.exit:                             ; preds = %do.end.i14, %land.lhs.true9.i, %if.then11.i
  %9 = load i64, ptr %perm, align 8
  %10 = load i64, ptr %shared_perm, align 8
  %call9 = call fastcc ptr @bdrv_attach_child_common(ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, i64 noundef %9, i64 noundef %10, ptr noundef nonnull %parent_bs, ptr noundef %tran, ptr noundef %errp)
  br label %return

return:                                           ; preds = %bdrv_child_perm.exit, %if.then5
  %retval.0 = phi ptr [ null, %if.then5 ], [ %call9, %bdrv_child_perm.exit ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_root_unref_child(ptr noundef %child) local_unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %child, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3289, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_root_unref_child) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %child, ptr noundef null)
  tail call fastcc void @bdrv_child_free(ptr noundef nonnull %child)
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end5, label %bdrv_schedule_unref.exit

bdrv_schedule_unref.exit:                         ; preds = %do.end
  %call2 = tail call fastcc i32 @bdrv_refresh_perms(ptr noundef nonnull %0, ptr noundef null, ptr noundef null), !range !14
  %call3 = tail call ptr @qemu_get_aio_context() #29
  %call4 = tail call i32 @bdrv_try_change_aio_context(ptr noundef nonnull %0, ptr noundef %call3, ptr noundef null, ptr noundef null), !range !25
  %call.i = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_bh_schedule_oneshot_full(ptr noundef %call.i, ptr noundef nonnull @bdrv_schedule_unref_bh, ptr noundef nonnull %0, ptr noundef nonnull @.str.105) #29
  br label %if.end5

if.end5:                                          ; preds = %do.end, %bdrv_schedule_unref.exit
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @bdrv_replace_child_noperm(ptr noundef %child, ptr noundef %new_bs) unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %child, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 7
  %1 = load i8, ptr %frozen, align 8
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.203, ptr noundef nonnull @.str.2, i32 noundef 2919, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #31
  unreachable

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne ptr %new_bs, null
  br i1 %tobool1, label %lor.lhs.false, label %if.end5

lor.lhs.false:                                    ; preds = %if.end
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 8
  %3 = load i8, ptr %quiesced_parent, align 1
  %4 = and i8 %3, 1
  %tobool2.not = icmp eq i8 %4, 0
  br i1 %tobool2.not, label %if.else4, label %if.end5

if.else4:                                         ; preds = %lor.lhs.false
  tail call void @__assert_fail(ptr noundef nonnull @.str.204, ptr noundef nonnull @.str.2, i32 noundef 2941, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #31
  unreachable

if.end5:                                          ; preds = %if.end, %lor.lhs.false
  %cmp.not = icmp eq ptr %0, %new_bs
  br i1 %cmp.not, label %if.else7, label %do.body

if.else7:                                         ; preds = %if.end5
  tail call void @__assert_fail(ptr noundef nonnull @.str.205, ptr noundef nonnull @.str.2, i32 noundef 2942, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #31
  unreachable

do.body:                                          ; preds = %if.end5
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else10

if.else10:                                        ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2943, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #31
  unreachable

do.end:                                           ; preds = %do.body
  %tobool12 = icmp ne ptr %0, null
  %or.cond = and i1 %tobool1, %tobool12
  br i1 %or.cond, label %bdrv_get_aio_context.exit46, label %if.end21

bdrv_get_aio_context.exit46:                      ; preds = %do.end
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 8
  %5 = load ptr, ptr %aio_context.i, align 8
  %aio_context.i42 = getelementptr inbounds %struct.BlockDriverState, ptr %new_bs, i64 0, i32 8
  %6 = load ptr, ptr %aio_context.i42, align 8
  %cmp17 = icmp eq ptr %5, %6
  br i1 %cmp17, label %if.then23, label %if.else19

if.else19:                                        ; preds = %bdrv_get_aio_context.exit46
  tail call void @__assert_fail(ptr noundef nonnull @.str.206, ptr noundef nonnull @.str.2, i32 noundef 2946, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #31
  unreachable

if.end21:                                         ; preds = %do.end
  br i1 %tobool12, label %if.then23, label %if.end47

if.then23:                                        ; preds = %bdrv_get_aio_context.exit46, %if.end21
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 2
  %7 = load ptr, ptr %klass, align 8
  %detach = getelementptr inbounds %struct.BdrvChildClass, ptr %7, i64 0, i32 8
  %8 = load ptr, ptr %detach, align 8
  %tobool24.not = icmp eq ptr %8, null
  br i1 %tobool24.not, label %do.body29, label %if.then25

if.then25:                                        ; preds = %if.then23
  tail call void %8(ptr noundef nonnull %child) #29
  br label %do.body29

do.body29:                                        ; preds = %if.then23, %if.then25
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 10
  %9 = load ptr, ptr %next_parent, align 8
  %cmp30.not = icmp eq ptr %9, null
  %le_prev41.phi.trans.insert = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 10, i32 1
  %.pre47 = load ptr, ptr %le_prev41.phi.trans.insert, align 8
  br i1 %cmp30.not, label %if.end37, label %if.then31

if.then31:                                        ; preds = %do.body29
  %le_prev36 = getelementptr inbounds %struct.BdrvChild, ptr %9, i64 0, i32 10, i32 1
  store ptr %.pre47, ptr %le_prev36, align 8
  %.pre = load ptr, ptr %next_parent, align 8
  br label %if.end37

if.end37:                                         ; preds = %do.body29, %if.then31
  %10 = phi ptr [ %.pre, %if.then31 ], [ null, %do.body29 ]
  store ptr %10, ptr %.pre47, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %next_parent, i8 0, i64 16, i1 false)
  br label %if.end47

if.end47:                                         ; preds = %if.end37, %if.end21
  store ptr %new_bs, ptr %child, align 8
  br i1 %tobool1, label %do.body51, label %land.lhs.true79

do.body51:                                        ; preds = %if.end47
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %new_bs, i64 0, i32 32
  %11 = load ptr, ptr %parents, align 8
  %next_parent52 = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 10
  store ptr %11, ptr %next_parent52, align 8
  %cmp54.not = icmp eq ptr %11, null
  br i1 %cmp54.not, label %if.end62, label %if.then55

if.then55:                                        ; preds = %do.body51
  %le_prev61 = getelementptr inbounds %struct.BdrvChild, ptr %11, i64 0, i32 10, i32 1
  store ptr %next_parent52, ptr %le_prev61, align 8
  br label %if.end62

if.end62:                                         ; preds = %if.then55, %do.body51
  store ptr %child, ptr %parents, align 8
  %le_prev68 = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 10, i32 1
  store ptr %parents, ptr %le_prev68, align 8
  %klass70 = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 2
  %12 = load ptr, ptr %klass70, align 8
  %attach = getelementptr inbounds %struct.BdrvChildClass, ptr %12, i64 0, i32 7
  %13 = load ptr, ptr %attach, align 8
  %tobool71.not = icmp eq ptr %13, null
  br i1 %tobool71.not, label %cond.true, label %if.then72

if.then72:                                        ; preds = %if.end62
  tail call void %13(ptr noundef nonnull %child) #29
  br label %cond.true

cond.true:                                        ; preds = %if.then72, %if.end62
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %new_bs, i64 0, i32 46
  %14 = load i32, ptr %quiesce_counter, align 8
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %land.lhs.true79, label %if.end83

land.lhs.true79:                                  ; preds = %if.end47, %cond.true
  %quiesced_parent80 = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 8
  %16 = load i8, ptr %quiesced_parent80, align 1
  %17 = and i8 %16, 1
  %tobool81.not = icmp eq i8 %17, 0
  br i1 %tobool81.not, label %if.end83, label %if.then82

if.then82:                                        ; preds = %land.lhs.true79
  tail call void @bdrv_parent_drained_end_single(ptr noundef nonnull %child) #29
  br label %if.end83

if.end83:                                         ; preds = %if.then82, %land.lhs.true79, %cond.true
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @bdrv_child_free(ptr noundef %child) unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %child, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %do.body, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.207, ptr noundef nonnull @.str.2, i32 noundef 2984, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_free) #31
  unreachable

do.body:                                          ; preds = %entry
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else2

if.else2:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2985, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_free) #31
  unreachable

do.end:                                           ; preds = %do.body
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %le_prev = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 9, i32 1
  %1 = load ptr, ptr %le_prev, align 8
  %tobool5.not = icmp eq ptr %1, null
  br i1 %tobool5.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.else7

if.else7:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.208, ptr noundef nonnull @.str.2, i32 noundef 2988, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_free) #31
  unreachable

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %do.end
  %name = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 1
  %2 = load ptr, ptr %name, align 8
  tail call void @g_free(ptr noundef %2) #29
  tail call void @g_free(ptr noundef nonnull %child) #29
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_try_change_aio_context(ptr noundef %bs, ptr noundef %ctx, ptr noundef %ignore_child, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7831, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_try_change_aio_context) #31
  unreachable

do.end:                                           ; preds = %bdrv_get_aio_context.exit
  %call2 = tail call ptr @tran_new() #29
  %call3 = tail call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  %tobool.not = icmp eq ptr %ignore_child, null
  br i1 %tobool.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %do.end
  %call5 = tail call i32 @g_hash_table_add(ptr noundef %call3, ptr noundef nonnull %ignore_child) #29
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %do.end
  %call7 = tail call fastcc zeroext i1 @bdrv_change_aio_context(ptr noundef %bs, ptr noundef %ctx, ptr noundef %call3, ptr noundef %call2, ptr noundef %errp)
  tail call void @g_hash_table_destroy(ptr noundef %call3) #29
  br i1 %call7, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  tail call void @tran_abort(ptr noundef %call2) #29
  br label %return

if.end10:                                         ; preds = %if.end6
  %call11 = tail call ptr @qemu_get_aio_context() #29
  %cmp.not = icmp eq ptr %call11, %cond.i
  br i1 %cmp.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %call15 = tail call ptr @qemu_get_aio_context() #29
  %cmp16.not = icmp eq ptr %call15, %ctx
  br i1 %cmp16.not, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end14
  tail call void @aio_context_acquire(ptr noundef %ctx) #29
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end14
  tail call void @tran_commit(ptr noundef %call2) #29
  %call20 = tail call ptr @qemu_get_aio_context() #29
  %cmp21.not = icmp eq ptr %call20, %ctx
  br i1 %cmp21.not, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end19
  tail call void @aio_context_release(ptr noundef %ctx) #29
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end19
  %call25 = tail call ptr @qemu_get_aio_context() #29
  %cmp26.not = icmp eq ptr %call25, %cond.i
  br i1 %cmp26.not, label %return, label %if.then28

if.then28:                                        ; preds = %if.end24
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  br label %return

return:                                           ; preds = %if.end24, %if.then28, %if.then9
  %retval.0 = phi i32 [ -1, %if.then9 ], [ 0, %if.then28 ], [ 0, %if.end24 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_unref_child(ptr noundef %parent, ptr noundef %child) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3382, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unref_child) #31
  unreachable

do.end:                                           ; preds = %entry
  %cmp = icmp eq ptr %child, null
  br i1 %cmp, label %return, label %if.end2

if.end2:                                          ; preds = %do.end
  tail call fastcc void @bdrv_unset_inherits_from(ptr noundef %parent, ptr noundef nonnull %child, ptr noundef null)
  tail call void @bdrv_root_unref_child(ptr noundef nonnull %child)
  br label %return

return:                                           ; preds = %do.end, %if.end2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @bdrv_unset_inherits_from(ptr noundef %root, ptr noundef readonly %child, ptr noundef %tran) unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %child, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 28
  %1 = load ptr, ptr %inherits_from, align 8
  %cmp = icmp eq ptr %1, %root
  br i1 %cmp, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %root, i64 0, i32 29
  %c.015 = load ptr, ptr %children, align 8
  %cond16 = icmp eq ptr %c.015, null
  br i1 %cond16, label %if.then7, label %for.body

for.body:                                         ; preds = %if.then, %for.inc
  %c.017 = phi ptr [ %c.0, %for.inc ], [ %c.015, %if.then ]
  %cmp1.not = icmp eq ptr %c.017, %child
  br i1 %cmp1.not, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %2 = load ptr, ptr %c.017, align 8
  %cmp4 = icmp eq ptr %2, %0
  br i1 %cmp4, label %if.end10, label %for.inc

for.inc:                                          ; preds = %for.body, %land.lhs.true
  %next = getelementptr inbounds %struct.BdrvChild, ptr %c.017, i64 0, i32 9
  %c.0 = load ptr, ptr %next, align 8
  %cond = icmp eq ptr %c.0, null
  br i1 %cond, label %if.then7, label %for.body, !llvm.loop !26

if.then7:                                         ; preds = %for.inc, %if.then
  %tobool.not.i = icmp eq ptr %tran, null
  br i1 %tobool.not.i, label %bdrv_set_inherits_from.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then7
  %call.i = tail call noalias dereferenceable_or_null(16) ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #32
  %3 = load ptr, ptr %inherits_from, align 8
  store ptr %0, ptr %call.i, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %call.i, i64 8
  store ptr %3, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 8
  tail call void @tran_add(ptr noundef nonnull %tran, ptr noundef nonnull @bdrv_set_inherits_from_drv, ptr noundef nonnull %call.i) #29
  br label %bdrv_set_inherits_from.exit

bdrv_set_inherits_from.exit:                      ; preds = %if.then7, %if.then.i
  store ptr null, ptr %inherits_from, align 8
  %.pre = load ptr, ptr %child, align 8
  br label %if.end10

if.end10:                                         ; preds = %land.lhs.true, %bdrv_set_inherits_from.exit, %entry
  %4 = phi ptr [ %.pre, %bdrv_set_inherits_from.exit ], [ %0, %entry ], [ %0, %land.lhs.true ]
  %children12 = getelementptr inbounds %struct.BlockDriverState, ptr %4, i64 0, i32 29
  %c.118 = load ptr, ptr %children12, align 8
  %tobool15.not19 = icmp eq ptr %c.118, null
  br i1 %tobool15.not19, label %for.end20, label %for.body16

for.body16:                                       ; preds = %if.end10, %for.body16
  %c.120 = phi ptr [ %c.1, %for.body16 ], [ %c.118, %if.end10 ]
  tail call fastcc void @bdrv_unset_inherits_from(ptr noundef %root, ptr noundef nonnull %c.120, ptr noundef %tran)
  %next18 = getelementptr inbounds %struct.BdrvChild, ptr %c.120, i64 0, i32 9
  %c.1 = load ptr, ptr %next18, align 8
  %tobool15.not = icmp eq ptr %c.1, null
  br i1 %tobool15.not, label %for.end20, label %for.body16, !llvm.loop !27

for.end20:                                        ; preds = %for.body16, %if.end10
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_set_backing_hd_drained(ptr noundef %bs, ptr noundef %backing_hd, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @tran_new() #29
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3548, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained) #31
  unreachable

do.end:                                           ; preds = %entry
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 46
  %0 = load i32, ptr %quiesce_counter, align 8
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.end4, label %if.else3

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.74, ptr noundef nonnull @.str.2, i32 noundef 3549, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained) #31
  unreachable

if.end4:                                          ; preds = %do.end
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %1 = load ptr, ptr %backing, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end13, label %if.then5

if.then5:                                         ; preds = %if.end4
  %2 = load ptr, ptr %1, align 8
  %quiesce_counter8 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i64 0, i32 46
  %3 = load i32, ptr %quiesce_counter8, align 8
  %cmp9 = icmp sgt i32 %3, 0
  br i1 %cmp9, label %if.end13, label %if.else11

if.else11:                                        ; preds = %if.then5
  tail call void @__assert_fail(ptr noundef nonnull @.str.75, ptr noundef nonnull @.str.2, i32 noundef 3551, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained) #31
  unreachable

if.end13:                                         ; preds = %if.then5, %if.end4
  %call14 = tail call fastcc i32 @bdrv_set_file_or_backing_noperm(ptr noundef nonnull %bs, ptr noundef %backing_hd, i1 noundef zeroext true, ptr noundef %call, ptr noundef %errp), !range !28
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %if.then.i, label %out

out:                                              ; preds = %if.end13
  %call18 = tail call fastcc i32 @bdrv_refresh_perms(ptr noundef nonnull %bs, ptr noundef %call, ptr noundef %errp), !range !14
  %cmp.i = icmp slt i32 %call18, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.end13, %out
  %ret.013 = phi i32 [ %call18, %out ], [ %call14, %if.end13 ]
  tail call void @tran_abort(ptr noundef %call) #29
  br label %tran_finalize.exit

if.else.i:                                        ; preds = %out
  tail call void @tran_commit(ptr noundef %call) #29
  br label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %if.then.i, %if.else.i
  %ret.012 = phi i32 [ %ret.013, %if.then.i ], [ 0, %if.else.i ]
  ret i32 %ret.012
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_set_file_or_backing_noperm(ptr noundef %parent_bs, ptr noundef %child_bs, i1 noundef zeroext %is_backing, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %tobool4.i = icmp ne ptr %child_bs, null
  %cmp5.i = icmp ne ptr %child_bs, %parent_bs
  %0 = and i1 %tobool4.i, %cmp5.i
  br i1 %0, label %while.body.i, label %bdrv_inherits_from_recursive.exit

while.body.i:                                     ; preds = %entry, %while.body.i
  %child.addr.06.i = phi ptr [ %1, %while.body.i ], [ %child_bs, %entry ]
  %inherits_from.i = getelementptr inbounds %struct.BlockDriverState, ptr %child.addr.06.i, i64 0, i32 28
  %1 = load ptr, ptr %inherits_from.i, align 8
  %tobool.i = icmp ne ptr %1, null
  %cmp.i = icmp ne ptr %1, %parent_bs
  %2 = and i1 %tobool.i, %cmp.i
  br i1 %2, label %while.body.i, label %bdrv_inherits_from_recursive.exit, !llvm.loop !29

bdrv_inherits_from_recursive.exit:                ; preds = %while.body.i, %entry
  %tobool.lcssa.i = phi i1 [ %tobool4.i, %entry ], [ %tobool.i, %while.body.i ]
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 30
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 31
  %cond.in = select i1 %is_backing, ptr %backing, ptr %file
  %cond = load ptr, ptr %cond.in, align 8
  %call2 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call2, label %do.end, label %if.else

if.else:                                          ; preds = %bdrv_inherits_from_recursive.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3457, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_set_file_or_backing_noperm) #31
  unreachable

do.end:                                           ; preds = %bdrv_inherits_from_recursive.exit
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 6
  %3 = load ptr, ptr %drv, align 8
  %tobool3.not = icmp eq ptr %3, null
  br i1 %tobool3.not, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.end
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3465, ptr noundef nonnull @__func__.bdrv_set_file_or_backing_noperm, ptr noundef nonnull @.str.209) #29
  br label %return

if.end5:                                          ; preds = %do.end
  %tobool6.not = icmp eq ptr %cond, null
  br i1 %tobool6.not, label %if.end11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end5
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %cond, i64 0, i32 7
  %4 = load i8, ptr %frozen, align 8
  %5 = and i8 %4, 1
  %tobool7.not = icmp eq i8 %5, 0
  br i1 %tobool7.not, label %if.end11, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  %name = getelementptr inbounds %struct.BdrvChild, ptr %cond, i64 0, i32 1
  %6 = load ptr, ptr %name, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  %7 = load ptr, ptr %cond, align 8
  %node_name9 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3471, ptr noundef nonnull @__func__.bdrv_set_file_or_backing_noperm, ptr noundef nonnull @.str.210, ptr noundef %6, ptr noundef nonnull %node_name, ptr noundef nonnull %node_name9) #29
  br label %return

if.end11:                                         ; preds = %land.lhs.true, %if.end5
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %3, i64 0, i32 2
  %8 = load i8, ptr %is_filter, align 4
  %9 = and i8 %8, 1
  %tobool15.not = icmp eq i8 %9, 0
  br i1 %is_backing, label %land.lhs.true13, label %if.end23

land.lhs.true13:                                  ; preds = %if.end11
  br i1 %tobool15.not, label %land.lhs.true16, label %if.end37

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %3, i64 0, i32 7
  %10 = load i8, ptr %supports_backing, align 1
  %11 = and i8 %10, 1
  %tobool18.not = icmp eq i8 %11, 0
  br i1 %tobool18.not, label %if.then19, label %if.end37

if.then19:                                        ; preds = %land.lhs.true16
  %12 = load ptr, ptr %3, align 8
  %node_name21 = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3479, ptr noundef nonnull @__func__.bdrv_set_file_or_backing_noperm, ptr noundef nonnull @.str.211, ptr noundef %12, ptr noundef nonnull %node_name21) #29
  br label %return

if.end23:                                         ; preds = %if.end11
  br i1 %tobool15.not, label %if.else31, label %if.end37

if.else31:                                        ; preds = %if.end23
  br i1 %tobool6.not, label %if.then33, label %if.end37.thread

if.then33:                                        ; preds = %if.else31
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3494, ptr noundef nonnull @__func__.bdrv_set_file_or_backing_noperm, ptr noundef nonnull @.str.212) #29
  br label %return

if.end37.thread:                                  ; preds = %if.else31
  %role35 = getelementptr inbounds %struct.BdrvChild, ptr %cond, i64 0, i32 3
  %13 = load i32, ptr %role35, align 8
  br label %if.then39

if.end37:                                         ; preds = %land.lhs.true13, %land.lhs.true16, %if.end23
  %role.0 = phi i32 [ 20, %if.end23 ], [ 8, %land.lhs.true16 ], [ 20, %land.lhs.true13 ]
  br i1 %tobool6.not, label %if.end45, label %if.then39

if.then39:                                        ; preds = %if.end37.thread, %if.end37
  %role.045 = phi i32 [ %13, %if.end37.thread ], [ %role.0, %if.end37 ]
  %14 = load ptr, ptr %cond, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %14, i64 0, i32 46
  %15 = load i32, ptr %quiesce_counter, align 8
  %tobool41.not = icmp eq i32 %15, 0
  br i1 %tobool41.not, label %if.else43, label %if.end44

if.else43:                                        ; preds = %if.then39
  tail call void @__assert_fail(ptr noundef nonnull @.str.213, ptr noundef nonnull @.str.2, i32 noundef 3501, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_set_file_or_backing_noperm) #31
  unreachable

if.end44:                                         ; preds = %if.then39
  tail call fastcc void @bdrv_unset_inherits_from(ptr noundef nonnull %parent_bs, ptr noundef nonnull %cond, ptr noundef %tran)
  tail call fastcc void @bdrv_remove_child(ptr noundef nonnull %cond, ptr noundef %tran)
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end37
  %role.046 = phi i32 [ %role.045, %if.end44 ], [ %role.0, %if.end37 ]
  %tobool46.not = icmp eq ptr %child_bs, null
  br i1 %tobool46.not, label %out, label %if.end48

if.end48:                                         ; preds = %if.end45
  %cond50 = select i1 %is_backing, ptr @.str.89, ptr @.str.214
  %call51 = tail call fastcc ptr @bdrv_attach_child_noperm(ptr noundef nonnull %parent_bs, ptr noundef nonnull %child_bs, ptr noundef nonnull %cond50, ptr noundef nonnull @child_of_bds, i32 noundef %role.046, ptr noundef %tran, ptr noundef %errp)
  %tobool52.not = icmp eq ptr %call51, null
  br i1 %tobool52.not, label %return, label %if.end54

if.end54:                                         ; preds = %if.end48
  br i1 %tobool.lcssa.i, label %if.then56, label %out

if.then56:                                        ; preds = %if.end54
  %tobool.not.i = icmp eq ptr %tran, null
  br i1 %tobool.not.i, label %bdrv_set_inherits_from.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then56
  %call.i = tail call noalias dereferenceable_or_null(16) ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #32
  %inherits_from.i38 = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 28
  %16 = load ptr, ptr %inherits_from.i38, align 8
  store ptr %child_bs, ptr %call.i, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %call.i, i64 8
  store ptr %16, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 8
  tail call void @tran_add(ptr noundef nonnull %tran, ptr noundef nonnull @bdrv_set_inherits_from_drv, ptr noundef nonnull %call.i) #29
  br label %bdrv_set_inherits_from.exit

bdrv_set_inherits_from.exit:                      ; preds = %if.then56, %if.then.i
  %inherits_from2.i = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 28
  store ptr %parent_bs, ptr %inherits_from2.i, align 8
  br label %out

out:                                              ; preds = %if.end54, %bdrv_set_inherits_from.exit, %if.end45
  tail call void @bdrv_refresh_limits(ptr noundef nonnull %parent_bs, ptr noundef %tran, ptr noundef null) #29
  br label %return

return:                                           ; preds = %if.end48, %out, %if.then33, %if.then19, %if.then8, %if.then4
  %retval.0 = phi i32 [ -1, %if.then8 ], [ 0, %out ], [ -22, %if.then33 ], [ -22, %if.then19 ], [ -22, %if.then4 ], [ -22, %if.end48 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_set_backing_hd(ptr noundef %bs, ptr noundef %backing_hd, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3570, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_set_backing_hd) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %0 = load ptr, ptr %backing, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %do.end
  %1 = load ptr, ptr %0, align 8
  br label %cond.end

cond.end:                                         ; preds = %do.end, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ %bs, %do.end ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_ref.exit, label %if.else.i

if.else.i:                                        ; preds = %cond.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %cond.end
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %cond, i64 0, i32 26
  %2 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %2, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  tail call void @bdrv_drained_begin(ptr noundef %cond) #29
  tail call void @bdrv_graph_wrlock(ptr noundef %backing_hd) #29
  %call3 = tail call i32 @bdrv_set_backing_hd_drained(ptr noundef nonnull %bs, ptr noundef %backing_hd, ptr noundef %errp), !range !14
  tail call void @bdrv_graph_wrunlock(ptr noundef %backing_hd) #29
  tail call void @bdrv_drained_end(ptr noundef %cond) #29
  tail call void @bdrv_unref(ptr noundef %cond)
  ret i32 %call3
}

declare void @bdrv_graph_rdlock_main_loop() local_unnamed_addr #5

declare void @bdrv_graph_rdunlock_main_loop() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_ref(ptr nocapture noundef %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

do.end:                                           ; preds = %entry
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 26
  %0 = load i32, ptr %refcnt, align 8
  %inc = add i32 %0, 1
  store i32 %inc, ptr %refcnt, align 8
  ret void
}

declare void @bdrv_graph_wrlock(ptr noundef) #5

declare void @bdrv_graph_wrunlock(ptr noundef) #5

declare void @bdrv_drained_end(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_open_backing_file(ptr noundef %bs, ptr noundef %parent_options, ptr noundef %bdref_key, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %options = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3613, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_backing_file) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %0 = load ptr, ptr %backing, align 8
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %if.end3, label %free_exit.thread

free_exit.thread:                                 ; preds = %do.end
  tail call void @g_free(ptr noundef null) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end3:                                          ; preds = %do.end
  %cmp4 = icmp eq ptr %parent_options, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %call6 = tail call ptr @qdict_new() #29
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %tmp_parent_options.0 = phi ptr [ %call6, %if.then5 ], [ null, %if.end3 ]
  %parent_options.addr.0 = phi ptr [ %call6, %if.then5 ], [ %parent_options, %if.end3 ]
  %1 = load i32, ptr %bs, align 8
  %and = and i32 %1, -257
  store i32 %and, ptr %bs, align 8
  %call8 = tail call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef nonnull @.str.76, ptr noundef %bdref_key) #29
  call void @qdict_extract_subqdict(ptr noundef %parent_options.addr.0, ptr noundef nonnull %options, ptr noundef %call8) #29
  call void @g_free(ptr noundef %call8) #29
  %call9 = call ptr @qdict_get_try_str(ptr noundef %parent_options.addr.0, ptr noundef %bdref_key) #29
  %tobool.not = icmp eq ptr %call9, null
  br i1 %tobool.not, label %lor.lhs.false, label %if.end47

lor.lhs.false:                                    ; preds = %if.end7
  %2 = load ptr, ptr %options, align 8
  %call10 = call i32 @qdict_haskey(ptr noundef %2, ptr noundef nonnull @.str.77) #29
  %tobool11.not = icmp eq i32 %call10, 0
  br i1 %tobool11.not, label %if.else13, label %if.end47

if.else13:                                        ; preds = %lor.lhs.false
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 12
  %3 = load i8, ptr %backing_file, align 1
  %cmp14 = icmp eq i8 %3, 0
  br i1 %cmp14, label %land.lhs.true, label %if.else22

land.lhs.true:                                    ; preds = %if.else13
  %4 = load ptr, ptr %options, align 8
  %call16 = call i64 @qdict_size(ptr noundef %4) #29
  %cmp17 = icmp eq i64 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.else22

if.then19:                                        ; preds = %land.lhs.true
  %5 = load ptr, ptr %options, align 8
  call fastcc void @qobject_unref_impl(ptr noundef %5)
  br label %free_exit

if.else22:                                        ; preds = %land.lhs.true, %if.else13
  %6 = load ptr, ptr %options, align 8
  %call23 = call i64 @qdict_size(ptr noundef %6) #29
  %cmp24 = icmp eq i64 %call23, 0
  br i1 %cmp24, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.else22
  %auto_backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 13
  %call29 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %auto_backing_file, ptr noundef nonnull dereferenceable(1) %backing_file) #28
  %tobool30.not = icmp eq i32 %call29, 0
  br label %if.end31

if.end31:                                         ; preds = %if.then26, %if.else22
  %implicit_backing.0 = phi i1 [ %tobool30.not, %if.then26 ], [ false, %if.else22 ]
  %call32 = call ptr @bdrv_get_full_backing_filename(ptr noundef nonnull %bs, ptr noundef nonnull %local_err)
  %7 = load ptr, ptr %local_err, align 8
  %tobool33.not = icmp eq ptr %7, null
  br i1 %tobool33.not, label %if.end47, label %if.then34

if.then34:                                        ; preds = %if.end31
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %7) #29
  %8 = load ptr, ptr %options, align 8
  %tobool36.not = icmp eq ptr %8, null
  br i1 %tobool36.not, label %free_exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.then34
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %8, i64 0, i32 1
  %9 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %9, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %9, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %free_exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  call void @qobject_destroy(ptr noundef nonnull %8) #29
  br label %free_exit

if.end47:                                         ; preds = %if.end31, %if.end7, %lor.lhs.false
  %implicit_backing.1 = phi i1 [ false, %if.end7 ], [ false, %lor.lhs.false ], [ %implicit_backing.0, %if.end31 ]
  %backing_filename.0 = phi ptr [ null, %if.end7 ], [ null, %lor.lhs.false ], [ %call32, %if.end31 ]
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %10 = load ptr, ptr %drv, align 8
  %tobool48.not = icmp eq ptr %10, null
  br i1 %tobool48.not, label %if.then52, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %if.end47
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %10, i64 0, i32 7
  %11 = load i8, ptr %supports_backing, align 1
  %12 = and i8 %11, 1
  %tobool51.not = icmp eq i8 %12, 0
  br i1 %tobool51.not, label %if.then52, label %if.end63

if.then52:                                        ; preds = %lor.lhs.false49, %if.end47
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3667, ptr noundef nonnull @__func__.bdrv_open_backing_file, ptr noundef nonnull @.str.78) #29
  %13 = load ptr, ptr %options, align 8
  %tobool54.not = icmp eq ptr %13, null
  br i1 %tobool54.not, label %free_exit, label %lor.lhs.false.i47

lor.lhs.false.i47:                                ; preds = %if.then52
  %refcnt.i48 = getelementptr inbounds %struct.QObjectBase_, ptr %13, i64 0, i32 1
  %14 = load i64, ptr %refcnt.i48, align 8
  %tobool1.not.i49 = icmp eq i64 %14, 0
  br i1 %tobool1.not.i49, label %if.else.i54, label %land.lhs.true.i50

if.else.i54:                                      ; preds = %lor.lhs.false.i47
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i50:                                ; preds = %lor.lhs.false.i47
  %dec.i51 = add i64 %14, -1
  store i64 %dec.i51, ptr %refcnt.i48, align 8
  %cmp.i52 = icmp eq i64 %dec.i51, 0
  br i1 %cmp.i52, label %if.then5.i53, label %free_exit

if.then5.i53:                                     ; preds = %land.lhs.true.i50
  call void @qobject_destroy(ptr noundef nonnull %13) #29
  br label %free_exit

if.end63:                                         ; preds = %lor.lhs.false49
  br i1 %tobool.not, label %land.lhs.true65, label %if.end76

land.lhs.true65:                                  ; preds = %if.end63
  %backing_format = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 14
  %15 = load i8, ptr %backing_format, align 1
  %cmp68.not = icmp eq i8 %15, 0
  br i1 %cmp68.not, label %if.end76, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %land.lhs.true65
  %16 = load ptr, ptr %options, align 8
  %call71 = call i32 @qdict_haskey(ptr noundef %16, ptr noundef nonnull @.str.20) #29
  %tobool72.not = icmp eq i32 %call71, 0
  br i1 %tobool72.not, label %if.then73, label %if.end76

if.then73:                                        ; preds = %land.lhs.true70
  %17 = load ptr, ptr %options, align 8
  call void @qdict_put_str(ptr noundef %17, ptr noundef nonnull @.str.20, ptr noundef nonnull %backing_format) #29
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %land.lhs.true70, %land.lhs.true65, %if.end63
  %18 = load ptr, ptr %options, align 8
  %bs.val = load ptr, ptr %drv, align 8
  %tobool.not.i = icmp eq ptr %bs.val, null
  br i1 %tobool.not.i, label %if.else.i57, label %land.lhs.true.i56

land.lhs.true.i56:                                ; preds = %if.end76
  %is_filter.i = getelementptr inbounds %struct.BlockDriver, ptr %bs.val, i64 0, i32 2
  %19 = load i8, ptr %is_filter.i, align 4
  %20 = and i8 %19, 1
  %tobool2.not.i = icmp eq i8 %20, 0
  br i1 %tobool2.not.i, label %if.else.i57, label %bdrv_backing_role.exit

if.else.i57:                                      ; preds = %land.lhs.true.i56, %if.end76
  br label %bdrv_backing_role.exit

bdrv_backing_role.exit:                           ; preds = %land.lhs.true.i56, %if.else.i57
  %retval.0.i = phi i32 [ 8, %if.else.i57 ], [ 20, %land.lhs.true.i56 ]
  %call78 = call ptr @bdrv_open_inherit(ptr noundef %backing_filename.0, ptr noundef %call9, ptr noundef %18, i32 noundef 0, ptr noundef nonnull %bs, ptr noundef nonnull @child_of_bds, i32 noundef %retval.0.i, ptr noundef %errp)
  %tobool79.not = icmp eq ptr %call78, null
  br i1 %tobool79.not, label %if.then80, label %if.end82

if.then80:                                        ; preds = %bdrv_backing_role.exit
  %21 = load i32, ptr %bs, align 8
  %or = or i32 %21, 256
  store i32 %or, ptr %bs, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %errp, ptr noundef nonnull @.str.79) #29
  br label %free_exit

if.end82:                                         ; preds = %bdrv_backing_role.exit
  br i1 %implicit_backing.1, label %if.then84, label %bdrv_get_aio_context.exit

if.then84:                                        ; preds = %if.end82
  call void @bdrv_refresh_filename(ptr noundef nonnull %call78)
  %auto_backing_file85 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 13
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %call78, i64 0, i32 11
  call void @pstrcpy(ptr noundef nonnull %auto_backing_file85, i32 noundef 4096, ptr noundef nonnull %filename) #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %if.then84, %if.end82
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %call78, i64 0, i32 8
  %22 = load ptr, ptr %aio_context.i, align 8
  call void @aio_context_acquire(ptr noundef %22) #29
  %call90 = call i32 @bdrv_set_backing_hd(ptr noundef nonnull %bs, ptr noundef nonnull %call78, ptr noundef %errp), !range !14
  call void @bdrv_unref(ptr noundef nonnull %call78)
  call void @aio_context_release(ptr noundef %22) #29
  %cmp91 = icmp slt i32 %call90, 0
  br i1 %cmp91, label %free_exit, label %if.end94

if.end94:                                         ; preds = %bdrv_get_aio_context.exit
  call void @qdict_del(ptr noundef %parent_options.addr.0, ptr noundef %bdref_key) #29
  br label %free_exit

free_exit:                                        ; preds = %if.then5.i53, %land.lhs.true.i50, %if.then52, %if.then5.i, %land.lhs.true.i, %if.then34, %bdrv_get_aio_context.exit, %if.end94, %if.then80, %if.then19
  %ret.0 = phi i32 [ %call90, %bdrv_get_aio_context.exit ], [ 0, %if.end94 ], [ -22, %if.then80 ], [ 0, %if.then19 ], [ -22, %if.then34 ], [ -22, %land.lhs.true.i ], [ -22, %if.then5.i ], [ -22, %if.then52 ], [ -22, %land.lhs.true.i50 ], [ -22, %if.then5.i53 ]
  %backing_filename.1 = phi ptr [ %backing_filename.0, %bdrv_get_aio_context.exit ], [ %backing_filename.0, %if.end94 ], [ %backing_filename.0, %if.then80 ], [ null, %if.then19 ], [ %call32, %if.then34 ], [ %call32, %land.lhs.true.i ], [ %call32, %if.then5.i ], [ %backing_filename.0, %if.then52 ], [ %backing_filename.0, %land.lhs.true.i50 ], [ %backing_filename.0, %if.then5.i53 ]
  call void @g_free(ptr noundef %backing_filename.1) #29
  %tobool96.not = icmp eq ptr %tmp_parent_options.0, null
  br i1 %tobool96.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %lor.lhs.false.i59

lor.lhs.false.i59:                                ; preds = %free_exit
  %refcnt.i60 = getelementptr inbounds %struct.QObjectBase_, ptr %tmp_parent_options.0, i64 0, i32 1
  %23 = load i64, ptr %refcnt.i60, align 8
  %tobool1.not.i61 = icmp eq i64 %23, 0
  br i1 %tobool1.not.i61, label %if.else.i66, label %land.lhs.true.i62

if.else.i66:                                      ; preds = %lor.lhs.false.i59
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i62:                                ; preds = %lor.lhs.false.i59
  %dec.i63 = add i64 %23, -1
  store i64 %dec.i63, ptr %refcnt.i60, align 8
  %cmp.i64 = icmp eq i64 %dec.i63, 0
  br i1 %cmp.i64, label %if.then5.i65, label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.then5.i65:                                     ; preds = %land.lhs.true.i62
  call void @qobject_destroy(ptr noundef nonnull %tmp_parent_options.0) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %free_exit.thread, %free_exit, %land.lhs.true.i62, %if.then5.i65
  %ret.072 = phi i32 [ 0, %free_exit.thread ], [ %ret.0, %free_exit ], [ %ret.0, %land.lhs.true.i62 ], [ %ret.0, %if.then5.i65 ]
  call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %ret.072
}

declare void @qdict_extract_subqdict(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qdict_get_try_str(ptr noundef, ptr noundef) local_unnamed_addr #5

declare i32 @qdict_haskey(ptr noundef, ptr noundef) local_unnamed_addr #5

declare i64 @qdict_size(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_open_inherit(ptr noundef %filename, ptr noundef %reference, ptr noundef %options, i32 noundef %flags, ptr noundef %parent, ptr noundef readonly %child_class, i32 noundef %child_role, ptr noundef %errp) #4 {
entry:
  %_now.i.i.i = alloca %struct.timeval, align 8
  %local_err.i155 = alloca ptr, align 8
  %buf.i = alloca [512 x i8], align 16
  %local_err.i112 = alloca ptr, align 8
  %filename.addr.i.i = alloca ptr, align 8
  %local_err.i = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %local_err = alloca ptr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr null, ptr %local_err, align 8
  %call = tail call ptr @qemu_get_aio_context() #29
  %tobool = icmp ne ptr %child_class, null
  %tobool1 = icmp ne i32 %flags, 0
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.219, ptr noundef nonnull @.str.2, i32 noundef 3979, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

if.end:                                           ; preds = %entry
  %0 = icmp eq ptr %parent, null
  %cmp = xor i1 %0, %tobool
  br i1 %cmp, label %do.body, label %if.else7

if.else7:                                         ; preds = %if.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.220, ptr noundef nonnull @.str.2, i32 noundef 3980, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

do.body:                                          ; preds = %if.end
  %call9 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call9, label %do.end, label %if.else11

if.else11:                                        ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3981, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

do.end:                                           ; preds = %do.body
  %call13 = tail call zeroext i1 @qemu_in_coroutine() #29
  br i1 %call13, label %if.else15, label %if.end16

if.else15:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.221, ptr noundef nonnull @.str.2, i32 noundef 3982, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

if.end16:                                         ; preds = %do.end
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %tobool18.not = icmp eq ptr %reference, null
  br i1 %tobool18.not, label %if.end38, label %if.then19

if.then19:                                        ; preds = %if.end16
  %tobool20.not = icmp eq ptr %options, null
  br i1 %tobool20.not, label %qobject_unref_impl.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.then19
  %call21 = tail call i64 @qdict_size(ptr noundef nonnull %options) #29
  %1 = icmp eq i64 %call21, 0
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %options, i64 0, i32 1
  %2 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %2, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %2, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %qobject_unref_impl.exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  tail call void @qobject_destroy(ptr noundef nonnull %options) #29
  br label %qobject_unref_impl.exit

qobject_unref_impl.exit:                          ; preds = %if.then19, %land.lhs.true.i, %if.then5.i
  %cond283 = phi i1 [ %1, %land.lhs.true.i ], [ %1, %if.then5.i ], [ true, %if.then19 ]
  %tobool29.not = icmp eq ptr %filename, null
  %brmerge.not = select i1 %tobool29.not, i1 %cond283, i1 false
  br i1 %brmerge.not, label %if.end33, label %if.then32

if.then32:                                        ; preds = %qobject_unref_impl.exit
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3993, ptr noundef nonnull @__func__.bdrv_open_inherit, ptr noundef nonnull @.str.222) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end33:                                         ; preds = %qobject_unref_impl.exit
  %call34 = tail call ptr @bdrv_lookup_bs(ptr noundef nonnull %reference, ptr noundef nonnull %reference, ptr noundef %errp)
  %tobool35.not = icmp eq ptr %call34, null
  br i1 %tobool35.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.end37

if.end37:                                         ; preds = %if.end33
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_ref.exit, label %if.else.i107

if.else.i107:                                     ; preds = %if.end37
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %if.end37
  %refcnt.i108 = getelementptr inbounds %struct.BlockDriverState, ptr %call34, i64 0, i32 26
  %3 = load i32, ptr %refcnt.i108, align 8
  %inc.i = add i32 %3, 1
  store i32 %inc.i, ptr %refcnt.i108, align 8
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end38:                                         ; preds = %if.end16
  %call39 = tail call ptr @bdrv_new()
  %cmp40 = icmp eq ptr %options, null
  br i1 %cmp40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end38
  %call42 = tail call ptr @qdict_new() #29
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end38
  %options.addr.0 = phi ptr [ %call42, %if.then41 ], [ %options, %if.end38 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %local_err.i)
  store ptr null, ptr %local_err.i, align 8
  %call.i109 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i109, label %do.end.i, label %if.else.i110

if.else.i110:                                     ; preds = %if.end43
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2023, ptr noundef nonnull @__PRETTY_FUNCTION__.parse_json_protocol) #31
  unreachable

do.end.i:                                         ; preds = %if.end43
  %tobool.not.i = icmp eq ptr %filename, null
  br i1 %tobool.not.i, label %parse_json_protocol.exit, label %lor.lhs.false.i111

lor.lhs.false.i111:                               ; preds = %do.end.i
  %call1.i = tail call i32 @g_str_has_prefix(ptr noundef nonnull %filename, ptr noundef nonnull @.str.8) #29
  %tobool2.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool2.not.i, label %parse_json_protocol.exit, label %if.end4.i

if.end4.i:                                        ; preds = %lor.lhs.false.i111
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %filename.addr.i.i)
  store ptr %filename, ptr %filename.addr.i.i, align 8
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %do.end.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.end4.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1995, ptr noundef nonnull @__PRETTY_FUNCTION__.parse_json_filename) #31
  unreachable

do.end.i.i:                                       ; preds = %if.end4.i
  %call1.i.i = call i32 @strstart(ptr noundef nonnull %filename, ptr noundef nonnull @.str.8, ptr noundef nonnull %filename.addr.i.i) #29
  %tobool.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i, label %if.else3.i.i, label %if.end4.i.i

if.else3.i.i:                                     ; preds = %do.end.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.230, ptr noundef nonnull @.str.2, i32 noundef 1998, ptr noundef nonnull @__PRETTY_FUNCTION__.parse_json_filename) #31
  unreachable

if.end4.i.i:                                      ; preds = %do.end.i.i
  %4 = load ptr, ptr %filename.addr.i.i, align 8
  %call5.i.i = call ptr @qobject_from_json(ptr noundef %4, ptr noundef nonnull %local_err.i) #29
  %tobool6.not.i.i = icmp eq ptr %call5.i.i, null
  br i1 %tobool6.not.i.i, label %if.then7.i.i, label %land.lhs.true.i.i.i

if.then7.i.i:                                     ; preds = %if.end4.i.i
  call void (ptr, ptr, ...) @error_prepend(ptr noundef nonnull %local_err.i, ptr noundef nonnull @.str.231) #29
  br label %parse_json_filename.exit.i

land.lhs.true.i.i.i:                              ; preds = %if.end4.i.i
  %obj.val.i.i.i = load i32, ptr %call5.i.i, align 8
  %5 = add i32 %obj.val.i.i.i, -1
  %or.cond.i.i.i.i = icmp ult i32 %5, 6
  br i1 %or.cond.i.i.i.i, label %qobject_type.exit.i.i.i, label %if.else.i.i.i.i

if.else.i.i.i.i:                                  ; preds = %land.lhs.true.i.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.218, ptr noundef nonnull @.str.161, i32 noundef 126, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_type) #31
  unreachable

qobject_type.exit.i.i.i:                          ; preds = %land.lhs.true.i.i.i
  %cmp.i.i.i = icmp eq i32 %obj.val.i.i.i, 4
  br i1 %cmp.i.i.i, label %if.end14.i.i, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %qobject_type.exit.i.i.i
  %refcnt.i.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %call5.i.i, i64 0, i32 1
  %6 = load i64, ptr %refcnt.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq i64 %6, 0
  br i1 %tobool1.not.i.i.i, label %if.else.i11.i.i, label %land.lhs.true.i9.i.i

if.else.i11.i.i:                                  ; preds = %lor.lhs.false.i.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i9.i.i:                             ; preds = %lor.lhs.false.i.i.i
  %dec.i.i.i = add i64 %6, -1
  store i64 %dec.i.i.i, ptr %refcnt.i.i.i, align 8
  %cmp.i10.i.i = icmp eq i64 %dec.i.i.i, 0
  br i1 %cmp.i10.i.i, label %if.then5.i.i.i, label %qobject_unref_impl.exit.i.i

if.then5.i.i.i:                                   ; preds = %land.lhs.true.i9.i.i
  call void @qobject_destroy(ptr noundef nonnull %call5.i.i) #29
  br label %qobject_unref_impl.exit.i.i

qobject_unref_impl.exit.i.i:                      ; preds = %if.then5.i.i.i, %land.lhs.true.i9.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err.i, ptr noundef nonnull @.str.2, i32 noundef 2009, ptr noundef nonnull @__func__.parse_json_filename, ptr noundef nonnull @.str.232) #29
  br label %parse_json_filename.exit.i

if.end14.i.i:                                     ; preds = %qobject_type.exit.i.i.i
  call void @qdict_flatten(ptr noundef nonnull %call5.i.i) #29
  br label %parse_json_filename.exit.i

parse_json_filename.exit.i:                       ; preds = %if.end14.i.i, %qobject_unref_impl.exit.i.i, %if.then7.i.i
  %retval.0.i.i = phi ptr [ %call5.i.i, %if.end14.i.i ], [ null, %qobject_unref_impl.exit.i.i ], [ null, %if.then7.i.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %filename.addr.i.i)
  %7 = load ptr, ptr %local_err.i, align 8
  %tobool6.not.i = icmp eq ptr %7, null
  br i1 %tobool6.not.i, label %if.end8.i, label %if.then7.i

if.then7.i:                                       ; preds = %parse_json_filename.exit.i
  call void @error_propagate(ptr noundef nonnull %local_err, ptr noundef nonnull %7) #29
  br label %parse_json_protocol.exit

if.end8.i:                                        ; preds = %parse_json_filename.exit.i
  call void @qdict_join(ptr noundef %options.addr.0, ptr noundef %retval.0.i.i, i1 noundef zeroext false) #29
  %tobool9.not.i = icmp eq ptr %retval.0.i.i, null
  br i1 %tobool9.not.i, label %parse_json_protocol.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.end8.i
  %refcnt.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %retval.0.i.i, i64 0, i32 1
  %8 = load i64, ptr %refcnt.i.i, align 8
  %tobool1.not.i.i = icmp eq i64 %8, 0
  br i1 %tobool1.not.i.i, label %if.else.i7.i, label %land.lhs.true.i.i

if.else.i7.i:                                     ; preds = %lor.lhs.false.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i.i:                                ; preds = %lor.lhs.false.i.i
  %dec.i.i = add i64 %8, -1
  store i64 %dec.i.i, ptr %refcnt.i.i, align 8
  %cmp.i.i = icmp eq i64 %dec.i.i, 0
  br i1 %cmp.i.i, label %if.then5.i.i, label %parse_json_protocol.exit

if.then5.i.i:                                     ; preds = %land.lhs.true.i.i
  call void @qobject_destroy(ptr noundef nonnull %retval.0.i.i) #29
  br label %parse_json_protocol.exit

parse_json_protocol.exit:                         ; preds = %if.end8.i, %land.lhs.true.i.i, %if.then5.i.i, %do.end.i, %lor.lhs.false.i111, %if.then7.i
  %filename.addr.0 = phi ptr [ null, %do.end.i ], [ %filename, %lor.lhs.false.i111 ], [ %filename, %if.then7.i ], [ null, %if.then5.i.i ], [ null, %land.lhs.true.i.i ], [ null, %if.end8.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i)
  %9 = load ptr, ptr %local_err, align 8
  %tobool44.not = icmp eq ptr %9, null
  br i1 %tobool44.not, label %if.end46, label %fail

if.end46:                                         ; preds = %parse_json_protocol.exit
  %call47 = call ptr @qdict_clone_shallow(ptr noundef %options.addr.0) #29
  %explicit_options = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 34
  store ptr %call47, ptr %explicit_options, align 8
  br i1 %tobool, label %if.then49, label %if.end60

if.then49:                                        ; preds = %if.end46
  %drv50 = getelementptr inbounds %struct.BlockDriverState, ptr %parent, i64 0, i32 6
  %10 = load ptr, ptr %drv50, align 8
  %tobool51.not = icmp eq ptr %10, null
  br i1 %tobool51.not, label %if.end57, label %if.then52

if.then52:                                        ; preds = %if.then49
  %is_format = getelementptr inbounds %struct.BlockDriver, ptr %10, i64 0, i32 4
  %11 = load i8, ptr %is_format, align 2
  %12 = and i8 %11, 1
  br label %if.end57

if.end57:                                         ; preds = %if.then49, %if.then52
  %parent_is_format.0 = phi i8 [ %12, %if.then52 ], [ 1, %if.then49 ]
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 28
  store ptr %parent, ptr %inherits_from, align 8
  %inherit_options = getelementptr inbounds %struct.BdrvChildClass, ptr %child_class, i64 0, i32 2
  %13 = load ptr, ptr %inherit_options, align 8
  %tobool58 = icmp ne i8 %parent_is_format.0, 0
  %14 = load i32, ptr %parent, align 8
  %options59 = getelementptr inbounds %struct.BlockDriverState, ptr %parent, i64 0, i32 33
  %15 = load ptr, ptr %options59, align 8
  call void %13(i32 noundef %child_role, i1 noundef zeroext %tobool58, ptr noundef nonnull %flags.addr, ptr noundef %options.addr.0, i32 noundef %14, ptr noundef %15) #29
  br label %if.end60

if.end60:                                         ; preds = %if.end57, %if.end46
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %local_err.i112)
  %16 = load i32, ptr %flags.addr, align 4
  store ptr null, ptr %local_err.i112, align 8
  %call.i113 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i113, label %do.end.i115, label %if.else.i114

if.else.i114:                                     ; preds = %if.end60
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2058, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_fill_options) #31
  unreachable

do.end.i115:                                      ; preds = %if.end60
  %call1.i116 = call ptr @qdict_get_try_str(ptr noundef %options.addr.0, ptr noundef nonnull @.str.20) #29
  %tobool2.not.i117 = icmp eq ptr %call1.i116, null
  br i1 %tobool2.not.i117, label %if.end10.i, label %if.then3.i

if.then3.i:                                       ; preds = %do.end.i115
  %call.i.i118 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i118, label %do.end.i.i120, label %if.else.i.i119

if.else.i.i119:                                   ; preds = %if.then3.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_format) #31
  unreachable

do.end.i.i120:                                    ; preds = %if.then3.i
  %call.i.i.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i.i, label %for.cond.preheader.i.i.i, label %if.else.i.i.i

for.cond.preheader.i.i.i:                         ; preds = %do.end.i.i120
  %drv1.04.i.i.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not5.i.i.i = icmp eq ptr %drv1.04.i.i.i, null
  br i1 %tobool.not5.i.i.i, label %if.then6.i, label %for.body.i.i.i

if.else.i.i.i:                                    ; preds = %do.end.i.i120
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 444, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_format) #31
  unreachable

for.body.i.i.i:                                   ; preds = %for.cond.preheader.i.i.i, %for.inc.i.i.i
  %drv1.06.i.i.i = phi ptr [ %drv1.0.i.i.i, %for.inc.i.i.i ], [ %drv1.04.i.i.i, %for.cond.preheader.i.i.i ]
  %17 = load ptr, ptr %drv1.06.i.i.i, align 8
  %call2.i.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %17, ptr noundef nonnull dereferenceable(1) %call1.i116) #28
  %tobool3.not.i.i.i = icmp eq i32 %call2.i.i.i, 0
  br i1 %tobool3.not.i.i.i, label %if.end7.i, label %for.inc.i.i.i

for.inc.i.i.i:                                    ; preds = %for.body.i.i.i
  %list.i.i.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i.i, i64 0, i32 61
  %drv1.0.i.i.i = load ptr, ptr %list.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %drv1.0.i.i.i, null
  br i1 %tobool.not.i.i.i, label %if.then6.i, label %for.body.i.i.i, !llvm.loop !8

if.then6.i:                                       ; preds = %for.inc.i.i.i, %for.cond.preheader.i.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 2071, ptr noundef nonnull @__func__.bdrv_fill_options, ptr noundef nonnull @.str.233, ptr noundef nonnull %call1.i116) #29
  br label %bdrv_fill_options.exit.thread

if.end7.i:                                        ; preds = %for.body.i.i.i
  %bdrv_file_open.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i.i, i64 0, i32 24
  %18 = load ptr, ptr %bdrv_file_open.i, align 8
  %tobool8.not.i = icmp eq ptr %18, null
  br i1 %tobool8.not.i, label %if.else13.i, label %if.then12.i

if.end10.i:                                       ; preds = %do.end.i115
  %19 = and i32 %16, 32768
  %.not.i = icmp eq i32 %19, 0
  br i1 %.not.i, label %if.else13.i, label %if.then12.i

if.then12.i:                                      ; preds = %if.end10.i, %if.end7.i
  %drv.046.i = phi ptr [ %drv1.06.i.i.i, %if.end7.i ], [ null, %if.end10.i ]
  %20 = load i32, ptr %flags.addr, align 4
  %or.i = or i32 %20, 32768
  br label %if.end15.i

if.else13.i:                                      ; preds = %if.end10.i, %if.end7.i
  %drv.045.i = phi ptr [ %drv1.06.i.i.i, %if.end7.i ], [ null, %if.end10.i ]
  %21 = load i32, ptr %flags.addr, align 4
  %and14.i = and i32 %21, -32769
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.else13.i, %if.then12.i
  %drv.044.i = phi ptr [ %drv.045.i, %if.else13.i ], [ %drv.046.i, %if.then12.i ]
  %protocol.041.i = phi i1 [ false, %if.else13.i ], [ true, %if.then12.i ]
  %storemerge.i = phi i32 [ %and14.i, %if.else13.i ], [ %or.i, %if.then12.i ]
  store i32 %storemerge.i, ptr %flags.addr, align 4
  call fastcc void @update_options_from_flags(ptr noundef %options.addr.0, i32 noundef %storemerge.i)
  %tobool17.i = icmp ne ptr %filename.addr.0, null
  %or.cond.i = and i1 %tobool17.i, %protocol.041.i
  br i1 %or.cond.i, label %if.then18.i, label %if.end24.i

if.then18.i:                                      ; preds = %if.end15.i
  %call19.i = call i32 @qdict_haskey(ptr noundef %options.addr.0, ptr noundef nonnull @.str.5) #29
  %tobool20.not.i = icmp eq i32 %call19.i, 0
  br i1 %tobool20.not.i, label %if.then21.i, label %if.else22.i

if.then21.i:                                      ; preds = %if.then18.i
  call void @qdict_put_str(ptr noundef %options.addr.0, ptr noundef nonnull @.str.5, ptr noundef nonnull %filename.addr.0) #29
  br label %if.end24.i

if.else22.i:                                      ; preds = %if.then18.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 2095, ptr noundef nonnull @__func__.bdrv_fill_options, ptr noundef nonnull @.str.234) #29
  br label %bdrv_fill_options.exit.thread

if.end24.i:                                       ; preds = %if.then21.i, %if.end15.i
  %call25.i = call ptr @qdict_get_try_str(ptr noundef %options.addr.0, ptr noundef nonnull @.str.5) #29
  %brmerge.not.i = and i1 %tobool2.not.i117, %protocol.041.i
  br i1 %brmerge.not.i, label %if.then29.i, label %if.end39.i

if.then29.i:                                      ; preds = %if.end24.i
  %tobool30.not.i = icmp eq ptr %call25.i, null
  br i1 %tobool30.not.i, label %if.else37.i, label %if.then31.i

if.then31.i:                                      ; preds = %if.then29.i
  %call33.i = call ptr @bdrv_find_protocol(ptr noundef nonnull %call25.i, i1 noundef zeroext %or.cond.i, ptr noundef nonnull %local_err)
  %tobool34.not.i = icmp eq ptr %call33.i, null
  br i1 %tobool34.not.i, label %bdrv_fill_options.exit.thread, label %if.end39.thread.i

if.end39.thread.i:                                ; preds = %if.then31.i
  %22 = load ptr, ptr %call33.i, align 8
  call void @qdict_put_str(ptr noundef %options.addr.0, ptr noundef nonnull @.str.20, ptr noundef %22) #29
  br label %land.lhs.true46.i

if.else37.i:                                      ; preds = %if.then29.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 2114, ptr noundef nonnull @__func__.bdrv_fill_options, ptr noundef nonnull @.str.225) #29
  br label %bdrv_fill_options.exit.thread

if.end39.i:                                       ; preds = %if.end24.i
  %tobool40.not.i = icmp eq ptr %drv.044.i, null
  %brmerge37.not.i = and i1 %tobool40.not.i, %protocol.041.i
  br i1 %brmerge37.not.i, label %if.else43.i, label %if.end44.i

if.else43.i:                                      ; preds = %if.end39.i
  call void @__assert_fail(ptr noundef nonnull @.str.235, ptr noundef nonnull @.str.2, i32 noundef 2119, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_fill_options) #31
  unreachable

if.end44.i:                                       ; preds = %if.end39.i
  br i1 %tobool40.not.i, label %if.end64, label %land.lhs.true46.i

land.lhs.true46.i:                                ; preds = %if.end44.i, %if.end39.thread.i
  %drv.15153.i = phi ptr [ %call33.i, %if.end39.thread.i ], [ %drv.044.i, %if.end44.i ]
  %bdrv_parse_filename.i = getelementptr inbounds %struct.BlockDriver, ptr %drv.15153.i, i64 0, i32 17
  %23 = load ptr, ptr %bdrv_parse_filename.i, align 8
  %tobool47.not.i = icmp ne ptr %23, null
  %brmerge38.not.i = and i1 %or.cond.i, %tobool47.not.i
  br i1 %brmerge38.not.i, label %if.then50.i, label %if.end64

if.then50.i:                                      ; preds = %land.lhs.true46.i
  call void %23(ptr noundef %call25.i, ptr noundef %options.addr.0, ptr noundef nonnull %local_err.i112) #29
  %24 = load ptr, ptr %local_err.i112, align 8
  %tobool52.not.i = icmp eq ptr %24, null
  br i1 %tobool52.not.i, label %if.end54.i, label %if.then53.i

if.then53.i:                                      ; preds = %if.then50.i
  call void @error_propagate(ptr noundef nonnull %local_err, ptr noundef nonnull %24) #29
  br label %bdrv_fill_options.exit.thread

if.end54.i:                                       ; preds = %if.then50.i
  %bdrv_needs_filename.i = getelementptr inbounds %struct.BlockDriver, ptr %drv.15153.i, i64 0, i32 6
  %25 = load i8, ptr %bdrv_needs_filename.i, align 8
  %26 = and i8 %25, 1
  %tobool55.not.i = icmp eq i8 %26, 0
  br i1 %tobool55.not.i, label %if.then56.i, label %if.end64

if.then56.i:                                      ; preds = %if.end54.i
  call void @qdict_del(ptr noundef %options.addr.0, ptr noundef nonnull @.str.5) #29
  br label %if.end64

bdrv_fill_options.exit.thread:                    ; preds = %if.else22.i, %if.then53.i, %if.else37.i, %if.then6.i, %if.then31.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i112)
  br label %fail

if.end64:                                         ; preds = %if.then56.i, %if.end54.i, %land.lhs.true46.i, %if.end44.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i112)
  %call65 = call ptr @qdict_get_try_str(ptr noundef %options.addr.0, ptr noundef nonnull @.str.51) #29
  %call66 = call i32 @g_strcmp0(ptr noundef %call65, ptr noundef nonnull @.str.36) #29
  %tobool67.not = icmp eq i32 %call66, 0
  br i1 %tobool67.not, label %if.else70, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end64
  %call68 = call zeroext i1 @qdict_get_try_bool(ptr noundef %options.addr.0, ptr noundef nonnull @.str.51, i1 noundef zeroext false) #29
  br i1 %call68, label %if.else70, label %if.then69

if.then69:                                        ; preds = %land.lhs.true
  %27 = load i32, ptr %flags.addr, align 4
  %or = or i32 %27, 8194
  br label %if.end71

if.else70:                                        ; preds = %land.lhs.true, %if.end64
  %28 = load i32, ptr %flags.addr, align 4
  %and = and i32 %28, -3
  br label %if.end71

if.end71:                                         ; preds = %if.else70, %if.then69
  %storemerge = phi i32 [ %or, %if.then69 ], [ %and, %if.else70 ]
  store i32 %storemerge, ptr %flags.addr, align 4
  %and72 = and i32 %storemerge, 8
  %tobool73.not = icmp eq i32 %and72, 0
  br i1 %tobool73.not, label %if.end76, label %if.then74

if.then74:                                        ; preds = %if.end71
  %call75 = call ptr @qdict_new() #29
  %29 = load i32, ptr %flags.addr, align 4
  %call.i121 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i121, label %bdrv_temp_snapshot_options.exit, label %if.else.i122

if.else.i122:                                     ; preds = %if.then74
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1244, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_temp_snapshot_options) #31
  unreachable

bdrv_temp_snapshot_options.exit:                  ; preds = %if.then74
  %and.i = and i32 %29, -153
  %or.i124 = or disjoint i32 %and.i, 16
  call void @qdict_set_default_str(ptr noundef %call75, ptr noundef nonnull @.str.47, ptr noundef nonnull @.str.34) #29
  call void @qdict_set_default_str(ptr noundef %call75, ptr noundef nonnull @.str.49, ptr noundef nonnull @.str.36) #29
  call void @qdict_copy_default(ptr noundef %call75, ptr noundef %options.addr.0, ptr noundef nonnull @.str.51) #29
  call void @qdict_copy_default(ptr noundef %call75, ptr noundef %options.addr.0, ptr noundef nonnull @.str.57) #29
  call void @qdict_del(ptr noundef %options.addr.0, ptr noundef nonnull @.str.51) #29
  %30 = load i32, ptr %flags.addr, align 4
  call void @bdrv_inherited_options(i32 noundef 8, i1 noundef zeroext true, ptr noundef nonnull %flags.addr, ptr noundef %options.addr.0, i32 noundef %30, ptr noundef %options.addr.0)
  %.pre = load i32, ptr %flags.addr, align 4
  br label %if.end76

if.end76:                                         ; preds = %bdrv_temp_snapshot_options.exit, %if.end71
  %31 = phi i32 [ %storemerge, %if.end71 ], [ %.pre, %bdrv_temp_snapshot_options.exit ]
  %snapshot_flags.0 = phi i32 [ 0, %if.end71 ], [ %or.i124, %bdrv_temp_snapshot_options.exit ]
  %snapshot_options.0 = phi ptr [ null, %if.end71 ], [ %call75, %bdrv_temp_snapshot_options.exit ]
  store i32 %31, ptr %call39, align 8
  %options78 = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 33
  store ptr %options.addr.0, ptr %options78, align 8
  %call79 = call ptr @qdict_clone_shallow(ptr noundef %options.addr.0) #29
  %call80 = call ptr @qdict_get_try_str(ptr noundef %call79, ptr noundef nonnull @.str.20) #29
  %tobool81.not = icmp eq ptr %call80, null
  br i1 %tobool81.not, label %lor.lhs.false89, label %if.then82

if.then82:                                        ; preds = %if.end76
  %call.i125 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i125, label %do.end.i127, label %if.else.i126

if.else.i126:                                     ; preds = %if.then82
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_format) #31
  unreachable

do.end.i127:                                      ; preds = %if.then82
  %call.i.i128 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i128, label %for.cond.preheader.i.i, label %if.else.i.i129

for.cond.preheader.i.i:                           ; preds = %do.end.i127
  %drv1.04.i.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not5.i.i = icmp eq ptr %drv1.04.i.i, null
  br i1 %tobool.not5.i.i, label %if.then85, label %for.body.i.i

if.else.i.i129:                                   ; preds = %do.end.i127
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 444, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_format) #31
  unreachable

for.body.i.i:                                     ; preds = %for.cond.preheader.i.i, %for.inc.i.i
  %drv1.06.i.i = phi ptr [ %drv1.0.i.i, %for.inc.i.i ], [ %drv1.04.i.i, %for.cond.preheader.i.i ]
  %32 = load ptr, ptr %drv1.06.i.i, align 8
  %call2.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %32, ptr noundef nonnull dereferenceable(1) %call80) #28
  %tobool3.not.i.i = icmp eq i32 %call2.i.i, 0
  br i1 %tobool3.not.i.i, label %if.end94, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %list.i.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i, i64 0, i32 61
  %drv1.0.i.i = load ptr, ptr %list.i.i, align 8
  %tobool.not.i.i130 = icmp eq ptr %drv1.0.i.i, null
  br i1 %tobool.not.i.i130, label %if.then85, label %for.body.i.i, !llvm.loop !8

if.then85:                                        ; preds = %for.inc.i.i, %for.cond.preheader.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4080, ptr noundef nonnull @__func__.bdrv_open_inherit, ptr noundef nonnull @.str.91, ptr noundef nonnull %call80) #29
  br label %fail

lor.lhs.false89:                                  ; preds = %if.end76
  %33 = load i32, ptr %flags.addr, align 4
  %and90 = and i32 %33, 32768
  %tobool91.not = icmp eq i32 %and90, 0
  br i1 %tobool91.not, label %if.end94, label %if.else93

if.else93:                                        ; preds = %lor.lhs.false89
  call void @__assert_fail(ptr noundef nonnull @.str.223, ptr noundef nonnull @.str.2, i32 noundef 4085, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

if.end94:                                         ; preds = %for.body.i.i, %lor.lhs.false89
  %drv.1 = phi ptr [ null, %lor.lhs.false89 ], [ %drv1.06.i.i, %for.body.i.i ]
  %call95 = call ptr @qdict_get_try_str(ptr noundef %call79, ptr noundef nonnull @.str.89) #29
  %call96 = call ptr @qdict_get(ptr noundef %call79, ptr noundef nonnull @.str.89) #29
  %tobool.not.i131 = icmp eq ptr %call96, null
  br i1 %tobool.not.i131, label %lor.lhs.false99, label %land.lhs.true.i132

land.lhs.true.i132:                               ; preds = %if.end94
  %obj.val.i = load i32, ptr %call96, align 8
  %34 = add i32 %obj.val.i, -1
  %or.cond.i.i = icmp ult i32 %34, 6
  br i1 %or.cond.i.i, label %qobject_type.exit.i, label %if.else.i.i133

if.else.i.i133:                                   ; preds = %land.lhs.true.i132
  call void @__assert_fail(ptr noundef nonnull @.str.218, ptr noundef nonnull @.str.161, i32 noundef 126, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_type) #31
  unreachable

qobject_type.exit.i:                              ; preds = %land.lhs.true.i132
  %cmp.i134 = icmp eq i32 %obj.val.i, 1
  br i1 %cmp.i134, label %if.then104, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %if.end94, %qobject_type.exit.i
  %tobool100.not = icmp eq ptr %call95, null
  br i1 %tobool100.not, label %if.end111, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %lor.lhs.false99
  %35 = load i8, ptr %call95, align 1
  %cmp102 = icmp eq i8 %35, 0
  br i1 %cmp102, label %if.then106, label %if.end111

if.then104:                                       ; preds = %qobject_type.exit.i
  %tobool105.not = icmp eq ptr %call95, null
  br i1 %tobool105.not, label %if.end107, label %if.then106

if.then106:                                       ; preds = %land.lhs.true101, %if.then104
  call void (ptr, ...) @warn_report(ptr noundef nonnull @.str.224) #29
  br label %if.end107

if.end107:                                        ; preds = %if.then106, %if.then104
  %36 = load i32, ptr %flags.addr, align 4
  %or108 = or i32 %36, 256
  store i32 %or108, ptr %flags.addr, align 4
  %37 = load ptr, ptr %explicit_options, align 8
  call void @qdict_del(ptr noundef %37, ptr noundef nonnull @.str.89) #29
  %38 = load ptr, ptr %options78, align 8
  call void @qdict_del(ptr noundef %38, ptr noundef nonnull @.str.89) #29
  call void @qdict_del(ptr noundef %call79, ptr noundef nonnull @.str.89) #29
  br label %if.end111

if.end111:                                        ; preds = %if.end107, %land.lhs.true101, %lor.lhs.false99
  %39 = load i32, ptr %flags.addr, align 4
  %and112 = and i32 %39, 32768
  %cmp113 = icmp eq i32 %and112, 0
  br i1 %cmp113, label %if.then115, label %if.end131.thread

if.then115:                                       ; preds = %if.end111
  %call116 = call fastcc ptr @bdrv_open_child_bs(ptr noundef %filename.addr.0, ptr noundef %call79, ptr noundef nonnull @.str.214, ptr noundef nonnull %call39, ptr noundef nonnull @child_of_bds, i32 noundef 19, i1 noundef zeroext true, ptr noundef nonnull %local_err)
  %40 = load ptr, ptr %local_err, align 8
  %tobool117.not = icmp eq ptr %40, null
  br i1 %tobool117.not, label %if.end119, label %fail

if.end119:                                        ; preds = %if.then115
  %cmp120.not = icmp eq ptr %call116, null
  br i1 %cmp120.not, label %if.end131.thread, label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %if.end119
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %call116, i64 0, i32 8
  %41 = load ptr, ptr %aio_context.i, align 8
  call void @aio_context_acquire(ptr noundef %41) #29
  %call124 = call ptr @blk_new(ptr noundef %41, i64 noundef 0, i64 noundef 15) #29
  %call125 = call i32 @blk_insert_bs(ptr noundef %call124, ptr noundef nonnull %call116, ptr noundef nonnull %local_err) #29
  call void @bdrv_unref(ptr noundef nonnull %call116)
  call void @aio_context_release(ptr noundef %41) #29
  %42 = load ptr, ptr %local_err, align 8
  %tobool126.not = icmp eq ptr %42, null
  br i1 %tobool126.not, label %if.end131, label %fail

if.end131.thread:                                 ; preds = %if.end119, %if.end111
  %tobool132.not293 = icmp eq ptr %drv.1, null
  %probed294 = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 3
  %frombool135295 = zext i1 %tobool132.not293 to i8
  store i8 %frombool135295, ptr %probed294, align 2
  br i1 %tobool132.not293, label %if.then149, label %if.end151

if.end131:                                        ; preds = %bdrv_get_aio_context.exit
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %call116, i64 0, i32 22
  call void @qdict_put_str(ptr noundef %call79, ptr noundef nonnull @.str.214, ptr noundef nonnull %node_name.i) #29
  %tobool132.not = icmp eq ptr %drv.1, null
  %probed = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 3
  %frombool135 = zext i1 %tobool132.not to i8
  store i8 %frombool135, ptr %probed, align 2
  %tobool138 = icmp ne ptr %call124, null
  %or.cond1 = and i1 %tobool132.not, %tobool138
  br i1 %or.cond1, label %if.then139, label %if.else147

if.then139:                                       ; preds = %if.end131
  call void @llvm.lifetime.start.p0(i64 512, ptr nonnull %buf.i)
  %call.i139 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i139, label %do.end.i141, label %if.else.i140

if.else.i140:                                     ; preds = %if.then139
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1019, ptr noundef nonnull @__PRETTY_FUNCTION__.find_image_format) #31
  unreachable

do.end.i141:                                      ; preds = %if.then139
  %call1.i142 = call zeroext i1 @blk_is_sg(ptr noundef nonnull %call124) #29
  br i1 %call1.i142, label %if.end144, label %lor.lhs.false.i143

lor.lhs.false.i143:                               ; preds = %do.end.i141
  %call2.i = call zeroext i1 @blk_is_inserted(ptr noundef nonnull %call124) #29
  br i1 %call2.i, label %lor.lhs.false3.i, label %if.end144

lor.lhs.false3.i:                                 ; preds = %lor.lhs.false.i143
  %call4.i = call i64 @blk_getlength(ptr noundef nonnull %call124) #29
  %cmp.i145 = icmp eq i64 %call4.i, 0
  br i1 %cmp.i145, label %if.end144, label %if.end6.i

if.end6.i:                                        ; preds = %lor.lhs.false3.i
  %call7.i = call i32 @blk_pread(ptr noundef nonnull %call124, i64 noundef 0, i64 noundef 512, ptr noundef nonnull %buf.i, i32 noundef 0) #29
  %cmp8.i = icmp slt i32 %call7.i, 0
  br i1 %cmp8.i, label %if.then9.i, label %if.end10.i146

if.then9.i:                                       ; preds = %if.end6.i
  %sub.i = sub i32 0, %call7.i
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1030, ptr noundef nonnull @__func__.find_image_format, i32 noundef %sub.i, ptr noundef nonnull @.str.236) #29
  br label %find_image_format.exit

if.end10.i146:                                    ; preds = %if.end6.i
  %d.07.i.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not8.i.i = icmp eq ptr %d.07.i.i, null
  br i1 %tobool.not8.i.i, label %if.then13.i, label %for.body.i.i147

for.body.i.i147:                                  ; preds = %if.end10.i146, %for.inc.i.i151
  %d.011.i.i = phi ptr [ %d.0.i.i, %for.inc.i.i151 ], [ %d.07.i.i, %if.end10.i146 ]
  %drv.010.i.i = phi ptr [ %drv.1.i.i, %for.inc.i.i151 ], [ null, %if.end10.i146 ]
  %score_max.09.i.i = phi i32 [ %score_max.1.i.i, %for.inc.i.i151 ], [ 0, %if.end10.i146 ]
  %bdrv_probe.i.i = getelementptr inbounds %struct.BlockDriver, ptr %d.011.i.i, i64 0, i32 62
  %43 = load ptr, ptr %bdrv_probe.i.i, align 8
  %tobool1.not.i.i148 = icmp eq ptr %43, null
  br i1 %tobool1.not.i.i148, label %for.inc.i.i151, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i147
  %call.i.i149 = call i32 %43(ptr noundef nonnull %buf.i, i32 noundef 512, ptr noundef %filename.addr.0) #29
  %cmp.i.i150 = icmp sgt i32 %call.i.i149, %score_max.09.i.i
  %spec.select.i.i = call i32 @llvm.smax.i32(i32 %call.i.i149, i32 %score_max.09.i.i)
  %spec.select6.i.i = select i1 %cmp.i.i150, ptr %d.011.i.i, ptr %drv.010.i.i
  br label %for.inc.i.i151

for.inc.i.i151:                                   ; preds = %if.then.i.i, %for.body.i.i147
  %score_max.1.i.i = phi i32 [ %score_max.09.i.i, %for.body.i.i147 ], [ %spec.select.i.i, %if.then.i.i ]
  %drv.1.i.i = phi ptr [ %drv.010.i.i, %for.body.i.i147 ], [ %spec.select6.i.i, %if.then.i.i ]
  %list.i.i152 = getelementptr inbounds %struct.BlockDriver, ptr %d.011.i.i, i64 0, i32 61
  %d.0.i.i = load ptr, ptr %list.i.i152, align 8
  %tobool.not.i.i153 = icmp eq ptr %d.0.i.i, null
  br i1 %tobool.not.i.i153, label %bdrv_probe_all.exit.i, label %for.body.i.i147, !llvm.loop !11

bdrv_probe_all.exit.i:                            ; preds = %for.inc.i.i151
  %tobool.not.i154 = icmp eq ptr %drv.1.i.i, null
  br i1 %tobool.not.i154, label %if.then13.i, label %if.end144

if.then13.i:                                      ; preds = %bdrv_probe_all.exit.i, %if.end10.i146
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1038, ptr noundef nonnull @__func__.find_image_format, ptr noundef nonnull @.str.237) #29
  br label %find_image_format.exit

find_image_format.exit:                           ; preds = %if.then9.i, %if.then13.i
  call void @llvm.lifetime.end.p0(i64 512, ptr nonnull %buf.i)
  br label %fail

if.end144:                                        ; preds = %lor.lhs.false3.i, %lor.lhs.false.i143, %do.end.i141, %bdrv_probe_all.exit.i
  %drv.1.i.lcssa.sink.i.ph = phi ptr [ %drv.1.i.i, %bdrv_probe_all.exit.i ], [ @bdrv_raw, %do.end.i141 ], [ @bdrv_raw, %lor.lhs.false.i143 ], [ @bdrv_raw, %lor.lhs.false3.i ]
  call void @llvm.lifetime.end.p0(i64 512, ptr nonnull %buf.i)
  %44 = load ptr, ptr %options78, align 8
  %45 = load ptr, ptr %drv.1.i.lcssa.sink.i.ph, align 8
  call void @qdict_put_str(ptr noundef %44, ptr noundef nonnull @.str.20, ptr noundef %45) #29
  %46 = load ptr, ptr %drv.1.i.lcssa.sink.i.ph, align 8
  call void @qdict_put_str(ptr noundef %call79, ptr noundef nonnull @.str.20, ptr noundef %46) #29
  br label %if.end151

if.else147:                                       ; preds = %if.end131
  br i1 %tobool132.not, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end131.thread, %if.else147
  %ctx.0299310 = phi ptr [ %call, %if.end131.thread ], [ %41, %if.else147 ]
  %file.0301309 = phi ptr [ null, %if.end131.thread ], [ %call124, %if.else147 ]
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4154, ptr noundef nonnull @__func__.bdrv_open_inherit, ptr noundef nonnull @.str.225) #29
  br label %fail

if.end151:                                        ; preds = %if.end131.thread, %if.else147, %if.end144
  %tobool138303 = phi i1 [ true, %if.end144 ], [ %tobool138, %if.else147 ], [ false, %if.end131.thread ]
  %file.0300 = phi ptr [ %call124, %if.end144 ], [ %call124, %if.else147 ], [ null, %if.end131.thread ]
  %ctx.0298 = phi ptr [ %41, %if.end144 ], [ %41, %if.else147 ], [ %call, %if.end131.thread ]
  %drv.2 = phi ptr [ %drv.1.i.lcssa.sink.i.ph, %if.end144 ], [ %drv.1, %if.else147 ], [ %drv.1, %if.end131.thread ]
  %47 = load i32, ptr %flags.addr, align 4
  %and152 = and i32 %47, 32768
  %and152.lobit = lshr exact i32 %and152, 15
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %drv.2, i64 0, i32 24
  %48 = load ptr, ptr %bdrv_file_open, align 8
  %tobool158 = icmp ne ptr %48, null
  %lnot.ext162 = zext i1 %tobool158 to i32
  %cmp163 = icmp eq i32 %and152.lobit, %lnot.ext162
  br i1 %cmp163, label %if.end167, label %if.else166

if.else166:                                       ; preds = %if.end151
  call void @__assert_fail(ptr noundef nonnull @.str.226, ptr noundef nonnull @.str.2, i32 noundef 4159, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

if.end167:                                        ; preds = %if.end151
  %tobool153 = icmp ne i32 %and152, 0
  %or.cond2 = and i1 %tobool138303, %tobool153
  br i1 %or.cond2, label %if.else173, label %if.end174

if.else173:                                       ; preds = %if.end167
  call void @__assert_fail(ptr noundef nonnull @.str.227, ptr noundef nonnull @.str.2, i32 noundef 4162, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_inherit) #31
  unreachable

if.end174:                                        ; preds = %if.end167
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %local_err.i155)
  store ptr null, ptr %local_err.i155, align 8
  %call.i156 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i156, label %do.end.i158, label %if.else.i157

if.else.i157:                                     ; preds = %if.end174
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1859, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_common) #31
  unreachable

do.end.i158:                                      ; preds = %if.end174
  call void @bdrv_graph_rdlock_main_loop() #29
  %file1.i = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 31
  %49 = load ptr, ptr %file1.i, align 8
  %cmp.i159 = icmp eq ptr %49, null
  br i1 %cmp.i159, label %if.end4.i160, label %if.else3.i

if.else3.i:                                       ; preds = %do.end.i158
  call void @__assert_fail(ptr noundef nonnull @.str.238, ptr noundef nonnull @.str.2, i32 noundef 1862, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_common) #31
  unreachable

if.end4.i160:                                     ; preds = %do.end.i158
  %cmp5.not.i = icmp eq ptr %call79, null
  br i1 %cmp5.not.i, label %if.else9.i, label %land.lhs.true.i161

land.lhs.true.i161:                               ; preds = %if.end4.i160
  %50 = load ptr, ptr %options78, align 8
  %cmp7.not.i = icmp eq ptr %50, %call79
  br i1 %cmp7.not.i, label %if.else9.i, label %if.end10.i162

if.else9.i:                                       ; preds = %land.lhs.true.i161, %if.end4.i160
  call void @__assert_fail(ptr noundef nonnull @.str.239, ptr noundef nonnull @.str.2, i32 noundef 1863, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_common) #31
  unreachable

if.end10.i162:                                    ; preds = %land.lhs.true.i161
  call void @bdrv_graph_rdunlock_main_loop() #29
  %call11.i = call ptr @qemu_opts_create(ptr noundef nonnull @bdrv_runtime_opts, ptr noundef null, i32 noundef 0, ptr noundef nonnull @error_abort) #29
  %call12.i = call zeroext i1 @qemu_opts_absorb_qdict(ptr noundef %call11.i, ptr noundef nonnull %call79, ptr noundef nonnull %local_err) #29
  br i1 %call12.i, label %if.end14.i, label %bdrv_open_common.exit.thread

if.end14.i:                                       ; preds = %if.end10.i162
  call fastcc void @update_flags_from_options(ptr noundef nonnull %call39, ptr noundef %call11.i)
  %call16.i = call ptr @qemu_opt_get(ptr noundef %call11.i, ptr noundef nonnull @.str.20) #29
  %call.i.i164 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i164, label %do.end.i.i166, label %if.else.i.i165

if.else.i.i165:                                   ; preds = %if.end14.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_format) #31
  unreachable

do.end.i.i166:                                    ; preds = %if.end14.i
  %call.i.i.i167 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i.i167, label %for.cond.preheader.i.i.i169, label %if.else.i.i.i168

for.cond.preheader.i.i.i169:                      ; preds = %do.end.i.i166
  %drv1.04.i.i.i170 = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not5.i.i.i171 = icmp eq ptr %drv1.04.i.i.i170, null
  br i1 %tobool.not5.i.i.i171, label %if.else20.i, label %for.body.i.i.i172

if.else.i.i.i168:                                 ; preds = %do.end.i.i166
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 444, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_format) #31
  unreachable

for.body.i.i.i172:                                ; preds = %for.cond.preheader.i.i.i169, %for.inc.i.i.i176
  %drv1.06.i.i.i173 = phi ptr [ %drv1.0.i.i.i178, %for.inc.i.i.i176 ], [ %drv1.04.i.i.i170, %for.cond.preheader.i.i.i169 ]
  %51 = load ptr, ptr %drv1.06.i.i.i173, align 8
  %call2.i.i.i174 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %51, ptr noundef nonnull dereferenceable(1) %call16.i) #28
  %tobool3.not.i.i.i175 = icmp eq i32 %call2.i.i.i174, 0
  br i1 %tobool3.not.i.i.i175, label %if.end21.i, label %for.inc.i.i.i176

for.inc.i.i.i176:                                 ; preds = %for.body.i.i.i172
  %list.i.i.i177 = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i.i173, i64 0, i32 61
  %drv1.0.i.i.i178 = load ptr, ptr %list.i.i.i177, align 8
  %tobool.not.i.i.i179 = icmp eq ptr %drv1.0.i.i.i178, null
  br i1 %tobool.not.i.i.i179, label %if.else20.i, label %for.body.i.i.i172, !llvm.loop !8

if.else20.i:                                      ; preds = %for.inc.i.i.i176, %for.cond.preheader.i.i.i169
  call void @__assert_fail(ptr noundef nonnull @.str.240, ptr noundef nonnull @.str.2, i32 noundef 1876, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_common) #31
  unreachable

if.end21.i:                                       ; preds = %for.body.i.i.i172
  %call22.i = call zeroext i1 @qemu_opt_get_bool(ptr noundef %call11.i, ptr noundef nonnull @.str.59, i1 noundef zeroext false) #29
  %force_share.i = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 4
  %frombool.i = zext i1 %call22.i to i8
  store i8 %frombool.i, ptr %force_share.i, align 1
  br i1 %call22.i, label %land.lhs.true24.i, label %if.end28.i

land.lhs.true24.i:                                ; preds = %if.end21.i
  %52 = load i32, ptr %call39, align 8
  %and.i188 = and i32 %52, 2
  %tobool26.not.i = icmp eq i32 %and.i188, 0
  br i1 %tobool26.not.i, label %if.end28.i, label %if.then27.i

if.then27.i:                                      ; preds = %land.lhs.true24.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1883, ptr noundef nonnull @__func__.bdrv_open_common, ptr noundef nonnull @.str.241) #29
  br label %bdrv_open_common.exit.thread

if.end28.i:                                       ; preds = %land.lhs.true24.i, %if.end21.i
  %cmp29.not.i = icmp eq ptr %file.0300, null
  br i1 %cmp29.not.i, label %if.else34.i, label %if.then30.i

if.then30.i:                                      ; preds = %if.end28.i
  call void @bdrv_graph_rdlock_main_loop() #29
  %call31.i = call ptr @blk_bs(ptr noundef nonnull %file.0300) #29
  call void @bdrv_refresh_filename(ptr noundef %call31.i)
  call void @bdrv_graph_rdunlock_main_loop() #29
  %call32.i = call ptr @blk_bs(ptr noundef nonnull %file.0300) #29
  %filename33.i = getelementptr inbounds %struct.BlockDriverState, ptr %call32.i, i64 0, i32 11
  br label %if.end36.i

if.else34.i:                                      ; preds = %if.end28.i
  %call35.i = call ptr @qdict_get_try_str(ptr noundef nonnull %call79, ptr noundef nonnull @.str.5) #29
  br label %if.end36.i

if.end36.i:                                       ; preds = %if.else34.i, %if.then30.i
  %filename.0.i = phi ptr [ %filename33.i, %if.then30.i ], [ %call35.i, %if.else34.i ]
  %bdrv_needs_filename.i180 = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i.i173, i64 0, i32 6
  %53 = load i8, ptr %bdrv_needs_filename.i180, align 8
  %54 = and i8 %53, 1
  %tobool37.not.i = icmp eq i8 %54, 0
  br i1 %tobool37.not.i, label %if.end42.i, label %land.lhs.true38.i

land.lhs.true38.i:                                ; preds = %if.end36.i
  %tobool39.not.i = icmp eq ptr %filename.0.i, null
  br i1 %tobool39.not.i, label %if.then41.i, label %lor.lhs.false.i181

lor.lhs.false.i181:                               ; preds = %land.lhs.true38.i
  %55 = load i8, ptr %filename.0.i, align 1
  %tobool40.not.i182 = icmp eq i8 %55, 0
  br i1 %tobool40.not.i182, label %if.then41.i, label %if.end42.i

if.then41.i:                                      ; preds = %lor.lhs.false.i181, %land.lhs.true38.i
  %56 = load ptr, ptr %drv1.06.i.i.i173, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1907, ptr noundef nonnull @__func__.bdrv_open_common, ptr noundef nonnull @.str.242, ptr noundef %56) #29
  br label %bdrv_open_common.exit.thread

if.end42.i:                                       ; preds = %lor.lhs.false.i181, %if.end36.i
  %tobool43.not.i = icmp eq ptr %filename.0.i, null
  %..str.95.i = select i1 %tobool43.not.i, ptr @.str.95, ptr %filename.0.i
  %57 = load i32, ptr %call39, align 8
  %58 = load ptr, ptr %drv1.06.i.i.i173, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %_now.i.i.i)
  %59 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool.i.i.i = icmp ne i32 %59, 0
  %60 = load i16, ptr @_TRACE_BDRV_OPEN_COMMON_DSTATE, align 2
  %tobool4.i.i.i = icmp ne i16 %60, 0
  %or.cond.i.i.i = select i1 %tobool.i.i.i, i1 %tobool4.i.i.i, i1 false
  br i1 %or.cond.i.i.i, label %land.lhs.true5.i.i.i, label %trace_bdrv_open_common.exit.i

land.lhs.true5.i.i.i:                             ; preds = %if.end42.i
  %61 = load i32, ptr @qemu_loglevel, align 4
  %and.i.i.i.i = and i32 %61, 32768
  %cmp.i.not.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %cmp.i.not.i.i.i, label %trace_bdrv_open_common.exit.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.lhs.true5.i.i.i
  %62 = load i8, ptr @message_with_timestamp, align 1
  %63 = and i8 %62, 1
  %tobool7.not.i.i.i = icmp eq i8 %63, 0
  br i1 %tobool7.not.i.i.i, label %if.else.i.i64.i, label %if.then8.i.i.i

if.then8.i.i.i:                                   ; preds = %if.then.i.i.i
  %call9.i.i.i = call i32 @gettimeofday(ptr noundef nonnull %_now.i.i.i, ptr noundef null) #29
  %call10.i.i.i = call i32 @qemu_get_thread_id() #29
  %64 = load i64, ptr %_now.i.i.i, align 8
  %tv_usec.i.i.i = getelementptr inbounds %struct.timeval, ptr %_now.i.i.i, i64 0, i32 1
  %65 = load i64, ptr %tv_usec.i.i.i, align 8
  call void (ptr, ...) @qemu_log(ptr noundef nonnull @.str.249, i32 noundef %call10.i.i.i, i64 noundef %64, i64 noundef %65, ptr noundef nonnull %call39, ptr noundef nonnull %..str.95.i, i32 noundef %57, ptr noundef %58) #29
  br label %trace_bdrv_open_common.exit.i

if.else.i.i64.i:                                  ; preds = %if.then.i.i.i
  call void (ptr, ...) @qemu_log(ptr noundef nonnull @.str.250, ptr noundef nonnull %call39, ptr noundef nonnull %..str.95.i, i32 noundef %57, ptr noundef %58) #29
  br label %trace_bdrv_open_common.exit.i

trace_bdrv_open_common.exit.i:                    ; preds = %if.else.i.i64.i, %if.then8.i.i.i, %land.lhs.true5.i.i.i, %if.end42.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %_now.i.i.i)
  %66 = load i32, ptr %call39, align 8
  %and.i.i = and i32 %66, 2
  %tobool.not.i.i183 = icmp eq i32 %and.i.i, 0
  %.b.i = load i1, ptr @use_bdrv_whitelist, align 4
  br i1 %.b.i, label %land.lhs.true49.i, label %while.end.i

land.lhs.true49.i:                                ; preds = %trace_bdrv_open_common.exit.i
  %call.i65.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i65.i, label %while.end.i, label %if.else.i66.i

if.else.i66.i:                                    ; preds = %land.lhs.true49.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 517, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_is_whitelisted) #31
  unreachable

while.end.i:                                      ; preds = %land.lhs.true49.i, %trace_bdrv_open_common.exit.i
  %copy_on_read.i = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 42
  %67 = load atomic i32, ptr %copy_on_read.i monotonic, align 8
  %cmp73.i = icmp eq i32 %67, 0
  br i1 %cmp73.i, label %if.end76.i, label %if.else75.i

if.else75.i:                                      ; preds = %while.end.i
  call void @__assert_fail(ptr noundef nonnull @.str.245, ptr noundef nonnull @.str.2, i32 noundef 1936, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_common) #31
  unreachable

if.end76.i:                                       ; preds = %while.end.i
  %68 = load i32, ptr %call39, align 8
  %and78.i = and i32 %68, 1024
  %tobool79.not.i = icmp eq i32 %and78.i, 0
  br i1 %tobool79.not.i, label %if.end85.i, label %if.then80.i

if.then80.i:                                      ; preds = %if.end76.i
  br i1 %tobool.not.i.i183, label %if.else83.i, label %if.then82.i

if.then82.i:                                      ; preds = %if.then80.i
  call void @bdrv_enable_copy_on_read(ptr noundef nonnull %call39) #29
  br label %if.end85.i

if.else83.i:                                      ; preds = %if.then80.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1942, ptr noundef nonnull @__func__.bdrv_open_common, ptr noundef nonnull @.str.246) #29
  br label %bdrv_open_common.exit.thread

if.end85.i:                                       ; preds = %if.then82.i, %if.end76.i
  %call86.i = call ptr @qemu_opt_get(ptr noundef %call11.i, ptr noundef nonnull @.str.57) #29
  %cmp87.not.i = icmp eq ptr %call86.i, null
  br i1 %cmp87.not.i, label %if.end85.if.end94_crit_edge.i, label %if.then88.i

if.end85.if.end94_crit_edge.i:                    ; preds = %if.end85.i
  %.pre.i = load i32, ptr %call39, align 8
  br label %if.end94.i

if.then88.i:                                      ; preds = %if.end85.i
  %69 = load i32, ptr %call39, align 4
  %and.i72.i = and i32 %69, -16385
  store i32 %and.i72.i, ptr %call39, align 4
  %call.i73.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call86.i, ptr noundef nonnull dereferenceable(4) @.str.34) #28
  %tobool.not.i74.i = icmp eq i32 %call.i73.i, 0
  br i1 %tobool.not.i74.i, label %if.end94.i, label %lor.lhs.false.i.i184

lor.lhs.false.i.i184:                             ; preds = %if.then88.i
  %call1.i.i185 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call86.i, ptr noundef nonnull dereferenceable(7) @.str.35) #28
  %tobool2.not.i.i = icmp eq i32 %call1.i.i185, 0
  br i1 %tobool2.not.i.i, label %if.end94.i, label %if.else.i75.i

if.else.i75.i:                                    ; preds = %lor.lhs.false.i.i184
  %call3.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call86.i, ptr noundef nonnull dereferenceable(3) @.str.36) #28
  %tobool4.not.i.i = icmp eq i32 %call3.i.i, 0
  br i1 %tobool4.not.i.i, label %if.then8.i.i, label %lor.lhs.false5.i.i

lor.lhs.false5.i.i:                               ; preds = %if.else.i75.i
  %call6.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call86.i, ptr noundef nonnull dereferenceable(6) @.str.37) #28
  %tobool7.not.i.i = icmp eq i32 %call6.i.i, 0
  br i1 %tobool7.not.i.i, label %if.then8.i.i, label %if.then92.i

if.then8.i.i:                                     ; preds = %lor.lhs.false5.i.i, %if.else.i75.i
  %or.i.i = or i32 %69, 16384
  store i32 %or.i.i, ptr %call39, align 4
  br label %if.end94.i

if.then92.i:                                      ; preds = %lor.lhs.false5.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 1951, ptr noundef nonnull @__func__.bdrv_open_common, ptr noundef nonnull @.str.247) #29
  br label %bdrv_open_common.exit.thread

if.end94.i:                                       ; preds = %if.then8.i.i, %lor.lhs.false.i.i184, %if.then88.i, %if.end85.if.end94_crit_edge.i
  %70 = phi i32 [ %.pre.i, %if.end85.if.end94_crit_edge.i ], [ %or.i.i, %if.then8.i.i ], [ %and.i72.i, %lor.lhs.false.i.i184 ], [ %and.i72.i, %if.then88.i ]
  %call96.i = call fastcc i32 @bdrv_parse_detect_zeroes(ptr noundef %call11.i, i32 noundef %70, ptr noundef nonnull %local_err.i155)
  %detect_zeroes.i = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 35
  store i32 %call96.i, ptr %detect_zeroes.i, align 8
  %71 = load ptr, ptr %local_err.i155, align 8
  %tobool97.not.i = icmp eq ptr %71, null
  br i1 %tobool97.not.i, label %if.end99.i, label %if.then98.i

if.then98.i:                                      ; preds = %if.end94.i
  call void @error_propagate(ptr noundef nonnull %local_err, ptr noundef nonnull %71) #29
  br label %bdrv_open_common.exit.thread

if.end99.i:                                       ; preds = %if.end94.i
  %filename105.i = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 11
  br i1 %tobool43.not.i, label %if.else104.i, label %if.then101.i

if.then101.i:                                     ; preds = %if.end99.i
  call void @pstrcpy(ptr noundef nonnull %filename105.i, i32 noundef 4096, ptr noundef nonnull %filename.0.i) #29
  br label %if.end107.i

if.else104.i:                                     ; preds = %if.end99.i
  store i8 0, ptr %filename105.i, align 1
  br label %if.end107.i

if.end107.i:                                      ; preds = %if.else104.i, %if.then101.i
  %exact_filename.i = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 16
  call void @pstrcpy(ptr noundef nonnull %exact_filename.i, i32 noundef 4096, ptr noundef nonnull %filename105.i) #29
  %72 = load i32, ptr %call39, align 8
  %call.i76.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i76.i, label %bdrv_open_flags.exit.i, label %if.else.i77.i

if.else.i77.i:                                    ; preds = %if.end107.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1522, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_flags) #31
  unreachable

bdrv_open_flags.exit.i:                           ; preds = %if.end107.i
  %call113.i = call ptr @qemu_opt_get(ptr noundef %call11.i, ptr noundef nonnull @.str.44) #29
  %bdrv_file_open.i186 = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i.i173, i64 0, i32 24
  %73 = load ptr, ptr %bdrv_file_open.i186, align 8
  %tobool114.i = icmp eq ptr %73, null
  %or.cond.i187 = or i1 %cmp29.not.i, %tobool114.i
  br i1 %or.cond.i187, label %bdrv_open_common.exit, label %if.else118.i

if.else118.i:                                     ; preds = %bdrv_open_flags.exit.i
  call void @__assert_fail(ptr noundef nonnull @.str.248, ptr noundef nonnull @.str.2, i32 noundef 1976, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_common) #31
  unreachable

bdrv_open_common.exit.thread:                     ; preds = %if.then27.i, %if.else83.i, %if.then92.i, %if.then98.i, %if.then41.i, %if.end10.i162
  call void @qemu_opts_del(ptr noundef %call11.i) #29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i155)
  br label %fail

bdrv_open_common.exit:                            ; preds = %bdrv_open_flags.exit.i
  %and.i79.i = and i32 %72, -33033
  %call120.i = call i32 @bdrv_open_driver(ptr noundef nonnull %call39, ptr noundef nonnull %drv1.06.i.i.i173, ptr noundef %call113.i, ptr noundef nonnull %call79, i32 noundef %and.i79.i, ptr noundef nonnull %local_err), !range !14
  call void @qemu_opts_del(ptr noundef %call11.i) #29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i155)
  %cmp176 = icmp slt i32 %call120.i, 0
  br i1 %cmp176, label %fail, label %bdrv_get_aio_context.exit195

bdrv_get_aio_context.exit195:                     ; preds = %bdrv_open_common.exit
  %aio_context.i191 = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 8
  %74 = load ptr, ptr %aio_context.i191, align 8
  br i1 %tobool138303, label %if.then182, label %if.end183

if.then182:                                       ; preds = %bdrv_get_aio_context.exit195
  call void @aio_context_acquire(ptr noundef %74) #29
  call void @blk_unref(ptr noundef nonnull %file.0300) #29
  call void @aio_context_release(ptr noundef %74) #29
  br label %if.end183

if.end183:                                        ; preds = %if.then182, %bdrv_get_aio_context.exit195
  %75 = load i32, ptr %flags.addr, align 4
  %and184 = and i32 %75, 256
  %cmp185 = icmp eq i32 %and184, 0
  br i1 %cmp185, label %if.then187, label %if.end193

if.then187:                                       ; preds = %if.end183
  %call188 = call i32 @bdrv_open_backing_file(ptr noundef nonnull %call39, ptr noundef %call79, ptr noundef nonnull @.str.89, ptr noundef nonnull %local_err), !range !14
  %cmp189 = icmp slt i32 %call188, 0
  br i1 %cmp189, label %close_and_fail, label %if.end193

if.end193:                                        ; preds = %if.then187, %if.end183
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 29
  %child.0316 = load ptr, ptr %children, align 8
  %tobool194.not317 = icmp eq ptr %child.0316, null
  br i1 %tobool194.not317, label %for.end, label %for.body

for.body:                                         ; preds = %if.end193, %for.body
  %child.0318 = phi ptr [ %child.0, %for.body ], [ %child.0316, %if.end193 ]
  %name = getelementptr inbounds %struct.BdrvChild, ptr %child.0318, i64 0, i32 1
  %76 = load ptr, ptr %name, align 8
  %call195 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef nonnull @.str.76, ptr noundef %76) #29
  %77 = load ptr, ptr %explicit_options, align 8
  call void @qdict_extract_subqdict(ptr noundef %77, ptr noundef null, ptr noundef %call195) #29
  %78 = load ptr, ptr %options78, align 8
  call void @qdict_extract_subqdict(ptr noundef %78, ptr noundef null, ptr noundef %call195) #29
  %79 = load ptr, ptr %explicit_options, align 8
  %80 = load ptr, ptr %name, align 8
  call void @qdict_del(ptr noundef %79, ptr noundef %80) #29
  %81 = load ptr, ptr %options78, align 8
  %82 = load ptr, ptr %name, align 8
  call void @qdict_del(ptr noundef %81, ptr noundef %82) #29
  call void @g_free(ptr noundef %call195) #29
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.0318, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool194.not = icmp eq ptr %child.0, null
  br i1 %tobool194.not, label %for.end, label %for.body, !llvm.loop !30

for.end:                                          ; preds = %for.body, %if.end193
  %call202 = call i64 @qdict_size(ptr noundef %call79) #29
  %cmp203.not = icmp eq i64 %call202, 0
  br i1 %cmp203.not, label %if.end216, label %if.then205

if.then205:                                       ; preds = %for.end
  %call207 = call ptr @qdict_first(ptr noundef %call79) #29
  %83 = load i32, ptr %flags.addr, align 4
  %and208 = and i32 %83, 32768
  %tobool209.not = icmp eq i32 %and208, 0
  %84 = load ptr, ptr %drv.2, align 8
  %85 = load ptr, ptr %call207, align 8
  br i1 %tobool209.not, label %if.else212, label %if.then210

if.then210:                                       ; preds = %if.then205
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4205, ptr noundef nonnull @__func__.bdrv_open_inherit, ptr noundef nonnull @.str.228, ptr noundef %84, ptr noundef %85) #29
  br label %close_and_fail

if.else212:                                       ; preds = %if.then205
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4209, ptr noundef nonnull @__func__.bdrv_open_inherit, ptr noundef nonnull @.str.229, ptr noundef %84, ptr noundef %85) #29
  br label %close_and_fail

if.end216:                                        ; preds = %for.end
  call fastcc void @bdrv_parent_cb_change_media(ptr noundef nonnull %call39)
  call fastcc void @qobject_unref_impl(ptr noundef %call79)
  %tobool227.not = icmp eq i32 %snapshot_flags.0, 0
  br i1 %tobool227.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.then228

if.then228:                                       ; preds = %if.end216
  %call229 = call fastcc ptr @bdrv_append_temp_snapshot(ptr noundef nonnull %call39, i32 noundef %snapshot_flags.0, ptr noundef %snapshot_options.0, ptr noundef nonnull %local_err)
  %86 = load ptr, ptr %local_err, align 8
  %tobool230.not = icmp eq ptr %86, null
  br i1 %tobool230.not, label %if.end232, label %close_and_fail

if.end232:                                        ; preds = %if.then228
  call void @aio_context_acquire(ptr noundef %74) #29
  call void @bdrv_unref(ptr noundef nonnull %call39)
  call void @aio_context_release(ptr noundef %74) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

fail:                                             ; preds = %bdrv_open_common.exit.thread, %find_image_format.exit, %bdrv_fill_options.exit.thread, %bdrv_open_common.exit, %bdrv_get_aio_context.exit, %if.then115, %parse_json_protocol.exit, %if.then149, %if.then85
  %options.addr.1 = phi ptr [ %call79, %find_image_format.exit ], [ %call79, %bdrv_open_common.exit ], [ %call79, %if.then149 ], [ %call79, %bdrv_get_aio_context.exit ], [ %call79, %if.then115 ], [ %call79, %if.then85 ], [ %options.addr.0, %parse_json_protocol.exit ], [ %options.addr.0, %bdrv_fill_options.exit.thread ], [ %call79, %bdrv_open_common.exit.thread ]
  %ctx.1 = phi ptr [ %41, %find_image_format.exit ], [ %ctx.0298, %bdrv_open_common.exit ], [ %ctx.0299310, %if.then149 ], [ %41, %bdrv_get_aio_context.exit ], [ %call, %if.then115 ], [ %call, %if.then85 ], [ %call, %parse_json_protocol.exit ], [ %call, %bdrv_fill_options.exit.thread ], [ %ctx.0298, %bdrv_open_common.exit.thread ]
  %snapshot_options.1 = phi ptr [ %snapshot_options.0, %find_image_format.exit ], [ %snapshot_options.0, %bdrv_open_common.exit ], [ %snapshot_options.0, %if.then149 ], [ %snapshot_options.0, %bdrv_get_aio_context.exit ], [ %snapshot_options.0, %if.then115 ], [ %snapshot_options.0, %if.then85 ], [ null, %parse_json_protocol.exit ], [ null, %bdrv_fill_options.exit.thread ], [ %snapshot_options.0, %bdrv_open_common.exit.thread ]
  %file.1 = phi ptr [ %call124, %find_image_format.exit ], [ %file.0300, %bdrv_open_common.exit ], [ %file.0301309, %if.then149 ], [ %call124, %bdrv_get_aio_context.exit ], [ null, %if.then115 ], [ null, %if.then85 ], [ null, %parse_json_protocol.exit ], [ null, %bdrv_fill_options.exit.thread ], [ %file.0300, %bdrv_open_common.exit.thread ]
  call void @aio_context_acquire(ptr noundef %ctx.1) #29
  call void @blk_unref(ptr noundef %file.1) #29
  %tobool235.not = icmp eq ptr %snapshot_options.1, null
  br i1 %tobool235.not, label %qobject_unref_impl.exit205, label %lor.lhs.false.i196

lor.lhs.false.i196:                               ; preds = %fail
  %refcnt.i197 = getelementptr inbounds %struct.QObjectBase_, ptr %snapshot_options.1, i64 0, i32 1
  %87 = load i64, ptr %refcnt.i197, align 8
  %tobool1.not.i198 = icmp eq i64 %87, 0
  br i1 %tobool1.not.i198, label %if.else.i204, label %land.lhs.true.i199

if.else.i204:                                     ; preds = %lor.lhs.false.i196
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i199:                               ; preds = %lor.lhs.false.i196
  %dec.i200 = add i64 %87, -1
  store i64 %dec.i200, ptr %refcnt.i197, align 8
  %cmp.i201 = icmp eq i64 %dec.i200, 0
  br i1 %cmp.i201, label %if.then5.i203, label %qobject_unref_impl.exit205

if.then5.i203:                                    ; preds = %land.lhs.true.i199
  call void @qobject_destroy(ptr noundef nonnull %snapshot_options.1) #29
  br label %qobject_unref_impl.exit205

qobject_unref_impl.exit205:                       ; preds = %fail, %land.lhs.true.i199, %if.then5.i203
  %explicit_options244 = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 34
  %88 = load ptr, ptr %explicit_options244, align 8
  %tobool246.not = icmp eq ptr %88, null
  br i1 %tobool246.not, label %qobject_unref_impl.exit215, label %lor.lhs.false.i206

lor.lhs.false.i206:                               ; preds = %qobject_unref_impl.exit205
  %refcnt.i207 = getelementptr inbounds %struct.QObjectBase_, ptr %88, i64 0, i32 1
  %89 = load i64, ptr %refcnt.i207, align 8
  %tobool1.not.i208 = icmp eq i64 %89, 0
  br i1 %tobool1.not.i208, label %if.else.i214, label %land.lhs.true.i209

if.else.i214:                                     ; preds = %lor.lhs.false.i206
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i209:                               ; preds = %lor.lhs.false.i206
  %dec.i210 = add i64 %89, -1
  store i64 %dec.i210, ptr %refcnt.i207, align 8
  %cmp.i211 = icmp eq i64 %dec.i210, 0
  br i1 %cmp.i211, label %if.then5.i213, label %qobject_unref_impl.exit215

if.then5.i213:                                    ; preds = %land.lhs.true.i209
  call void @qobject_destroy(ptr noundef nonnull %88) #29
  br label %qobject_unref_impl.exit215

qobject_unref_impl.exit215:                       ; preds = %qobject_unref_impl.exit205, %land.lhs.true.i209, %if.then5.i213
  %options255 = getelementptr inbounds %struct.BlockDriverState, ptr %call39, i64 0, i32 33
  %90 = load ptr, ptr %options255, align 8
  %tobool257.not = icmp eq ptr %90, null
  br i1 %tobool257.not, label %qobject_unref_impl.exit225, label %lor.lhs.false.i216

lor.lhs.false.i216:                               ; preds = %qobject_unref_impl.exit215
  %refcnt.i217 = getelementptr inbounds %struct.QObjectBase_, ptr %90, i64 0, i32 1
  %91 = load i64, ptr %refcnt.i217, align 8
  %tobool1.not.i218 = icmp eq i64 %91, 0
  br i1 %tobool1.not.i218, label %if.else.i224, label %land.lhs.true.i219

if.else.i224:                                     ; preds = %lor.lhs.false.i216
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i219:                               ; preds = %lor.lhs.false.i216
  %dec.i220 = add i64 %91, -1
  store i64 %dec.i220, ptr %refcnt.i217, align 8
  %cmp.i221 = icmp eq i64 %dec.i220, 0
  br i1 %cmp.i221, label %if.then5.i223, label %qobject_unref_impl.exit225

if.then5.i223:                                    ; preds = %land.lhs.true.i219
  call void @qobject_destroy(ptr noundef nonnull %90) #29
  br label %qobject_unref_impl.exit225

qobject_unref_impl.exit225:                       ; preds = %qobject_unref_impl.exit215, %land.lhs.true.i219, %if.then5.i223
  %tobool267.not = icmp eq ptr %options.addr.1, null
  br i1 %tobool267.not, label %qobject_unref_impl.exit235, label %lor.lhs.false.i226

lor.lhs.false.i226:                               ; preds = %qobject_unref_impl.exit225
  %refcnt.i227 = getelementptr inbounds %struct.QObjectBase_, ptr %options.addr.1, i64 0, i32 1
  %92 = load i64, ptr %refcnt.i227, align 8
  %tobool1.not.i228 = icmp eq i64 %92, 0
  br i1 %tobool1.not.i228, label %if.else.i234, label %land.lhs.true.i229

if.else.i234:                                     ; preds = %lor.lhs.false.i226
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i229:                               ; preds = %lor.lhs.false.i226
  %dec.i230 = add i64 %92, -1
  store i64 %dec.i230, ptr %refcnt.i227, align 8
  %cmp.i231 = icmp eq i64 %dec.i230, 0
  br i1 %cmp.i231, label %if.then5.i233, label %qobject_unref_impl.exit235

if.then5.i233:                                    ; preds = %land.lhs.true.i229
  call void @qobject_destroy(ptr noundef nonnull %options.addr.1) #29
  br label %qobject_unref_impl.exit235

qobject_unref_impl.exit235:                       ; preds = %qobject_unref_impl.exit225, %land.lhs.true.i229, %if.then5.i233
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %options255, i8 0, i64 16, i1 false)
  call void @bdrv_unref(ptr noundef nonnull %call39)
  call void @aio_context_release(ptr noundef %ctx.1) #29
  %93 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %93) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

close_and_fail:                                   ; preds = %if.then228, %if.then210, %if.else212, %if.then187
  %options.addr.2 = phi ptr [ %call79, %if.then187 ], [ null, %if.then228 ], [ %call79, %if.else212 ], [ %call79, %if.then210 ]
  %snapshot_options.2 = phi ptr [ %snapshot_options.0, %if.then187 ], [ null, %if.then228 ], [ %snapshot_options.0, %if.else212 ], [ %snapshot_options.0, %if.then210 ]
  call void @aio_context_acquire(ptr noundef %74) #29
  call void @bdrv_unref(ptr noundef nonnull %call39)
  call void @aio_context_release(ptr noundef %74) #29
  call fastcc void @qobject_unref_impl(ptr noundef %snapshot_options.2)
  call fastcc void @qobject_unref_impl(ptr noundef %options.addr.2)
  %94 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %94) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %if.end216, %if.end232, %if.end33, %close_and_fail, %qobject_unref_impl.exit235, %bdrv_ref.exit, %if.then32
  %retval.0 = phi ptr [ null, %if.then32 ], [ %call34, %bdrv_ref.exit ], [ null, %qobject_unref_impl.exit235 ], [ null, %close_and_fail ], [ null, %if.end33 ], [ %call229, %if.end232 ], [ %call39, %if.end216 ]
  call void @bdrv_graph_rdunlock_main_loop() #29
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_refresh_filename(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8175, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_refresh_filename) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end179, label %if.end3

if.end3:                                          ; preds = %do.end
  %children = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.0101 = load ptr, ptr %children, align 8
  %tobool4.not102 = icmp eq ptr %child.0101, null
  br i1 %tobool4.not102, label %for.end, label %for.body

for.body:                                         ; preds = %if.end3, %for.body
  %child.0103 = phi ptr [ %child.0, %for.body ], [ %child.0101, %if.end3 ]
  %1 = load ptr, ptr %child.0103, align 8
  tail call void @bdrv_refresh_filename(ptr noundef %1)
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.0103, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool4.not = icmp eq ptr %child.0, null
  br i1 %tobool4.not, label %for.end, label %for.body, !llvm.loop !31

for.end:                                          ; preds = %for.body, %if.end3
  %implicit = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 5
  %2 = load i8, ptr %implicit, align 8
  %3 = and i8 %2, 1
  %tobool6.not = icmp eq i8 %3, 0
  br i1 %tobool6.not, label %if.end38, label %if.then7

if.then7:                                         ; preds = %for.end
  %4 = load ptr, ptr %children, align 8
  %next10 = getelementptr inbounds %struct.BdrvChild, ptr %4, i64 0, i32 9
  %5 = load ptr, ptr %next10, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.end14, label %if.else13

if.else13:                                        ; preds = %if.then7
  tail call void @__assert_fail(ptr noundef nonnull @.str.134, ptr noundef nonnull @.str.2, i32 noundef 8190, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_refresh_filename) #31
  unreachable

if.end14:                                         ; preds = %if.then7
  %exact_filename = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 16
  %6 = load ptr, ptr %4, align 8
  %exact_filename16 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i64 0, i32 16
  tail call void @pstrcpy(ptr noundef nonnull %exact_filename, i32 noundef 4096, ptr noundef nonnull %exact_filename16) #29
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  %7 = load ptr, ptr %4, align 8
  %filename20 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i64 0, i32 11
  tail call void @pstrcpy(ptr noundef nonnull %filename, i32 noundef 4096, ptr noundef nonnull %filename20) #29
  %full_open_options = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 15
  %8 = load ptr, ptr %full_open_options, align 8
  %tobool22.not = icmp eq ptr %8, null
  br i1 %tobool22.not, label %qobject_unref_impl.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end14
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %8, i64 0, i32 1
  %9 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %9, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %9, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %qobject_unref_impl.exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  tail call void @qobject_destroy(ptr noundef nonnull %8) #29
  br label %qobject_unref_impl.exit

qobject_unref_impl.exit:                          ; preds = %if.end14, %land.lhs.true.i, %if.then5.i
  %10 = load ptr, ptr %4, align 8
  %full_open_options25 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i64 0, i32 15
  %11 = load ptr, ptr %full_open_options25, align 8
  %tobool27.not = icmp eq ptr %11, null
  br i1 %tobool27.not, label %qobject_ref_impl.exit, label %if.then.i

if.then.i:                                        ; preds = %qobject_unref_impl.exit
  %refcnt.i75 = getelementptr inbounds %struct.QObjectBase_, ptr %11, i64 0, i32 1
  %12 = load i64, ptr %refcnt.i75, align 8
  %inc.i = add i64 %12, 1
  store i64 %inc.i, ptr %refcnt.i75, align 8
  br label %qobject_ref_impl.exit

qobject_ref_impl.exit:                            ; preds = %qobject_unref_impl.exit, %if.then.i
  store ptr %11, ptr %full_open_options, align 8
  br label %if.end179

if.end38:                                         ; preds = %for.end
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i76

if.else.i76:                                      ; preds = %if.end38
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8142, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_overridden) #31
  unreachable

do.end.i:                                         ; preds = %if.end38
  %backing.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %13 = load ptr, ptr %backing.i, align 8
  %tobool.not.i = icmp eq ptr %13, null
  %auto_backing_file8.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 13
  br i1 %tobool.not.i, label %if.else7.i, label %if.then1.i

if.then1.i:                                       ; preds = %do.end.i
  %14 = load ptr, ptr %13, align 8
  %filename.i = getelementptr inbounds %struct.BlockDriverState, ptr %14, i64 0, i32 11
  %call5.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %auto_backing_file8.i, ptr noundef nonnull dereferenceable(1) %filename.i) #28
  %tobool6.i = icmp ne i32 %call5.i, 0
  br label %bdrv_backing_overridden.exit

if.else7.i:                                       ; preds = %do.end.i
  %15 = load i8, ptr %auto_backing_file8.i, align 1
  %cmp.i77 = icmp ne i8 %15, 0
  br label %bdrv_backing_overridden.exit

bdrv_backing_overridden.exit:                     ; preds = %if.then1.i, %if.else7.i
  %retval.0.i = phi i1 [ %tobool6.i, %if.then1.i ], [ %cmp.i77, %if.else7.i ]
  %16 = load i32, ptr %bs, align 8
  %and = and i32 %16, 65536
  %tobool40.not = icmp eq i32 %and, 0
  %narrow = select i1 %tobool40.not, i1 %retval.0.i, i1 false
  %narrow.fr = freeze i1 %narrow
  %call43 = tail call ptr @qdict_new() #29
  %17 = load ptr, ptr %drv1, align 8
  %tobool.not.i78 = icmp eq ptr %17, null
  br i1 %tobool.not.i78, label %append_strong_runtime_options.exit, label %while.cond.preheader.i

while.cond.preheader.i:                           ; preds = %bdrv_backing_overridden.exit
  %options.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 33
  br label %while.cond.outer.i.outer

while.cond.outer.i.outer:                         ; preds = %land.lhs.true50.i, %while.cond.preheader.i
  %option_name.0.ph.i.ph = phi ptr [ %retval.0.i.i, %land.lhs.true50.i ], [ null, %while.cond.preheader.i ]
  %found_any.0.ph.i.ph = phi i8 [ %spec.select27.i, %land.lhs.true50.i ], [ 0, %while.cond.preheader.i ]
  %18 = and i8 %found_any.0.ph.i.ph, 1
  %tobool44.not.i = icmp ne i8 %18, 0
  br label %while.cond.outer.i

while.cond.outer.i:                               ; preds = %while.cond.outer.i.backedge, %while.cond.outer.i.outer
  %option_name.0.ph.i = phi ptr [ %option_name.0.ph.i.ph, %while.cond.outer.i.outer ], [ %retval.0.i.i, %while.cond.outer.i.backedge ]
  br label %while.cond.i

while.cond.i:                                     ; preds = %if.then8.i, %while.cond.outer.i
  %option_name.0.i = phi ptr [ %retval.0.i.i, %if.then8.i ], [ %option_name.0.ph.i, %while.cond.outer.i ]
  %tobool.not.i.i = icmp eq ptr %option_name.0.i, null
  br i1 %tobool.not.i.i, label %while.body.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %while.cond.i
  %incdec.ptr.i.i = getelementptr ptr, ptr %option_name.0.i, i64 1
  %cmp.i.i = icmp eq ptr %incdec.ptr.i.i, getelementptr inbounds ([3 x ptr], ptr @strong_options.global_options, i64 0, i64 2)
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.end4.i.i

land.lhs.true.i.i:                                ; preds = %if.end.i.i
  %19 = load ptr, ptr %drv1, align 8
  %tobool1.not.i.i = icmp eq ptr %19, null
  br i1 %tobool1.not.i.i, label %land.lhs.true6.i.i, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %land.lhs.true.i.i
  %strong_runtime_opts.i.i = getelementptr inbounds %struct.BlockDriver, ptr %19, i64 0, i32 12
  %20 = load ptr, ptr %strong_runtime_opts.i.i, align 8
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then2.i.i, %if.end.i.i
  %curopt.addr.0.i.i = phi ptr [ %20, %if.then2.i.i ], [ %incdec.ptr.i.i, %if.end.i.i ]
  %tobool5.not.i.i = icmp eq ptr %curopt.addr.0.i.i, null
  br i1 %tobool5.not.i.i, label %while.end.i, label %land.lhs.true6.i.i

land.lhs.true6.i.i:                               ; preds = %if.end4.i.i, %land.lhs.true.i.i
  %curopt.addr.09.i.i = phi ptr [ %curopt.addr.0.i.i, %if.end4.i.i ], [ getelementptr inbounds ([3 x ptr], ptr @strong_options.global_options, i64 0, i64 2), %land.lhs.true.i.i ]
  %21 = load ptr, ptr %curopt.addr.09.i.i, align 8
  %tobool7.not.i.i = icmp eq ptr %21, null
  br i1 %tobool7.not.i.i, label %while.end.i, label %while.body.i

while.body.i:                                     ; preds = %land.lhs.true6.i.i, %while.cond.i
  %22 = phi ptr [ %21, %land.lhs.true6.i.i ], [ @.str.20, %while.cond.i ]
  %retval.0.i.i = phi ptr [ %curopt.addr.09.i.i, %land.lhs.true6.i.i ], [ @strong_options.global_options, %while.cond.i ]
  %call2.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %22) #28
  %cmp.not.i = icmp eq i64 %call2.i, 0
  br i1 %cmp.not.i, label %if.else.i79, label %if.end4.i

if.else.i79:                                      ; preds = %while.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.290, ptr noundef nonnull @.str.2, i32 noundef 8097, ptr noundef nonnull @__PRETTY_FUNCTION__.append_strong_runtime_options) #31
  unreachable

if.end4.i:                                        ; preds = %while.body.i
  %23 = getelementptr i8, ptr %22, i64 %call2.i
  %arrayidx.i = getelementptr i8, ptr %23, i64 -1
  %24 = load i8, ptr %arrayidx.i, align 1
  %cmp6.not.i = icmp eq i8 %24, 46
  %25 = load ptr, ptr %options.i, align 8
  br i1 %cmp6.not.i, label %if.else17.i, label %if.then8.i

if.then8.i:                                       ; preds = %if.end4.i
  %call10.i = tail call ptr @qdict_get(ptr noundef %25, ptr noundef nonnull %22) #29
  %tobool11.not.i = icmp eq ptr %call10.i, null
  br i1 %tobool11.not.i, label %while.cond.i, label %qobject_ref_impl.exit.i, !llvm.loop !32

qobject_ref_impl.exit.i:                          ; preds = %if.then8.i
  %26 = load ptr, ptr %retval.0.i.i, align 8
  %refcnt.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %call10.i, i64 0, i32 1
  %27 = load i64, ptr %refcnt.i.i, align 8
  %inc.i.i = add i64 %27, 1
  store i64 %inc.i.i, ptr %refcnt.i.i, align 8
  tail call void @qdict_put_obj(ptr noundef %call43, ptr noundef %26, ptr noundef nonnull %call10.i) #29
  br label %if.end43.i

if.else17.i:                                      ; preds = %if.end4.i
  %call20.i = tail call ptr @qdict_first(ptr noundef %25) #29
  %tobool21.not41.i = icmp eq ptr %call20.i, null
  br i1 %tobool21.not41.i, label %while.cond.outer.i.backedge, label %for.body.i

for.body.i:                                       ; preds = %if.else17.i, %for.inc.i
  %option_given.043.i = phi i8 [ %option_given.1.i, %for.inc.i ], [ 0, %if.else17.i ]
  %entry18.042.i = phi ptr [ %call42.i, %for.inc.i ], [ %call20.i, %if.else17.i ]
  %call22.i = tail call ptr @qdict_entry_key(ptr noundef nonnull %entry18.042.i) #29
  %28 = load ptr, ptr %retval.0.i.i, align 8
  %call23.i = tail call i32 @strstart(ptr noundef %call22.i, ptr noundef %28, ptr noundef null) #29
  %tobool24.not.i = icmp eq i32 %call23.i, 0
  br i1 %tobool24.not.i, label %for.inc.i, label %if.then25.i

if.then25.i:                                      ; preds = %for.body.i
  %call26.i = tail call ptr @qdict_entry_key(ptr noundef nonnull %entry18.042.i) #29
  %call28.i = tail call ptr @qdict_entry_value(ptr noundef nonnull %entry18.042.i) #29
  %tobool30.not.i = icmp eq ptr %call28.i, null
  br i1 %tobool30.not.i, label %qobject_ref_impl.exit34.i, label %if.then.i30.i

if.then.i30.i:                                    ; preds = %if.then25.i
  %refcnt.i31.i = getelementptr inbounds %struct.QObjectBase_, ptr %call28.i, i64 0, i32 1
  %29 = load i64, ptr %refcnt.i31.i, align 8
  %inc.i32.i = add i64 %29, 1
  store i64 %inc.i32.i, ptr %refcnt.i31.i, align 8
  br label %qobject_ref_impl.exit34.i

qobject_ref_impl.exit34.i:                        ; preds = %if.then.i30.i, %if.then25.i
  tail call void @qdict_put_obj(ptr noundef %call43, ptr noundef %call26.i, ptr noundef %call28.i) #29
  br label %for.inc.i

for.inc.i:                                        ; preds = %qobject_ref_impl.exit34.i, %for.body.i
  %option_given.1.i = phi i8 [ 1, %qobject_ref_impl.exit34.i ], [ %option_given.043.i, %for.body.i ]
  %30 = load ptr, ptr %options.i, align 8
  %call42.i = tail call ptr @qdict_next(ptr noundef %30, ptr noundef nonnull %entry18.042.i) #29
  %tobool21.not.i = icmp eq ptr %call42.i, null
  br i1 %tobool21.not.i, label %if.end43.i, label %for.body.i, !llvm.loop !33

if.end43.i:                                       ; preds = %for.inc.i, %qobject_ref_impl.exit.i
  %option_given.2.i = phi i8 [ 1, %qobject_ref_impl.exit.i ], [ %option_given.1.i, %for.inc.i ]
  %31 = and i8 %option_given.2.i, 1
  %tobool45.not.i = icmp eq i8 %31, 0
  %or.cond.i = select i1 %tobool44.not.i, i1 true, i1 %tobool45.not.i
  br i1 %or.cond.i, label %while.cond.outer.i.backedge, label %land.lhs.true47.i

land.lhs.true47.i:                                ; preds = %if.end43.i
  %32 = load ptr, ptr %retval.0.i.i, align 8
  %call48.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %32, ptr noundef nonnull dereferenceable(7) @.str.20) #28
  %tobool49.not.i = icmp eq i32 %call48.i, 0
  br i1 %tobool49.not.i, label %while.cond.outer.i.backedge, label %land.lhs.true50.i

while.cond.outer.i.backedge:                      ; preds = %land.lhs.true47.i, %if.end43.i, %if.else17.i
  br label %while.cond.outer.i, !llvm.loop !32

land.lhs.true50.i:                                ; preds = %land.lhs.true47.i
  %call51.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %32, ptr noundef nonnull dereferenceable(9) @.str.5) #28
  %tobool52.not.i = icmp eq i32 %call51.i, 0
  %spec.select27.i = select i1 %tobool52.not.i, i8 %found_any.0.ph.i.ph, i8 1
  br label %while.cond.outer.i.outer, !llvm.loop !32

while.end.i:                                      ; preds = %land.lhs.true6.i.i, %if.end4.i.i
  %call55.i = tail call i32 @qdict_haskey(ptr noundef %call43, ptr noundef nonnull @.str.20) #29
  %tobool56.not.i = icmp eq i32 %call55.i, 0
  br i1 %tobool56.not.i, label %if.then57.i, label %if.end59.i

if.then57.i:                                      ; preds = %while.end.i
  %33 = load ptr, ptr %drv1, align 8
  %34 = load ptr, ptr %33, align 8
  tail call void @qdict_put_str(ptr noundef %call43, ptr noundef nonnull @.str.20, ptr noundef %34) #29
  br label %if.end59.i

if.end59.i:                                       ; preds = %if.then57.i, %while.end.i
  %35 = and i8 %found_any.0.ph.i.ph, 1
  %tobool60.i = icmp ne i8 %35, 0
  br label %append_strong_runtime_options.exit

append_strong_runtime_options.exit:               ; preds = %bdrv_backing_overridden.exit, %if.end59.i
  %retval.0.i80 = phi i1 [ %tobool60.i, %if.end59.i ], [ false, %bdrv_backing_overridden.exit ]
  %or70 = or i1 %narrow.fr, %retval.0.i80
  %bdrv_gather_child_options = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 31
  %36 = load ptr, ptr %bdrv_gather_child_options, align 8
  %tobool51.not = icmp eq ptr %36, null
  br i1 %tobool51.not, label %for.cond58.preheader, label %if.then52

for.cond58.preheader:                             ; preds = %append_strong_runtime_options.exit
  %child.1104 = load ptr, ptr %children, align 8
  %tobool59.not105 = icmp eq ptr %child.1104, null
  br i1 %tobool59.not105, label %for.end93, label %for.body60.lr.ph

for.body60.lr.ph:                                 ; preds = %for.cond58.preheader
  br i1 %narrow.fr, label %for.body60.us, label %for.body60

for.body60.us:                                    ; preds = %for.body60.lr.ph, %qobject_ref_impl.exit84.us
  %child.1106.us = phi ptr [ %child.1.us, %qobject_ref_impl.exit84.us ], [ %child.1104, %for.body60.lr.ph ]
  %name.us = getelementptr inbounds %struct.BdrvChild, ptr %child.1106.us, i64 0, i32 1
  %37 = load ptr, ptr %name.us, align 8
  %38 = load ptr, ptr %child.1106.us, align 8
  %full_open_options68.us = getelementptr inbounds %struct.BlockDriverState, ptr %38, i64 0, i32 15
  %39 = load ptr, ptr %full_open_options68.us, align 8
  %tobool70.not.us = icmp eq ptr %39, null
  br i1 %tobool70.not.us, label %qobject_ref_impl.exit84.us, label %if.then.i81.us

if.then.i81.us:                                   ; preds = %for.body60.us
  %refcnt.i82.us = getelementptr inbounds %struct.QObjectBase_, ptr %39, i64 0, i32 1
  %40 = load i64, ptr %refcnt.i82.us, align 8
  %inc.i83.us = add i64 %40, 1
  store i64 %inc.i83.us, ptr %refcnt.i82.us, align 8
  br label %qobject_ref_impl.exit84.us

qobject_ref_impl.exit84.us:                       ; preds = %if.then.i81.us, %for.body60.us
  tail call void @qdict_put_obj(ptr noundef %call43, ptr noundef %37, ptr noundef %39) #29
  %next91.us = getelementptr inbounds %struct.BdrvChild, ptr %child.1106.us, i64 0, i32 9
  %child.1.us = load ptr, ptr %next91.us, align 8
  %tobool59.not.us = icmp eq ptr %child.1.us, null
  br i1 %tobool59.not.us, label %for.end93, label %for.body60.us, !llvm.loop !34

if.then52:                                        ; preds = %append_strong_runtime_options.exit
  tail call void %36(ptr noundef nonnull %bs, ptr noundef %call43, i1 noundef zeroext %narrow.fr) #29
  br label %if.end101

for.body60:                                       ; preds = %for.body60.lr.ph, %for.inc90
  %child.1106 = phi ptr [ %child.1, %for.inc90 ], [ %child.1104, %for.body60.lr.ph ]
  %41 = load ptr, ptr %backing.i, align 8
  %cmp61.not = icmp eq ptr %child.1106, %41
  br i1 %cmp61.not, label %for.inc90, label %if.end65

if.end65:                                         ; preds = %for.body60
  %name = getelementptr inbounds %struct.BdrvChild, ptr %child.1106, i64 0, i32 1
  %42 = load ptr, ptr %name, align 8
  %43 = load ptr, ptr %child.1106, align 8
  %full_open_options68 = getelementptr inbounds %struct.BlockDriverState, ptr %43, i64 0, i32 15
  %44 = load ptr, ptr %full_open_options68, align 8
  %tobool70.not = icmp eq ptr %44, null
  br i1 %tobool70.not, label %qobject_ref_impl.exit84, label %if.then.i81

if.then.i81:                                      ; preds = %if.end65
  %refcnt.i82 = getelementptr inbounds %struct.QObjectBase_, ptr %44, i64 0, i32 1
  %45 = load i64, ptr %refcnt.i82, align 8
  %inc.i83 = add i64 %45, 1
  store i64 %inc.i83, ptr %refcnt.i82, align 8
  br label %qobject_ref_impl.exit84

qobject_ref_impl.exit84:                          ; preds = %if.end65, %if.then.i81
  tail call void @qdict_put_obj(ptr noundef %call43, ptr noundef %42, ptr noundef %44) #29
  br label %for.inc90

for.inc90:                                        ; preds = %for.body60, %qobject_ref_impl.exit84
  %next91 = getelementptr inbounds %struct.BdrvChild, ptr %child.1106, i64 0, i32 9
  %child.1 = load ptr, ptr %next91, align 8
  %tobool59.not = icmp eq ptr %child.1, null
  br i1 %tobool59.not, label %for.end93, label %for.body60, !llvm.loop !34

for.end93:                                        ; preds = %for.inc90, %qobject_ref_impl.exit84.us, %for.cond58.preheader
  br i1 %narrow.fr, label %land.lhs.true96, label %if.end101

land.lhs.true96:                                  ; preds = %for.end93
  %46 = load ptr, ptr %backing.i, align 8
  %tobool98.not = icmp eq ptr %46, null
  br i1 %tobool98.not, label %if.then99, label %if.end101

if.then99:                                        ; preds = %land.lhs.true96
  tail call void @qdict_put_null(ptr noundef %call43, ptr noundef nonnull @.str.89) #29
  br label %if.end101

if.end101:                                        ; preds = %for.end93, %land.lhs.true96, %if.then99, %if.then52
  %full_open_options102 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 15
  %47 = load ptr, ptr %full_open_options102, align 8
  %tobool104.not = icmp eq ptr %47, null
  br i1 %tobool104.not, label %qobject_unref_impl.exit93, label %lor.lhs.false.i85

lor.lhs.false.i85:                                ; preds = %if.end101
  %refcnt.i86 = getelementptr inbounds %struct.QObjectBase_, ptr %47, i64 0, i32 1
  %48 = load i64, ptr %refcnt.i86, align 8
  %tobool1.not.i87 = icmp eq i64 %48, 0
  br i1 %tobool1.not.i87, label %if.else.i92, label %land.lhs.true.i88

if.else.i92:                                      ; preds = %lor.lhs.false.i85
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i88:                                ; preds = %lor.lhs.false.i85
  %dec.i89 = add i64 %48, -1
  store i64 %dec.i89, ptr %refcnt.i86, align 8
  %cmp.i90 = icmp eq i64 %dec.i89, 0
  br i1 %cmp.i90, label %if.then5.i91, label %qobject_unref_impl.exit93

if.then5.i91:                                     ; preds = %land.lhs.true.i88
  tail call void @qobject_destroy(ptr noundef nonnull %47) #29
  br label %qobject_unref_impl.exit93

qobject_unref_impl.exit93:                        ; preds = %if.end101, %land.lhs.true.i88, %if.then5.i91
  store ptr %call43, ptr %full_open_options102, align 8
  %bs.val = load ptr, ptr %children, align 8
  %tobool.not7.i.i = icmp eq ptr %bs.val, null
  br i1 %tobool.not7.i.i, label %bdrv_primary_bs.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %qobject_unref_impl.exit93, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %bs.val, %qobject_unref_impl.exit93 ]
  %found.08.i.i = phi ptr [ %found.1.i.i, %for.inc.i.i ], [ null, %qobject_unref_impl.exit93 ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 3
  %49 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %49, 16
  %tobool1.not.i.i94 = icmp eq i32 %and.i.i, 0
  br i1 %tobool1.not.i.i94, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %tobool2.not.i.i = icmp eq ptr %found.08.i.i, null
  br i1 %tobool2.not.i.i, label %for.inc.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.155, ptr noundef nonnull @.str.2, i32 noundef 8506, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_primary_child) #31
  unreachable

for.inc.i.i:                                      ; preds = %if.then.i.i, %for.body.i.i
  %found.1.i.i = phi ptr [ %found.08.i.i, %for.body.i.i ], [ %c.09.i.i, %if.then.i.i ]
  %next.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 9
  %c.0.i.i = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i95 = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i95, label %bdrv_primary_child.exit.i, label %for.body.i.i, !llvm.loop !35

bdrv_primary_child.exit.i:                        ; preds = %for.inc.i.i
  %tobool.not.i1.i = icmp eq ptr %found.1.i.i, null
  br i1 %tobool.not.i1.i, label %bdrv_primary_bs.exit, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %bdrv_primary_child.exit.i
  %50 = load ptr, ptr %found.1.i.i, align 8
  br label %bdrv_primary_bs.exit

bdrv_primary_bs.exit:                             ; preds = %qobject_unref_impl.exit93, %bdrv_primary_child.exit.i, %cond.true.i.i
  %cond.i.i = phi ptr [ %50, %cond.true.i.i ], [ null, %bdrv_primary_child.exit.i ], [ null, %qobject_unref_impl.exit93 ]
  %bdrv_refresh_filename = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 30
  %51 = load ptr, ptr %bdrv_refresh_filename, align 8
  %tobool115.not = icmp eq ptr %51, null
  br i1 %tobool115.not, label %if.else119, label %if.then116

if.then116:                                       ; preds = %bdrv_primary_bs.exit
  %exact_filename117 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 16
  store i8 0, ptr %exact_filename117, align 8
  %52 = load ptr, ptr %bdrv_refresh_filename, align 8
  tail call void %52(ptr noundef nonnull %bs) #29
  br label %if.end143

if.else119:                                       ; preds = %bdrv_primary_bs.exit
  %tobool120.not = icmp eq ptr %cond.i.i, null
  br i1 %tobool120.not, label %if.end143, label %if.then121

if.then121:                                       ; preds = %if.else119
  %exact_filename122 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 16
  store i8 0, ptr %exact_filename122, align 8
  %exact_filename124 = getelementptr inbounds %struct.BlockDriverState, ptr %cond.i.i, i64 0, i32 16
  %53 = load i8, ptr %exact_filename124, align 8
  %tobool127.not = icmp eq i8 %53, 0
  br i1 %tobool127.not, label %if.end143, label %land.lhs.true128

land.lhs.true128:                                 ; preds = %if.then121
  %drv129 = getelementptr inbounds %struct.BlockDriverState, ptr %cond.i.i, i64 0, i32 6
  %54 = load ptr, ptr %drv129, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %54, i64 0, i32 24
  %55 = load ptr, ptr %bdrv_file_open, align 8
  %tobool130.not = icmp eq ptr %55, null
  br i1 %tobool130.not, label %if.end143, label %land.lhs.true131

land.lhs.true131:                                 ; preds = %land.lhs.true128
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %56 = load i8, ptr %is_filter, align 4
  %57 = and i8 %56, 1
  %tobool132.not = icmp ne i8 %57, 0
  %brmerge73 = select i1 %tobool132.not, i1 true, i1 %or70
  br i1 %brmerge73, label %if.end143, label %if.then135

if.then135:                                       ; preds = %land.lhs.true131
  %call140 = tail call ptr @strcpy(ptr noundef nonnull dereferenceable(1) %exact_filename122, ptr noundef nonnull dereferenceable(1) %exact_filename124) #29
  br label %if.end143

if.end143:                                        ; preds = %land.lhs.true131, %if.else119, %if.then135, %land.lhs.true128, %if.then121, %if.then116
  %exact_filename144 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 16
  %58 = load i8, ptr %exact_filename144, align 8
  %tobool146.not = icmp eq i8 %58, 0
  br i1 %tobool146.not, label %if.else152, label %if.then147

if.then147:                                       ; preds = %if.end143
  %filename148 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  tail call void @pstrcpy(ptr noundef nonnull %filename148, i32 noundef 4096, ptr noundef nonnull %exact_filename144) #29
  br label %if.end179

if.else152:                                       ; preds = %if.end143
  %59 = load ptr, ptr %full_open_options102, align 8
  %call164 = tail call ptr @qobject_to_json(ptr noundef %59) #29
  %filename165 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 11
  %60 = load ptr, ptr %call164, align 8
  %call167 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %filename165, i64 noundef 4096, ptr noundef nonnull @.str.135, ptr noundef %60) #29
  %cmp169 = icmp ugt i32 %call167, 4095
  br i1 %cmp169, label %if.then171, label %if.end177

if.then171:                                       ; preds = %if.else152
  %add.ptr175 = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 11, i64 4092
  store i32 3026478, ptr %add.ptr175, align 1
  br label %if.end177

if.end177:                                        ; preds = %if.then171, %if.else152
  %call178 = tail call ptr @g_string_free(ptr noundef nonnull %call164, i32 noundef 1) #29
  br label %if.end179

if.end179:                                        ; preds = %do.end, %if.end177, %if.then147, %qobject_ref_impl.exit
  ret void
}

declare void @pstrcpy(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #5

declare void @aio_context_acquire(ptr noundef) local_unnamed_addr #5

declare void @aio_context_release(ptr noundef) local_unnamed_addr #5

declare void @qdict_del(ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_open_child(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %child_class, i32 noundef %child_role, i1 noundef zeroext %allow_none, ptr noundef %errp) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3785, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_child) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call fastcc ptr @bdrv_open_child_bs(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %child_class, i32 noundef %child_role, i1 noundef zeroext %allow_none, ptr noundef %errp)
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %return, label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %do.end
  tail call void @bdrv_graph_wrlock(ptr noundef null) #29
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %call1, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  tail call void @aio_context_acquire(ptr noundef %0) #29
  %call5 = tail call ptr @bdrv_attach_child(ptr noundef %parent, ptr noundef nonnull %call1, ptr noundef %bdref_key, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %errp)
  tail call void @aio_context_release(ptr noundef %0) #29
  tail call void @bdrv_graph_wrunlock(ptr noundef null) #29
  br label %return

return:                                           ; preds = %do.end, %bdrv_get_aio_context.exit
  %retval.0 = phi ptr [ %call5, %bdrv_get_aio_context.exit ], [ null, %do.end ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_open_child_bs(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %child_class, i32 noundef %child_role, i1 noundef zeroext %allow_none, ptr noundef %errp) unnamed_addr #4 {
entry:
  %image_options = alloca ptr, align 8
  %cmp.not = icmp eq ptr %child_class, null
  br i1 %cmp.not, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.216, ptr noundef nonnull @.str.2, i32 noundef 3722, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_child_bs) #31
  unreachable

if.end:                                           ; preds = %entry
  %call = tail call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef nonnull @.str.76, ptr noundef %bdref_key) #29
  call void @qdict_extract_subqdict(ptr noundef %options, ptr noundef nonnull %image_options, ptr noundef %call) #29
  call void @g_free(ptr noundef %call) #29
  %call1 = call ptr @qdict_get_try_str(ptr noundef %options, ptr noundef %bdref_key) #29
  %tobool = icmp ne ptr %filename, null
  %tobool2 = icmp ne ptr %call1, null
  %or.cond = select i1 %tobool, i1 true, i1 %tobool2
  br i1 %or.cond, label %if.end12, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %if.end
  %0 = load ptr, ptr %image_options, align 8
  %call4 = call i64 @qdict_size(ptr noundef %0) #29
  %tobool5.not = icmp eq i64 %call4, 0
  br i1 %tobool5.not, label %if.then6, label %if.end12

if.then6:                                         ; preds = %land.lhs.true3
  br i1 %allow_none, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.then6
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3739, ptr noundef nonnull @__func__.bdrv_open_child_bs, ptr noundef nonnull @.str.217, ptr noundef %bdref_key) #29
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.then6
  %1 = load ptr, ptr %image_options, align 8
  %tobool10.not = icmp eq ptr %1, null
  br i1 %tobool10.not, label %done, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end9
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %1, i64 0, i32 1
  %2 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %2, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %2, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %done

if.then5.i:                                       ; preds = %land.lhs.true.i
  call void @qobject_destroy(ptr noundef nonnull %1) #29
  br label %done

if.end12:                                         ; preds = %land.lhs.true3, %if.end
  %3 = load ptr, ptr %image_options, align 8
  %call13 = call ptr @bdrv_open_inherit(ptr noundef %filename, ptr noundef %call1, ptr noundef %3, i32 noundef 0, ptr noundef %parent, ptr noundef nonnull %child_class, i32 noundef %child_role, ptr noundef %errp)
  br label %done

done:                                             ; preds = %if.then5.i, %land.lhs.true.i, %if.end9, %if.end12
  %bs.0 = phi ptr [ %call13, %if.end12 ], [ null, %if.end9 ], [ null, %land.lhs.true.i ], [ null, %if.then5.i ]
  call void @qdict_del(ptr noundef %options, ptr noundef %bdref_key) #29
  ret ptr %bs.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_open_file_child(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %parent, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %filtered_child_is_backing = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 3
  %1 = load i8, ptr %filtered_child_is_backing, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.80, ptr noundef nonnull @.str.2, i32 noundef 3818, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_file_child) #31
  unreachable

if.end:                                           ; preds = %entry
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %3 = load i8, ptr %is_filter, align 4
  %4 = and i8 %3, 1
  %tobool2.not = icmp eq i8 %4, 0
  %cond = select i1 %tobool2.not, i32 19, i32 20
  %call = tail call ptr @bdrv_open_child(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef nonnull %parent, ptr noundef nonnull @child_of_bds, i32 noundef %cond, i1 noundef zeroext false, ptr noundef %errp)
  %tobool3.not = icmp eq ptr %call, null
  %. = select i1 %tobool3.not, i32 -22, i32 0
  ret i32 %.
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_open_blockdev_ref(ptr noundef %ref, ptr noundef %errp) #4 {
entry:
  %obj = alloca ptr, align 8
  %options = alloca ptr, align 8
  store ptr null, ptr %obj, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3843, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_blockdev_ref) #31
  unreachable

do.end:                                           ; preds = %entry
  %0 = load i32, ptr %ref, align 8
  %cmp = icmp eq i32 %0, 3
  %u = getelementptr inbounds %struct.BlockdevRef, ptr %ref, i64 0, i32 1
  br i1 %cmp, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.end
  %1 = load ptr, ptr %u, align 8
  br label %if.end12

if.else2:                                         ; preds = %do.end
  store ptr %u, ptr %options, align 8
  %cmp5 = icmp eq i32 %0, 4
  br i1 %cmp5, label %if.end8, label %if.else7

if.else7:                                         ; preds = %if.else2
  tail call void @__assert_fail(ptr noundef nonnull @.str.81, ptr noundef nonnull @.str.2, i32 noundef 3849, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open_blockdev_ref) #31
  unreachable

if.end8:                                          ; preds = %if.else2
  %call9 = call ptr @qobject_output_visitor_new(ptr noundef nonnull %obj) #29
  %call10 = call zeroext i1 @visit_type_BlockdevOptions(ptr noundef %call9, ptr noundef null, ptr noundef nonnull %options, ptr noundef nonnull @error_abort) #29
  call void @visit_complete(ptr noundef %call9, ptr noundef nonnull %obj) #29
  %2 = load ptr, ptr %obj, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %if.else.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end8
  %obj.val.i = load i32, ptr %2, align 8
  %3 = add i32 %obj.val.i, -1
  %or.cond.i.i = icmp ult i32 %3, 6
  br i1 %or.cond.i.i, label %qobject_type.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i
  call void @__assert_fail(ptr noundef nonnull @.str.218, ptr noundef nonnull @.str.161, i32 noundef 126, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_type) #31
  unreachable

qobject_type.exit.i:                              ; preds = %land.lhs.true.i
  %cmp.i = icmp eq i32 %obj.val.i, 4
  br i1 %cmp.i, label %qobject_check_type.exit, label %if.else.i

if.else.i:                                        ; preds = %qobject_type.exit.i, %if.end8
  br label %qobject_check_type.exit

qobject_check_type.exit:                          ; preds = %qobject_type.exit.i, %if.else.i
  %retval.0.i = phi ptr [ null, %if.else.i ], [ %2, %qobject_type.exit.i ]
  call void @qdict_flatten(ptr noundef %retval.0.i) #29
  call void @qdict_set_default_str(ptr noundef %retval.0.i, ptr noundef nonnull @.str.47, ptr noundef nonnull @.str.34) #29
  call void @qdict_set_default_str(ptr noundef %retval.0.i, ptr noundef nonnull @.str.49, ptr noundef nonnull @.str.34) #29
  call void @qdict_set_default_str(ptr noundef %retval.0.i, ptr noundef nonnull @.str.51, ptr noundef nonnull @.str.34) #29
  call void @qdict_set_default_str(ptr noundef %retval.0.i, ptr noundef nonnull @.str.53, ptr noundef nonnull @.str.34) #29
  br label %if.end12

if.end12:                                         ; preds = %qobject_check_type.exit, %if.then1
  %v.0 = phi ptr [ null, %if.then1 ], [ %call9, %qobject_check_type.exit ]
  %reference.0 = phi ptr [ %1, %if.then1 ], [ null, %qobject_check_type.exit ]
  %qdict.0 = phi ptr [ null, %if.then1 ], [ %retval.0.i, %qobject_check_type.exit ]
  %call13 = call ptr @bdrv_open_inherit(ptr noundef null, ptr noundef %reference.0, ptr noundef %qdict.0, i32 noundef 0, ptr noundef null, ptr noundef null, i32 noundef 0, ptr noundef %errp)
  store ptr null, ptr %obj, align 8
  call void @visit_free(ptr noundef %v.0) #29
  ret ptr %call13
}

declare ptr @qobject_output_visitor_new(ptr noundef) local_unnamed_addr #5

declare zeroext i1 @visit_type_BlockdevOptions(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @visit_complete(ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @qdict_flatten(ptr noundef) local_unnamed_addr #5

declare void @qdict_set_default_str(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @visit_free(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_open(ptr noundef %filename, ptr noundef %reference, ptr noundef %options, i32 noundef %flags, ptr noundef %errp) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4270, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call ptr @bdrv_open_inherit(ptr noundef %filename, ptr noundef %reference, ptr noundef %options, i32 noundef %flags, ptr noundef null, ptr noundef null, i32 noundef 0, ptr noundef %errp)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_reopen_queue(ptr noundef %bs_queue, ptr noundef %bs, ptr noundef %options, i1 noundef zeroext %keep_old_opts) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4530, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_queue) #31
  unreachable

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2 = tail call fastcc ptr @bdrv_reopen_queue_child(ptr noundef %bs_queue, ptr noundef %bs, ptr noundef %options, ptr noundef null, i32 noundef 0, i1 noundef zeroext false, ptr noundef null, i32 noundef 0, i1 noundef zeroext %keep_old_opts)
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret ptr %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_reopen_queue_child(ptr noundef %bs_queue, ptr noundef %bs, ptr noundef %options, ptr nocapture noundef readonly %klass, i32 noundef %role, i1 noundef zeroext %parent_is_format, ptr noundef %parent_options, i32 noundef %parent_flags, i1 noundef zeroext %keep_old_opts) unnamed_addr #4 {
entry:
  %flags = alloca i32, align 4
  %new_child_options = alloca ptr, align 8
  %cmp.not = icmp eq ptr %bs, null
  br i1 %cmp.not, label %if.else, label %do.body

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.22, ptr noundef nonnull @.str.2, i32 noundef 4375, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_queue_child) #31
  unreachable

do.body:                                          ; preds = %entry
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else3

if.else3:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4383, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_queue_child) #31
  unreachable

do.end:                                           ; preds = %do.body
  tail call void @bdrv_drained_begin(ptr noundef nonnull %bs) #29
  %cmp5 = icmp eq ptr %bs_queue, null
  br i1 %cmp5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %do.end
  %call7 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 16) #32
  store ptr null, ptr %call7, align 8
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %call7, i64 0, i32 1
  store ptr %call7, ptr %tql_prev, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then6, %do.end
  %bs_queue.addr.0 = phi ptr [ %call7, %if.then6 ], [ %bs_queue, %do.end ]
  %tobool.not = icmp eq ptr %options, null
  br i1 %tobool.not, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end10
  %call12 = tail call ptr @qdict_new() #29
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end10
  %options.addr.0 = phi ptr [ %options, %if.end10 ], [ %call12, %if.then11 ]
  %bs_entry.0135 = load ptr, ptr %bs_queue.addr.0, align 8
  %tobool14.not136 = icmp eq ptr %bs_entry.0135, null
  br i1 %tobool14.not136, label %lor.lhs.false.critedge, label %for.body

for.body:                                         ; preds = %if.end13, %for.inc
  %bs_entry.0137 = phi ptr [ %bs_entry.0, %for.inc ], [ %bs_entry.0135, %if.end13 ]
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0137, i64 0, i32 1
  %0 = load ptr, ptr %state, align 8
  %cmp16 = icmp eq ptr %0, %bs
  br i1 %cmp16, label %if.then22, label %for.inc

for.inc:                                          ; preds = %for.body
  %entry19 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0137, i64 0, i32 2
  %bs_entry.0 = load ptr, ptr %entry19, align 8
  %tobool14.not = icmp eq ptr %bs_entry.0, null
  br i1 %tobool14.not, label %lor.lhs.false.critedge, label %for.body, !llvm.loop !36

lor.lhs.false.critedge:                           ; preds = %for.inc, %if.end13
  br i1 %keep_old_opts, label %1, label %if.end34

if.then22:                                        ; preds = %for.body
  %explicit_options25 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0137, i64 0, i32 1, i32 7
  br label %2

1:                                                ; preds = %lor.lhs.false.critedge
  %explicit_options26150 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 34
  br label %2

2:                                                ; preds = %if.then22, %1
  %tobool14.not130153 = phi i1 [ true, %1 ], [ false, %if.then22 ]
  %bs_entry.0134151 = phi ptr [ null, %1 ], [ %bs_entry.0137, %if.then22 ]
  %3 = phi ptr [ %explicit_options26150, %1 ], [ %explicit_options25, %if.then22 ]
  %cond = load ptr, ptr %3, align 8
  %call27 = tail call ptr @qdict_clone_shallow(ptr noundef %cond) #29
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %2
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1091, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_join_options) #31
  unreachable

do.end.i:                                         ; preds = %2
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %4 = load ptr, ptr %drv.i, align 8
  %tobool.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i, label %if.else6.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %do.end.i
  %bdrv_join_options.i = getelementptr inbounds %struct.BlockDriver, ptr %4, i64 0, i32 22
  %5 = load ptr, ptr %bdrv_join_options.i, align 8
  %tobool2.not.i = icmp eq ptr %5, null
  br i1 %tobool2.not.i, label %if.else6.i, label %if.then3.i

if.then3.i:                                       ; preds = %land.lhs.true.i
  tail call void %5(ptr noundef %options.addr.0, ptr noundef %call27) #29
  br label %bdrv_join_options.exit

if.else6.i:                                       ; preds = %land.lhs.true.i, %do.end.i
  tail call void @qdict_join(ptr noundef %options.addr.0, ptr noundef %call27, i1 noundef zeroext false) #29
  br label %bdrv_join_options.exit

bdrv_join_options.exit:                           ; preds = %if.then3.i, %if.else6.i
  %tobool28.not = icmp eq ptr %call27, null
  br i1 %tobool28.not, label %if.end34, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %bdrv_join_options.exit
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %call27, i64 0, i32 1
  %6 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %6, 0
  br i1 %tobool1.not.i, label %if.else.i81, label %land.lhs.true.i80

if.else.i81:                                      ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i80:                                ; preds = %lor.lhs.false.i
  %dec.i = add i64 %6, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %if.end34

if.then5.i:                                       ; preds = %land.lhs.true.i80
  tail call void @qobject_destroy(ptr noundef nonnull %call27) #29
  br label %if.end34

if.end34:                                         ; preds = %if.then5.i, %land.lhs.true.i80, %bdrv_join_options.exit, %lor.lhs.false.critedge
  %bs_entry.0133 = phi ptr [ %bs_entry.0134151, %if.then5.i ], [ %bs_entry.0134151, %land.lhs.true.i80 ], [ %bs_entry.0134151, %bdrv_join_options.exit ], [ null, %lor.lhs.false.critedge ]
  %tobool14.not131 = phi i1 [ %tobool14.not130153, %if.then5.i ], [ %tobool14.not130153, %land.lhs.true.i80 ], [ %tobool14.not130153, %bdrv_join_options.exit ], [ true, %lor.lhs.false.critedge ]
  %call35 = tail call ptr @qdict_clone_shallow(ptr noundef %options.addr.0) #29
  %tobool36.not = icmp eq ptr %parent_options, null
  br i1 %tobool36.not, label %if.else39, label %if.then37

if.then37:                                        ; preds = %if.end34
  store i32 0, ptr %flags, align 4
  %inherit_options = getelementptr inbounds %struct.BdrvChildClass, ptr %klass, i64 0, i32 2
  %7 = load ptr, ptr %inherit_options, align 8
  call void %7(i32 noundef %role, i1 noundef zeroext %parent_is_format, ptr noundef nonnull %flags, ptr noundef %options.addr.0, i32 noundef %parent_flags, ptr noundef nonnull %parent_options) #29
  br label %if.end41

if.else39:                                        ; preds = %if.end34
  %8 = load i32, ptr %bs, align 8
  store i32 %8, ptr %flags, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.else39, %if.then37
  br i1 %keep_old_opts, label %if.then43, label %if.end56

if.then43:                                        ; preds = %if.end41
  %options44 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 33
  %9 = load ptr, ptr %options44, align 8
  %call45 = call ptr @qdict_clone_shallow(ptr noundef %9) #29
  %call.i82 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i82, label %do.end.i84, label %if.else.i83

if.else.i83:                                      ; preds = %if.then43
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1091, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_join_options) #31
  unreachable

do.end.i84:                                       ; preds = %if.then43
  %drv.i85 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %10 = load ptr, ptr %drv.i85, align 8
  %tobool.not.i86 = icmp eq ptr %10, null
  br i1 %tobool.not.i86, label %if.else6.i91, label %land.lhs.true.i87

land.lhs.true.i87:                                ; preds = %do.end.i84
  %bdrv_join_options.i88 = getelementptr inbounds %struct.BlockDriver, ptr %10, i64 0, i32 22
  %11 = load ptr, ptr %bdrv_join_options.i88, align 8
  %tobool2.not.i89 = icmp eq ptr %11, null
  br i1 %tobool2.not.i89, label %if.else6.i91, label %if.then3.i90

if.then3.i90:                                     ; preds = %land.lhs.true.i87
  call void %11(ptr noundef %options.addr.0, ptr noundef %call45) #29
  br label %bdrv_join_options.exit92

if.else6.i91:                                     ; preds = %land.lhs.true.i87, %do.end.i84
  call void @qdict_join(ptr noundef %options.addr.0, ptr noundef %call45, i1 noundef zeroext false) #29
  br label %bdrv_join_options.exit92

bdrv_join_options.exit92:                         ; preds = %if.then3.i90, %if.else6.i91
  %tobool47.not = icmp eq ptr %call45, null
  br i1 %tobool47.not, label %if.end56, label %lor.lhs.false.i93

lor.lhs.false.i93:                                ; preds = %bdrv_join_options.exit92
  %refcnt.i94 = getelementptr inbounds %struct.QObjectBase_, ptr %call45, i64 0, i32 1
  %12 = load i64, ptr %refcnt.i94, align 8
  %tobool1.not.i95 = icmp eq i64 %12, 0
  br i1 %tobool1.not.i95, label %if.else.i100, label %land.lhs.true.i96

if.else.i100:                                     ; preds = %lor.lhs.false.i93
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i96:                                ; preds = %lor.lhs.false.i93
  %dec.i97 = add i64 %12, -1
  store i64 %dec.i97, ptr %refcnt.i94, align 8
  %cmp.i98 = icmp eq i64 %dec.i97, 0
  br i1 %cmp.i98, label %if.then5.i99, label %if.end56

if.then5.i99:                                     ; preds = %land.lhs.true.i96
  call void @qobject_destroy(ptr noundef nonnull %call45) #29
  br label %if.end56

if.end56:                                         ; preds = %if.then5.i99, %land.lhs.true.i96, %bdrv_join_options.exit92, %if.end41
  %call57 = call ptr @qdict_clone_shallow(ptr noundef %options.addr.0) #29
  %call58 = call ptr @qemu_opts_create(ptr noundef nonnull @bdrv_runtime_opts, ptr noundef null, i32 noundef 0, ptr noundef nonnull @error_abort) #29
  %call59 = call zeroext i1 @qemu_opts_absorb_qdict(ptr noundef %call58, ptr noundef %call57, ptr noundef null) #29
  call fastcc void @update_flags_from_options(ptr noundef nonnull %flags, ptr noundef %call58)
  call void @qemu_opts_del(ptr noundef %call58) #29
  %tobool61.not = icmp eq ptr %call57, null
  br i1 %tobool61.not, label %qobject_unref_impl.exit110, label %lor.lhs.false.i102

lor.lhs.false.i102:                               ; preds = %if.end56
  %refcnt.i103 = getelementptr inbounds %struct.QObjectBase_, ptr %call57, i64 0, i32 1
  %13 = load i64, ptr %refcnt.i103, align 8
  %tobool1.not.i104 = icmp eq i64 %13, 0
  br i1 %tobool1.not.i104, label %if.else.i109, label %land.lhs.true.i105

if.else.i109:                                     ; preds = %lor.lhs.false.i102
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i105:                               ; preds = %lor.lhs.false.i102
  %dec.i106 = add i64 %13, -1
  store i64 %dec.i106, ptr %refcnt.i103, align 8
  %cmp.i107 = icmp eq i64 %dec.i106, 0
  br i1 %cmp.i107, label %if.then5.i108, label %qobject_unref_impl.exit110

if.then5.i108:                                    ; preds = %land.lhs.true.i105
  call void @qobject_destroy(ptr noundef nonnull %call57) #29
  br label %qobject_unref_impl.exit110

qobject_unref_impl.exit110:                       ; preds = %if.end56, %land.lhs.true.i105, %if.then5.i108
  %14 = load i32, ptr %flags, align 4
  %and = and i32 %14, -32769
  %and70 = shl i32 %14, 12
  %15 = and i32 %and70, 8192
  %storemerge = or i32 %15, %and
  store i32 %storemerge, ptr %flags, align 4
  br i1 %tobool14.not131, label %if.then75, label %if.else86

if.then75:                                        ; preds = %qobject_unref_impl.exit110
  %call76 = call noalias dereferenceable_or_null(88) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 88) #32
  %entry78 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %call76, i64 0, i32 2
  store ptr null, ptr %entry78, align 8
  %tql_prev79 = getelementptr inbounds %struct.QTailQLink, ptr %bs_queue.addr.0, i64 0, i32 1
  %16 = load ptr, ptr %tql_prev79, align 8
  %tql_prev81 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %call76, i64 0, i32 2, i32 0, i32 1
  store ptr %16, ptr %tql_prev81, align 8
  store ptr %call76, ptr %16, align 8
  store ptr %entry78, ptr %tql_prev79, align 8
  br label %if.end111

if.else86:                                        ; preds = %qobject_unref_impl.exit110
  %options88 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0133, i64 0, i32 1, i32 6
  %17 = load ptr, ptr %options88, align 8
  %tobool90.not = icmp eq ptr %17, null
  br i1 %tobool90.not, label %qobject_unref_impl.exit119, label %lor.lhs.false.i111

lor.lhs.false.i111:                               ; preds = %if.else86
  %refcnt.i112 = getelementptr inbounds %struct.QObjectBase_, ptr %17, i64 0, i32 1
  %18 = load i64, ptr %refcnt.i112, align 8
  %tobool1.not.i113 = icmp eq i64 %18, 0
  br i1 %tobool1.not.i113, label %if.else.i118, label %land.lhs.true.i114

if.else.i118:                                     ; preds = %lor.lhs.false.i111
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i114:                               ; preds = %lor.lhs.false.i111
  %dec.i115 = add i64 %18, -1
  store i64 %dec.i115, ptr %refcnt.i112, align 8
  %cmp.i116 = icmp eq i64 %dec.i115, 0
  br i1 %cmp.i116, label %if.then5.i117, label %qobject_unref_impl.exit119

if.then5.i117:                                    ; preds = %land.lhs.true.i114
  call void @qobject_destroy(ptr noundef nonnull %17) #29
  br label %qobject_unref_impl.exit119

qobject_unref_impl.exit119:                       ; preds = %if.else86, %land.lhs.true.i114, %if.then5.i117
  %explicit_options100 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0133, i64 0, i32 1, i32 7
  %19 = load ptr, ptr %explicit_options100, align 8
  %tobool102.not = icmp eq ptr %19, null
  br i1 %tobool102.not, label %if.end111, label %lor.lhs.false.i120

lor.lhs.false.i120:                               ; preds = %qobject_unref_impl.exit119
  %refcnt.i121 = getelementptr inbounds %struct.QObjectBase_, ptr %19, i64 0, i32 1
  %20 = load i64, ptr %refcnt.i121, align 8
  %tobool1.not.i122 = icmp eq i64 %20, 0
  br i1 %tobool1.not.i122, label %if.else.i127, label %land.lhs.true.i123

if.else.i127:                                     ; preds = %lor.lhs.false.i120
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i123:                               ; preds = %lor.lhs.false.i120
  %dec.i124 = add i64 %20, -1
  store i64 %dec.i124, ptr %refcnt.i121, align 8
  %cmp.i125 = icmp eq i64 %dec.i124, 0
  br i1 %cmp.i125, label %if.then5.i126, label %if.end111

if.then5.i126:                                    ; preds = %land.lhs.true.i123
  call void @qobject_destroy(ptr noundef nonnull %19) #29
  br label %if.end111

if.end111:                                        ; preds = %if.then5.i126, %land.lhs.true.i123, %qobject_unref_impl.exit119, %if.then75
  %bs_entry.1 = phi ptr [ %call76, %if.then75 ], [ %bs_entry.0133, %qobject_unref_impl.exit119 ], [ %bs_entry.0133, %land.lhs.true.i123 ], [ %bs_entry.0133, %if.then5.i126 ]
  %state112 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1, i64 0, i32 1
  store ptr %bs, ptr %state112, align 8
  %options115 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1, i64 0, i32 1, i32 6
  store ptr %options.addr.0, ptr %options115, align 8
  %explicit_options117 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1, i64 0, i32 1, i32 7
  store ptr %call35, ptr %explicit_options117, align 8
  %21 = load i32, ptr %flags, align 4
  %flags119 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1, i64 0, i32 1, i32 1
  store i32 %21, ptr %flags119, align 8
  br i1 %keep_old_opts, label %if.end128, label %if.then121

if.then121:                                       ; preds = %if.end111
  %call122 = call i32 @qdict_haskey(ptr noundef %options.addr.0, ptr noundef nonnull @.str.89) #29
  %tobool123.not = icmp eq i32 %call122, 0
  br i1 %tobool123.not, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then121
  %call124 = call i32 @qdict_haskey(ptr noundef %options.addr.0, ptr noundef nonnull @.str.256) #29
  %tobool125.not = icmp eq i32 %call124, 0
  %22 = zext i1 %tobool125.not to i8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then121
  %frombool127 = phi i8 [ 0, %if.then121 ], [ %22, %land.rhs ]
  %backing_missing = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1, i64 0, i32 1, i32 3
  store i8 %frombool127, ptr %backing_missing, align 8
  br label %if.end128

if.end128:                                        ; preds = %land.end, %if.end111
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.0140 = load ptr, ptr %children, align 8
  %tobool130.not141 = icmp eq ptr %child.0140, null
  br i1 %tobool130.not141, label %for.end159, label %for.body131.lr.ph

for.body131.lr.ph:                                ; preds = %if.end128
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  br label %for.body131

for.body131:                                      ; preds = %for.body131.lr.ph, %for.inc158
  %child.0142 = phi ptr [ %child.0140, %for.body131.lr.ph ], [ %child.0, %for.inc158 ]
  store ptr null, ptr %new_child_options, align 8
  %23 = load ptr, ptr %child.0142, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %23, i64 0, i32 28
  %24 = load ptr, ptr %inherits_from, align 8
  %cmp135.not = icmp eq ptr %24, %bs
  br i1 %cmp135.not, label %if.end137, label %for.inc158

if.end137:                                        ; preds = %for.body131
  %name = getelementptr inbounds %struct.BdrvChild, ptr %child.0142, i64 0, i32 1
  %25 = load ptr, ptr %name, align 8
  %call138 = call i32 @qdict_haskey(ptr noundef %options.addr.0, ptr noundef %25) #29
  %tobool139.not = icmp eq i32 %call138, 0
  %26 = load ptr, ptr %name, align 8
  br i1 %tobool139.not, label %if.else148, label %if.then140

if.then140:                                       ; preds = %if.end137
  %call142 = call ptr @qdict_get_try_str(ptr noundef %options.addr.0, ptr noundef %26) #29
  %27 = load ptr, ptr %child.0142, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %27, i64 0, i32 22
  %call144 = call i32 @g_strcmp0(ptr noundef %call142, ptr noundef nonnull %node_name) #29
  %tobool145.not = icmp eq i32 %call144, 0
  br i1 %tobool145.not, label %if.end151, label %for.inc158

if.else148:                                       ; preds = %if.end137
  %call150 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef nonnull @.str.76, ptr noundef %26) #29
  call void @qdict_extract_subqdict(ptr noundef %call35, ptr noundef null, ptr noundef %call150) #29
  call void @qdict_extract_subqdict(ptr noundef %options.addr.0, ptr noundef nonnull %new_child_options, ptr noundef %call150) #29
  call void @g_free(ptr noundef %call150) #29
  br label %if.end151

if.end151:                                        ; preds = %if.then140, %if.else148
  %child_keep_old.0 = phi i1 [ %keep_old_opts, %if.else148 ], [ true, %if.then140 ]
  %28 = load ptr, ptr %child.0142, align 8
  %29 = load ptr, ptr %new_child_options, align 8
  %klass153 = getelementptr inbounds %struct.BdrvChild, ptr %child.0142, i64 0, i32 2
  %30 = load ptr, ptr %klass153, align 8
  %role154 = getelementptr inbounds %struct.BdrvChild, ptr %child.0142, i64 0, i32 3
  %31 = load i32, ptr %role154, align 8
  %32 = load ptr, ptr %drv, align 8
  %is_format = getelementptr inbounds %struct.BlockDriver, ptr %32, i64 0, i32 4
  %33 = load i8, ptr %is_format, align 2
  %34 = and i8 %33, 1
  %tobool155 = icmp ne i8 %34, 0
  %35 = load i32, ptr %flags, align 4
  %call157 = call fastcc ptr @bdrv_reopen_queue_child(ptr noundef nonnull %bs_queue.addr.0, ptr noundef %28, ptr noundef %29, ptr noundef %30, i32 noundef %31, i1 noundef zeroext %tobool155, ptr noundef %options.addr.0, i32 noundef %35, i1 noundef zeroext %child_keep_old.0)
  br label %for.inc158

for.inc158:                                       ; preds = %if.then140, %for.body131, %if.end151
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.0142, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool130.not = icmp eq ptr %child.0, null
  br i1 %tobool130.not, label %for.end159, label %for.body131, !llvm.loop !37

for.end159:                                       ; preds = %for.inc158, %if.end128
  ret ptr %bs_queue.addr.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_reopen_queue_free(ptr noundef %bs_queue) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4539, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_queue_free) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %bs_queue, null
  br i1 %tobool.not, label %if.end21, label %if.then1

if.then1:                                         ; preds = %do.end
  %0 = load ptr, ptr %bs_queue, align 8
  %tobool2.not22 = icmp eq ptr %0, null
  br i1 %tobool2.not22, label %for.end, label %land.rhs

land.rhs:                                         ; preds = %if.then1, %qobject_unref_impl.exit21
  %bs_entry.023 = phi ptr [ %1, %qobject_unref_impl.exit21 ], [ %0, %if.then1 ]
  %entry3 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.023, i64 0, i32 2
  %1 = load ptr, ptr %entry3, align 8
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.023, i64 0, i32 1
  %2 = load ptr, ptr %state, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %land.rhs
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %2, i64 0, i32 8
  %3 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %land.rhs
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %3, %cond.true.i ], [ %call.i, %cond.false.i ]
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  %4 = load ptr, ptr %state, align 8
  tail call void @bdrv_drained_end(ptr noundef %4) #29
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  %explicit_options = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.023, i64 0, i32 1, i32 7
  %5 = load ptr, ptr %explicit_options, align 8
  %tobool8.not = icmp eq ptr %5, null
  br i1 %tobool8.not, label %qobject_unref_impl.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %bdrv_get_aio_context.exit
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %5, i64 0, i32 1
  %6 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %6, 0
  br i1 %tobool1.not.i, label %if.else.i, label %land.lhs.true.i

if.else.i:                                        ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %6, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %qobject_unref_impl.exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  tail call void @qobject_destroy(ptr noundef nonnull %5) #29
  br label %qobject_unref_impl.exit

qobject_unref_impl.exit:                          ; preds = %bdrv_get_aio_context.exit, %land.lhs.true.i, %if.then5.i
  %options = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.023, i64 0, i32 1, i32 6
  %7 = load ptr, ptr %options, align 8
  %tobool12.not = icmp eq ptr %7, null
  br i1 %tobool12.not, label %qobject_unref_impl.exit21, label %lor.lhs.false.i13

lor.lhs.false.i13:                                ; preds = %qobject_unref_impl.exit
  %refcnt.i14 = getelementptr inbounds %struct.QObjectBase_, ptr %7, i64 0, i32 1
  %8 = load i64, ptr %refcnt.i14, align 8
  %tobool1.not.i15 = icmp eq i64 %8, 0
  br i1 %tobool1.not.i15, label %if.else.i20, label %land.lhs.true.i16

if.else.i20:                                      ; preds = %lor.lhs.false.i13
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i16:                                ; preds = %lor.lhs.false.i13
  %dec.i17 = add i64 %8, -1
  store i64 %dec.i17, ptr %refcnt.i14, align 8
  %cmp.i18 = icmp eq i64 %dec.i17, 0
  br i1 %cmp.i18, label %if.then5.i19, label %qobject_unref_impl.exit21

if.then5.i19:                                     ; preds = %land.lhs.true.i16
  tail call void @qobject_destroy(ptr noundef nonnull %7) #29
  br label %qobject_unref_impl.exit21

qobject_unref_impl.exit21:                        ; preds = %qobject_unref_impl.exit, %land.lhs.true.i16, %if.then5.i19
  tail call void @g_free(ptr noundef nonnull %bs_entry.023) #29
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %for.end, label %land.rhs, !llvm.loop !38

for.end:                                          ; preds = %qobject_unref_impl.exit21, %if.then1
  tail call void @g_free(ptr noundef nonnull %bs_queue) #29
  br label %if.end21

if.end21:                                         ; preds = %for.end, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_reopen_multiple(ptr noundef %bs_queue, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %local_err.i = alloca ptr, align 8
  %call = tail call ptr @tran_new() #29
  %call1 = tail call ptr @qemu_get_current_aio_context() #29
  %call2 = tail call ptr @qemu_get_aio_context() #29
  %cmp = icmp eq ptr %call1, %call2
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.82, ptr noundef nonnull @.str.2, i32 noundef 4584, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #31
  unreachable

if.end:                                           ; preds = %entry
  %cmp3.not = icmp eq ptr %bs_queue, null
  br i1 %cmp3.not, label %if.else5, label %do.body

if.else5:                                         ; preds = %if.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.83, ptr noundef nonnull @.str.2, i32 noundef 4585, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #31
  unreachable

do.body:                                          ; preds = %if.end
  %call7 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call7, label %for.cond.preheader, label %if.else9

for.cond.preheader:                               ; preds = %do.body
  %bs_entry.0154 = load ptr, ptr %bs_queue, align 8
  %tobool.not155 = icmp eq ptr %bs_entry.0154, null
  br i1 %tobool.not155, label %for.end58, label %for.body

if.else9:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4586, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #31
  unreachable

for.cond:                                         ; preds = %bdrv_get_aio_context.exit
  %entry18 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0156, i64 0, i32 2
  %bs_entry.0 = load ptr, ptr %entry18, align 8
  %tobool.not = icmp eq ptr %bs_entry.0, null
  br i1 %tobool.not, label %for.cond19.preheader, label %for.body, !llvm.loop !39

for.cond19.preheader:                             ; preds = %for.cond
  %bs_entry.1157.pre = load ptr, ptr %bs_queue, align 8
  %tobool20.not158 = icmp eq ptr %bs_entry.1157.pre, null
  br i1 %tobool20.not158, label %for.end58, label %for.body21

for.body:                                         ; preds = %for.cond.preheader, %for.cond
  %bs_entry.0156 = phi ptr [ %bs_entry.0, %for.cond ], [ %bs_entry.0154, %for.cond.preheader ]
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.0156, i64 0, i32 1
  %0 = load ptr, ptr %state, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %for.body
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 8
  %1 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %for.body
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %1, %cond.true.i ], [ %call.i, %cond.false.i ]
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  %2 = load ptr, ptr %state, align 8
  %call14 = tail call i32 @bdrv_flush(ptr noundef %2) #29
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %if.then16, label %for.cond

if.then16:                                        ; preds = %bdrv_get_aio_context.exit
  %sub = sub i32 0, %call14
  tail call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4594, ptr noundef nonnull @__func__.bdrv_reopen_multiple, i32 noundef %sub, ptr noundef nonnull @.str.84) #29
  br label %abort

for.cond39.preheader:                             ; preds = %if.end35
  %bs_entry.2164.pre = load ptr, ptr %bs_queue, align 8
  %tobool40.not165 = icmp eq ptr %bs_entry.2164.pre, null
  br i1 %tobool40.not165, label %for.end58, label %for.body41

for.body21:                                       ; preds = %for.cond19.preheader, %if.end35
  %bs_entry.1159 = phi ptr [ %bs_entry.1, %if.end35 ], [ %bs_entry.1157.pre, %for.cond19.preheader ]
  %state22 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1159, i64 0, i32 1
  %3 = load ptr, ptr %state22, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %3, i64 0, i32 46
  %4 = load i32, ptr %quiesce_counter, align 8
  %cmp24 = icmp sgt i32 %4, 0
  br i1 %cmp24, label %bdrv_get_aio_context.exit67, label %if.else26

if.else26:                                        ; preds = %for.body21
  call void @__assert_fail(ptr noundef nonnull @.str.85, ptr noundef nonnull @.str.2, i32 noundef 4600, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #31
  unreachable

bdrv_get_aio_context.exit67:                      ; preds = %for.body21
  %aio_context.i63 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i64 0, i32 8
  %5 = load ptr, ptr %aio_context.i63, align 8
  call void @aio_context_acquire(ptr noundef %5) #29
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %local_err.i)
  store ptr null, ptr %local_err.i, align 8
  %6 = load ptr, ptr %state22, align 8
  %drv1.i = getelementptr inbounds %struct.BlockDriverState, ptr %6, i64 0, i32 6
  %7 = load ptr, ptr %drv1.i, align 8
  %cmp2.not.i = icmp eq ptr %7, null
  br i1 %cmp2.not.i, label %if.else4.i, label %do.body.i

if.else4.i:                                       ; preds = %bdrv_get_aio_context.exit67
  call void @__assert_fail(ptr noundef nonnull @.str.258, ptr noundef nonnull @.str.2, i32 noundef 4915, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #31
  unreachable

do.body.i:                                        ; preds = %bdrv_get_aio_context.exit67
  %call.i68 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i68, label %do.end.i, label %if.else7.i

if.else7.i:                                       ; preds = %do.body.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4916, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #31
  unreachable

do.end.i:                                         ; preds = %do.body.i
  %8 = load ptr, ptr %state22, align 8
  %drv10.i = getelementptr inbounds %struct.BlockDriverState, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %drv10.i, align 8
  %options.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1159, i64 0, i32 1, i32 6
  %10 = load ptr, ptr %options.i, align 8
  %call11.i = call ptr @qdict_clone_shallow(ptr noundef %10) #29
  %call12.i = call ptr @qemu_opts_create(ptr noundef nonnull @bdrv_runtime_opts, ptr noundef null, i32 noundef 0, ptr noundef nonnull @error_abort) #29
  %11 = load ptr, ptr %options.i, align 8
  %call14.i = call zeroext i1 @qemu_opts_absorb_qdict(ptr noundef %call12.i, ptr noundef %11, ptr noundef %errp) #29
  br i1 %call14.i, label %if.end16.i, label %if.end162.i

if.end16.i:                                       ; preds = %do.end.i
  %flags.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1159, i64 0, i32 1, i32 1
  %12 = load i32, ptr %flags.i, align 8
  call fastcc void @update_flags_from_options(ptr noundef nonnull %flags.i, ptr noundef %call12.i)
  %13 = load i32, ptr %flags.i, align 8
  %cmp19.i = icmp eq i32 %12, %13
  br i1 %cmp19.i, label %if.end22.i, label %if.else21.i

if.else21.i:                                      ; preds = %if.end16.i
  call void @__assert_fail(ptr noundef nonnull @.str.259, ptr noundef nonnull @.str.2, i32 noundef 4936, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #31
  unreachable

if.end22.i:                                       ; preds = %if.end16.i
  %call23.i = call ptr @qemu_opt_get_del(ptr noundef %call12.i, ptr noundef nonnull @.str.57) #29
  %cmp24.not.i = icmp eq ptr %call23.i, null
  br i1 %cmp24.not.i, label %if.end22.if.end31_crit_edge.i, label %if.then25.i

if.end22.if.end31_crit_edge.i:                    ; preds = %if.end22.i
  %.pre.i = load i32, ptr %flags.i, align 8
  br label %if.end31.i

if.then25.i:                                      ; preds = %if.end22.i
  %14 = load i32, ptr %flags.i, align 4
  %and.i.i = and i32 %14, -16385
  store i32 %and.i.i, ptr %flags.i, align 4
  %call.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call23.i, ptr noundef nonnull dereferenceable(4) @.str.34) #28
  %tobool.not.i.i = icmp eq i32 %call.i.i, 0
  br i1 %tobool.not.i.i, label %if.end31.i, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then25.i
  %call1.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call23.i, ptr noundef nonnull dereferenceable(7) @.str.35) #28
  %tobool2.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool2.not.i.i, label %if.end31.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %lor.lhs.false.i.i
  %call3.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call23.i, ptr noundef nonnull dereferenceable(3) @.str.36) #28
  %tobool4.not.i.i = icmp eq i32 %call3.i.i, 0
  br i1 %tobool4.not.i.i, label %if.then8.i.i, label %lor.lhs.false5.i.i

lor.lhs.false5.i.i:                               ; preds = %if.else.i.i
  %call6.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call23.i, ptr noundef nonnull dereferenceable(6) @.str.37) #28
  %tobool7.not.i.i = icmp eq i32 %call6.i.i, 0
  br i1 %tobool7.not.i.i, label %if.then8.i.i, label %if.then29.i

if.then8.i.i:                                     ; preds = %lor.lhs.false5.i.i, %if.else.i.i
  %or.i.i = or i32 %14, 16384
  store i32 %or.i.i, ptr %flags.i, align 4
  br label %if.end31.i

if.then29.i:                                      ; preds = %lor.lhs.false5.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4941, ptr noundef nonnull @__func__.bdrv_reopen_prepare, ptr noundef nonnull @.str.247) #29
  br label %if.end162.i

if.end31.i:                                       ; preds = %if.then8.i.i, %lor.lhs.false.i.i, %if.then25.i, %if.end22.if.end31_crit_edge.i
  %15 = phi i32 [ %.pre.i, %if.end22.if.end31_crit_edge.i ], [ %or.i.i, %if.then8.i.i ], [ %and.i.i, %lor.lhs.false.i.i ], [ %and.i.i, %if.then25.i ]
  %call33.i = call fastcc i32 @bdrv_parse_detect_zeroes(ptr noundef %call12.i, i32 noundef %15, ptr noundef nonnull %local_err.i)
  %detect_zeroes.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1159, i64 0, i32 1, i32 2
  store i32 %call33.i, ptr %detect_zeroes.i, align 4
  %16 = load ptr, ptr %local_err.i, align 8
  %tobool.not.i69 = icmp eq ptr %16, null
  br i1 %tobool.not.i69, label %if.end35.i, label %if.then34.i

if.then34.i:                                      ; preds = %if.end31.i
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %16) #29
  br label %if.end162.i

if.end35.i:                                       ; preds = %if.end31.i
  %17 = load ptr, ptr %options.i, align 8
  %call37.i = call ptr @qemu_opts_to_qdict(ptr noundef %call12.i, ptr noundef %17) #29
  %18 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %18, 2
  %tobool39.not.i = icmp eq i32 %and.i, 0
  call void @bdrv_graph_rdlock_main_loop() #29
  %19 = load ptr, ptr %state22, align 8
  %copy_on_read.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %19, i64 0, i32 42
  %20 = load i32, ptr %copy_on_read.i.i, align 8
  %tobool.not.i85.i = icmp ne i32 %20, 0
  %brmerge.not.i.i = and i1 %tobool39.not.i, %tobool.not.i85.i
  br i1 %brmerge.not.i.i, label %if.then.i.i, label %bdrv_can_set_read_only.exit.i

if.then.i.i:                                      ; preds = %if.end35.i
  %parents.i.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %19, i64 0, i32 32
  %c.07.i.i.i.i = load ptr, ptr %parents.i.i.i.i, align 8
  %tobool.not8.i.i.i.i = icmp eq ptr %c.07.i.i.i.i, null
  br i1 %tobool.not8.i.i.i.i, label %bdrv_get_device_or_node_name.exit.i.i, label %for.body.i.i.i.i

for.body.i.i.i.i:                                 ; preds = %if.then.i.i, %for.inc.i.i.i.i
  %c.09.i.i.i.i = phi ptr [ %c.0.i.i.i.i, %for.inc.i.i.i.i ], [ %c.07.i.i.i.i, %if.then.i.i ]
  %klass.i.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i.i, i64 0, i32 2
  %21 = load ptr, ptr %klass.i.i.i.i, align 8
  %get_name.i.i.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %21, i64 0, i32 15
  %22 = load ptr, ptr %get_name.i.i.i.i, align 8
  %tobool1.not.i.i.i.i = icmp eq ptr %22, null
  br i1 %tobool1.not.i.i.i.i, label %for.inc.i.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %for.body.i.i.i.i
  %call.i.i.i.i = call ptr %22(ptr noundef nonnull %c.09.i.i.i.i) #29
  %tobool4.not.i.i.i.i = icmp eq ptr %call.i.i.i.i, null
  br i1 %tobool4.not.i.i.i.i, label %for.inc.i.i.i.i, label %land.lhs.true.i.i.i.i

land.lhs.true.i.i.i.i:                            ; preds = %if.then.i.i.i.i
  %23 = load i8, ptr %call.i.i.i.i, align 1
  %tobool5.not.i.i.i.i = icmp eq i8 %23, 0
  br i1 %tobool5.not.i.i.i.i, label %for.inc.i.i.i.i, label %bdrv_get_device_or_node_name.exit.i.i

for.inc.i.i.i.i:                                  ; preds = %land.lhs.true.i.i.i.i, %if.then.i.i.i.i, %for.body.i.i.i.i
  %next_parent.i.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i.i, i64 0, i32 10
  %c.0.i.i.i.i = load ptr, ptr %next_parent.i.i.i.i, align 8
  %tobool.not.i.i.i.i = icmp eq ptr %c.0.i.i.i.i, null
  br i1 %tobool.not.i.i.i.i, label %bdrv_get_device_or_node_name.exit.i.i, label %for.body.i.i.i.i, !llvm.loop !5

bdrv_get_device_or_node_name.exit.i.i:            ; preds = %for.inc.i.i.i.i, %land.lhs.true.i.i.i.i, %if.then.i.i
  %retval.0.i.i.i.i = phi ptr [ null, %if.then.i.i ], [ null, %for.inc.i.i.i.i ], [ %call.i.i.i.i, %land.lhs.true.i.i.i.i ]
  %tobool.not.i.i.i = icmp eq ptr %retval.0.i.i.i.i, null
  %node_name.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %19, i64 0, i32 22
  %cond.i.i.i = select i1 %tobool.not.i.i.i, ptr %node_name.i.i.i, ptr %retval.0.i.i.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err.i, ptr noundef nonnull @.str.2, i32 noundef 291, ptr noundef nonnull @__func__.bdrv_can_set_read_only, ptr noundef nonnull @.str.156, ptr noundef nonnull %cond.i.i.i) #29
  br label %bdrv_can_set_read_only.exit.i

bdrv_can_set_read_only.exit.i:                    ; preds = %bdrv_get_device_or_node_name.exit.i.i, %if.end35.i
  %retval.0.i87.i = phi i32 [ -22, %bdrv_get_device_or_node_name.exit.i.i ], [ 0, %if.end35.i ]
  call void @bdrv_graph_rdunlock_main_loop() #29
  %24 = load ptr, ptr %local_err.i, align 8
  %tobool43.not.i = icmp eq ptr %24, null
  br i1 %tobool43.not.i, label %if.end45.i, label %if.then44.i

if.then44.i:                                      ; preds = %bdrv_can_set_read_only.exit.i
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %24) #29
  br label %if.end162.i

if.end45.i:                                       ; preds = %bdrv_can_set_read_only.exit.i
  %bdrv_reopen_prepare.i = getelementptr inbounds %struct.BlockDriver, ptr %9, i64 0, i32 18
  %25 = load ptr, ptr %bdrv_reopen_prepare.i, align 8
  %tobool46.not.i = icmp eq ptr %25, null
  br i1 %tobool46.not.i, label %if.else65.i, label %if.then47.i

if.then47.i:                                      ; preds = %if.end45.i
  %26 = load ptr, ptr %state22, align 8
  %27 = load ptr, ptr %options.i, align 8
  %options.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %26, i64 0, i32 33
  %28 = load ptr, ptr %options.i.i, align 8
  %call.i88.i = call ptr @qdict_first(ptr noundef %28) #29
  %tobool.not31.i.i = icmp eq ptr %call.i88.i, null
  br i1 %tobool.not31.i.i, label %if.end53.i, label %for.body.lr.ph.i.i

for.body.lr.ph.i.i:                               ; preds = %if.then47.i
  %drv.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %26, i64 0, i32 6
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %for.body.lr.ph.i.i
  %e.032.i.i = phi ptr [ %call.i88.i, %for.body.lr.ph.i.i ], [ %call10.i.i, %for.inc.i.i ]
  %29 = load ptr, ptr %e.032.i.i, align 8
  %call1.i89.i = call i32 @qdict_haskey(ptr noundef %27, ptr noundef %29) #29
  %tobool2.not.i90.i = icmp eq i32 %call1.i89.i, 0
  br i1 %tobool2.not.i90.i, label %land.lhs.true.i.i, label %for.inc.i.i

land.lhs.true.i.i:                                ; preds = %for.body.i.i
  %30 = load ptr, ptr %e.032.i.i, align 8
  %tobool.i.not.i.i = icmp eq ptr %30, null
  br i1 %tobool.i.not.i.i, label %bdrv_reset_options_allowed.exit.i, label %for.body.i.i.i

for.cond.i.i.i:                                   ; preds = %for.body.i.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %arrayidx.i.i.i = getelementptr ptr, ptr @__const.bdrv_reset_options_allowed.common_options, i64 %indvars.iv.next.i.i
  %31 = load ptr, ptr %arrayidx.i.i.i, align 8
  %exitcond.i.i = icmp eq i64 %indvars.iv.next.i.i, 7
  br i1 %exitcond.i.i, label %land.lhs.true5.i.i, label %for.body.i.i.i, !llvm.loop !40

for.body.i.i.i:                                   ; preds = %land.lhs.true.i.i, %for.cond.i.i.i
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %for.cond.i.i.i ], [ 0, %land.lhs.true.i.i ]
  %32 = phi ptr [ %31, %for.cond.i.i.i ], [ @.str.44, %land.lhs.true.i.i ]
  %call.i.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %30, ptr noundef nonnull dereferenceable(1) %32) #28
  %tobool4.not.i.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %tobool4.not.i.i.i, label %for.inc.i.i, label %for.cond.i.i.i

land.lhs.true5.i.i:                               ; preds = %for.cond.i.i.i
  %33 = load ptr, ptr %drv.i.i, align 8
  %mutable_opts.i.i = getelementptr inbounds %struct.BlockDriver, ptr %33, i64 0, i32 11
  %34 = load ptr, ptr %mutable_opts.i.i, align 8
  %tobool1.i.not.i.i = icmp eq ptr %34, null
  br i1 %tobool1.i.not.i.i, label %bdrv_reset_options_allowed.exit.i, label %for.cond.preheader.i10.i.i

for.cond.preheader.i10.i.i:                       ; preds = %land.lhs.true5.i.i
  %35 = load ptr, ptr %34, align 8
  %cmp.not6.i11.i.i = icmp eq ptr %35, null
  br i1 %cmp.not6.i11.i.i, label %bdrv_reset_options_allowed.exit.i, label %for.body.i12.i.i

for.cond.i16.i.i:                                 ; preds = %for.body.i12.i.i
  %inc.i17.i.i = add i32 %i.07.i13.i.i, 1
  %idxprom.i18.i.i = sext i32 %inc.i17.i.i to i64
  %arrayidx.i19.i.i = getelementptr ptr, ptr %34, i64 %idxprom.i18.i.i
  %36 = load ptr, ptr %arrayidx.i19.i.i, align 8
  %cmp.not.i20.i.i = icmp eq ptr %36, null
  br i1 %cmp.not.i20.i.i, label %bdrv_reset_options_allowed.exit.i, label %for.body.i12.i.i, !llvm.loop !40

for.body.i12.i.i:                                 ; preds = %for.cond.preheader.i10.i.i, %for.cond.i16.i.i
  %37 = phi ptr [ %36, %for.cond.i16.i.i ], [ %35, %for.cond.preheader.i10.i.i ]
  %i.07.i13.i.i = phi i32 [ %inc.i17.i.i, %for.cond.i16.i.i ], [ 0, %for.cond.preheader.i10.i.i ]
  %call.i14.i.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %30, ptr noundef nonnull dereferenceable(1) %37) #28
  %tobool4.not.i15.i.i = icmp eq i32 %call.i14.i.i, 0
  br i1 %tobool4.not.i15.i.i, label %for.inc.i.i, label %for.cond.i16.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i.i, %for.body.i12.i.i, %for.body.i.i
  %38 = load ptr, ptr %options.i.i, align 8
  %call10.i.i = call ptr @qdict_next(ptr noundef %38, ptr noundef nonnull %e.032.i.i) #29
  %tobool.not.i91.i = icmp eq ptr %call10.i.i, null
  br i1 %tobool.not.i91.i, label %if.end53.i, label %for.body.i.i, !llvm.loop !41

bdrv_reset_options_allowed.exit.i:                ; preds = %for.cond.preheader.i10.i.i, %land.lhs.true5.i.i, %land.lhs.true.i.i, %for.cond.i16.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4315, ptr noundef nonnull @__func__.bdrv_reset_options_allowed, ptr noundef nonnull @.str.264, ptr noundef %30) #29
  br label %if.end162.i

if.end53.i:                                       ; preds = %for.inc.i.i, %if.then47.i
  %39 = load ptr, ptr %bdrv_reopen_prepare.i, align 8
  %call55.i = call i32 %39(ptr noundef nonnull %state22, ptr noundef nonnull %bs_queue, ptr noundef nonnull %local_err.i) #29
  %tobool56.not.i = icmp eq i32 %call55.i, 0
  br i1 %tobool56.not.i, label %if.end68.i, label %if.then57.i

if.then57.i:                                      ; preds = %if.end53.i
  %40 = load ptr, ptr %local_err.i, align 8
  %cmp58.not.i = icmp eq ptr %40, null
  br i1 %cmp58.not.i, label %if.else60.i, label %if.then59.i

if.then59.i:                                      ; preds = %if.then57.i
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %40) #29
  br label %if.end162.i

if.else60.i:                                      ; preds = %if.then57.i
  call void @bdrv_graph_rdlock_main_loop() #29
  %41 = load ptr, ptr %state22, align 8
  call void @bdrv_refresh_filename(ptr noundef %41)
  call void @bdrv_graph_rdunlock_main_loop() #29
  %42 = load ptr, ptr %state22, align 8
  %filename.i = getelementptr inbounds %struct.BlockDriverState, ptr %42, i64 0, i32 11
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4994, ptr noundef nonnull @__func__.bdrv_reopen_prepare, ptr noundef nonnull @.str.260, ptr noundef nonnull %filename.i) #29
  br label %if.end162.i

if.else65.i:                                      ; preds = %if.end45.i
  call void @bdrv_graph_rdlock_main_loop() #29
  %43 = load ptr, ptr %9, align 8
  %44 = load ptr, ptr %state22, align 8
  %parents.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %44, i64 0, i32 32
  %c.07.i.i = load ptr, ptr %parents.i.i, align 8
  %tobool.not8.i.i = icmp eq ptr %c.07.i.i, null
  br i1 %tobool.not8.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i133

for.body.i.i133:                                  ; preds = %if.else65.i, %for.inc.i.i142
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i142 ], [ %c.07.i.i, %if.else65.i ]
  %klass.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 2
  %45 = load ptr, ptr %klass.i.i, align 8
  %get_name.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %45, i64 0, i32 15
  %46 = load ptr, ptr %get_name.i.i, align 8
  %tobool1.not.i.i134 = icmp eq ptr %46, null
  br i1 %tobool1.not.i.i134, label %for.inc.i.i142, label %if.then.i.i135

if.then.i.i135:                                   ; preds = %for.body.i.i133
  %call.i.i136 = call ptr %46(ptr noundef nonnull %c.09.i.i) #29
  %tobool4.not.i.i137 = icmp eq ptr %call.i.i136, null
  br i1 %tobool4.not.i.i137, label %for.inc.i.i142, label %land.lhs.true.i.i138

land.lhs.true.i.i138:                             ; preds = %if.then.i.i135
  %47 = load i8, ptr %call.i.i136, align 1
  %tobool5.not.i.i = icmp eq i8 %47, 0
  br i1 %tobool5.not.i.i, label %for.inc.i.i142, label %bdrv_get_device_or_node_name.exit

for.inc.i.i142:                                   ; preds = %land.lhs.true.i.i138, %if.then.i.i135, %for.body.i.i133
  %next_parent.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 10
  %c.0.i.i = load ptr, ptr %next_parent.i.i, align 8
  %tobool.not.i.i143 = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i143, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i133, !llvm.loop !5

bdrv_get_device_or_node_name.exit:                ; preds = %land.lhs.true.i.i138, %for.inc.i.i142, %if.else65.i
  %retval.0.i.i = phi ptr [ null, %if.else65.i ], [ null, %for.inc.i.i142 ], [ %call.i.i136, %land.lhs.true.i.i138 ]
  %tobool.not.i139 = icmp eq ptr %retval.0.i.i, null
  %node_name.i140 = getelementptr inbounds %struct.BlockDriverState, ptr %44, i64 0, i32 22
  %cond.i141 = select i1 %tobool.not.i139, ptr %node_name.i140, ptr %retval.0.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5004, ptr noundef nonnull @__func__.bdrv_reopen_prepare, ptr noundef nonnull @.str.261, ptr noundef %43, ptr noundef nonnull %cond.i141) #29
  call void @bdrv_graph_rdunlock_main_loop() #29
  br label %if.end162.i

if.end68.i:                                       ; preds = %if.end53.i
  call void @bdrv_graph_rdlock_main_loop() #29
  %supports_backing.i = getelementptr inbounds %struct.BlockDriver, ptr %9, i64 0, i32 7
  %48 = load i8, ptr %supports_backing.i, align 1
  %49 = and i8 %48, 1
  %tobool69.not.i = icmp eq i8 %49, 0
  br i1 %tobool69.not.i, label %if.end79.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end68.i
  %backing_missing.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1159, i64 0, i32 1, i32 3
  %50 = load i8, ptr %backing_missing.i, align 8
  %51 = and i8 %50, 1
  %tobool70.not.i = icmp eq i8 %51, 0
  br i1 %tobool70.not.i, label %if.end79.i, label %land.lhs.true71.i

land.lhs.true71.i:                                ; preds = %land.lhs.true.i
  %52 = load ptr, ptr %state22, align 8
  %backing.i = getelementptr inbounds %struct.BlockDriverState, ptr %52, i64 0, i32 30
  %53 = load ptr, ptr %backing.i, align 8
  %tobool73.not.i = icmp eq ptr %53, null
  br i1 %tobool73.not.i, label %lor.lhs.false.i, label %if.then76.i

lor.lhs.false.i:                                  ; preds = %land.lhs.true71.i
  %backing_file.i = getelementptr inbounds %struct.BlockDriverState, ptr %52, i64 0, i32 12
  %54 = load i8, ptr %backing_file.i, align 1
  %tobool75.not.i = icmp eq i8 %54, 0
  br i1 %tobool75.not.i, label %if.end79.i, label %if.then76.i

if.then76.i:                                      ; preds = %lor.lhs.false.i, %land.lhs.true71.i
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %52, i64 0, i32 22
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5021, ptr noundef nonnull @__func__.bdrv_reopen_prepare, ptr noundef nonnull @.str.262, ptr noundef nonnull %node_name.i) #29
  br label %if.then157.sink.split.i

if.end79.i:                                       ; preds = %lor.lhs.false.i, %land.lhs.true.i, %if.end68.i
  call void @bdrv_graph_rdunlock_main_loop() #29
  %call80.i = call fastcc i32 @bdrv_reopen_parse_file_or_backing(ptr noundef nonnull %state22, i1 noundef zeroext true, ptr noundef %call, ptr noundef %errp), !range !28
  %cmp81.i = icmp slt i32 %call80.i, 0
  br i1 %cmp81.i, label %if.then157.i, label %if.end84.i

if.end84.i:                                       ; preds = %if.end79.i
  %55 = load ptr, ptr %options.i, align 8
  call void @qdict_del(ptr noundef %55, ptr noundef nonnull @.str.89) #29
  %call86.i = call fastcc i32 @bdrv_reopen_parse_file_or_backing(ptr noundef nonnull %state22, i1 noundef zeroext false, ptr noundef %call, ptr noundef %errp), !range !28
  %cmp87.i = icmp slt i32 %call86.i, 0
  br i1 %cmp87.i, label %if.then157.i, label %if.end90.i

if.end90.i:                                       ; preds = %if.end84.i
  %56 = load ptr, ptr %options.i, align 8
  call void @qdict_del(ptr noundef %56, ptr noundef nonnull @.str.214) #29
  %57 = load ptr, ptr %options.i, align 8
  %call93.i = call i64 @qdict_size(ptr noundef %57) #29
  %tobool94.not.i = icmp eq i64 %call93.i, 0
  br i1 %tobool94.not.i, label %if.end136.i, label %if.then95.i

if.then95.i:                                      ; preds = %if.end90.i
  %58 = load ptr, ptr %options.i, align 8
  %call98.i = call ptr @qdict_first(ptr noundef %58) #29
  call void @bdrv_graph_rdlock_main_loop() #29
  br label %do.body100.i

do.body100.i:                                     ; preds = %do.cond.i, %if.then95.i
  %entry96.0.i = phi ptr [ %call98.i, %if.then95.i ], [ %call133.i, %do.cond.i ]
  %value.i = getelementptr inbounds %struct.QDictEntry, ptr %entry96.0.i, i64 0, i32 1
  %59 = load ptr, ptr %value.i, align 8
  %60 = load ptr, ptr %state22, align 8
  %options102.i = getelementptr inbounds %struct.BlockDriverState, ptr %60, i64 0, i32 33
  %61 = load ptr, ptr %options102.i, align 8
  %62 = load ptr, ptr %entry96.0.i, align 8
  %call103.i = call ptr @qdict_get(ptr noundef %61, ptr noundef %62) #29
  %.val.i = load i32, ptr %59, align 8
  %63 = add i32 %.val.i, -1
  %or.cond.i.i = icmp ult i32 %63, 6
  br i1 %or.cond.i.i, label %qobject_type.exit.i, label %if.else.i94.i

if.else.i94.i:                                    ; preds = %do.body100.i
  call void @__assert_fail(ptr noundef nonnull @.str.218, ptr noundef nonnull @.str.161, i32 noundef 126, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_type) #31
  unreachable

qobject_type.exit.i:                              ; preds = %do.body100.i
  %cmp105.i = icmp eq i32 %.val.i, 3
  br i1 %cmp105.i, label %if.then107.i, label %if.end127.i

if.then107.i:                                     ; preds = %qobject_type.exit.i
  %64 = load ptr, ptr %state22, align 8
  %children.i = getelementptr inbounds %struct.BlockDriverState, ptr %64, i64 0, i32 29
  %child.0125.i = load ptr, ptr %children.i, align 8
  %tobool109.not126.i = icmp eq ptr %child.0125.i, null
  br i1 %tobool109.not126.i, label %if.end127.i, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %if.then107.i
  %65 = load ptr, ptr %entry96.0.i, align 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %child.0127.i = phi ptr [ %child.0125.i, %for.body.lr.ph.i ], [ %child.0.i, %for.inc.i ]
  %name.i = getelementptr inbounds %struct.BdrvChild, ptr %child.0127.i, i64 0, i32 1
  %66 = load ptr, ptr %name.i, align 8
  %call111.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %66, ptr noundef nonnull dereferenceable(1) %65) #28
  %tobool112.not.i = icmp eq i32 %call111.i, 0
  br i1 %tobool112.not.i, label %qobject_check_type.exit, label %for.inc.i

for.inc.i:                                        ; preds = %for.body.i
  %next.i = getelementptr inbounds %struct.BdrvChild, ptr %child.0127.i, i64 0, i32 9
  %child.0.i = load ptr, ptr %next.i, align 8
  %tobool109.not.i = icmp eq ptr %child.0.i, null
  br i1 %tobool109.not.i, label %if.end127.i, label %for.body.i, !llvm.loop !42

qobject_check_type.exit:                          ; preds = %for.body.i
  %67 = load ptr, ptr %child.0127.i, align 8
  %node_name118.i = getelementptr inbounds %struct.BlockDriverState, ptr %67, i64 0, i32 22
  %call121.i = call ptr @qstring_get_str(ptr noundef nonnull %59) #29
  %call122.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %node_name118.i, ptr noundef nonnull dereferenceable(1) %call121.i) #28
  %tobool123.not.i = icmp eq i32 %call122.i, 0
  br i1 %tobool123.not.i, label %do.cond.i, label %if.end127.i

if.end127.i:                                      ; preds = %for.inc.i, %qobject_check_type.exit, %if.then107.i, %qobject_type.exit.i
  %call128.i = call zeroext i1 @qobject_is_equal(ptr noundef nonnull %59, ptr noundef %call103.i) #29
  br i1 %call128.i, label %do.cond.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit.i

do.cond.i:                                        ; preds = %if.end127.i, %qobject_check_type.exit
  %68 = load ptr, ptr %options.i, align 8
  %call133.i = call ptr @qdict_next(ptr noundef %68, ptr noundef nonnull %entry96.0.i) #29
  %tobool134.not.i = icmp eq ptr %call133.i, null
  br i1 %tobool134.not.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit.thread.i, label %do.body100.i, !llvm.loop !43

glib_autoptr_cleanup_GraphLockableMainloop.exit.thread.i: ; preds = %do.cond.i
  call void @bdrv_graph_rdunlock_main_loop() #29
  br label %if.end136.i

glib_autoptr_cleanup_GraphLockableMainloop.exit.i: ; preds = %if.end127.i
  %69 = load ptr, ptr %entry96.0.i, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5095, ptr noundef nonnull @__func__.bdrv_reopen_prepare, ptr noundef nonnull @.str.263, ptr noundef %69) #29
  br label %if.then157.sink.split.i

if.end136.i:                                      ; preds = %glib_autoptr_cleanup_GraphLockableMainloop.exit.thread.i, %if.end90.i
  %70 = load ptr, ptr %options.i, align 8
  call fastcc void @qobject_unref_impl(ptr noundef %70)
  %tobool141.not.i = icmp eq ptr %call11.i, null
  br i1 %tobool141.not.i, label %qobject_ref_impl.exit.i, label %if.then.i97.i

if.then.i97.i:                                    ; preds = %if.end136.i
  %refcnt.i.i = getelementptr inbounds %struct.QObjectBase_, ptr %call11.i, i64 0, i32 1
  %71 = load i64, ptr %refcnt.i.i, align 8
  %inc.i.i = add i64 %71, 1
  store i64 %inc.i.i, ptr %refcnt.i.i, align 8
  br label %qobject_ref_impl.exit.i

qobject_ref_impl.exit.i:                          ; preds = %if.then.i97.i, %if.end136.i
  store ptr %call11.i, ptr %options.i, align 8
  br label %if.end162.i

if.then157.sink.split.i:                          ; preds = %glib_autoptr_cleanup_GraphLockableMainloop.exit.i, %if.then76.i
  call void @bdrv_graph_rdunlock_main_loop() #29
  br label %if.then157.i

if.then157.i:                                     ; preds = %if.then157.sink.split.i, %if.end84.i, %if.end79.i
  %ret.1.i = phi i32 [ %call80.i, %if.end79.i ], [ %call86.i, %if.end84.i ], [ -22, %if.then157.sink.split.i ]
  %bdrv_reopen_abort.i = getelementptr inbounds %struct.BlockDriver, ptr %9, i64 0, i32 21
  %72 = load ptr, ptr %bdrv_reopen_abort.i, align 8
  %tobool158.not.i = icmp eq ptr %72, null
  br i1 %tobool158.not.i, label %if.end162.i, label %if.then159.i

if.then159.i:                                     ; preds = %if.then157.i
  call void %72(ptr noundef nonnull %state22) #29
  br label %if.end162.i

if.end162.i:                                      ; preds = %if.then159.i, %if.then157.i, %qobject_ref_impl.exit.i, %bdrv_get_device_or_node_name.exit, %if.else60.i, %if.then59.i, %bdrv_reset_options_allowed.exit.i, %if.then44.i, %if.then34.i, %if.then29.i, %do.end.i
  %ret.1118.i = phi i32 [ %ret.1.i, %if.then157.i ], [ %ret.1.i, %if.then159.i ], [ -22, %do.end.i ], [ -1, %bdrv_get_device_or_node_name.exit ], [ 0, %qobject_ref_impl.exit.i ], [ %call55.i, %if.else60.i ], [ %call55.i, %if.then59.i ], [ -22, %bdrv_reset_options_allowed.exit.i ], [ %retval.0.i87.i, %if.then44.i ], [ -22, %if.then34.i ], [ -22, %if.then29.i ]
  %discard.0117.i = phi ptr [ %call23.i, %if.then157.i ], [ %call23.i, %if.then159.i ], [ null, %do.end.i ], [ %call23.i, %bdrv_get_device_or_node_name.exit ], [ %call23.i, %qobject_ref_impl.exit.i ], [ %call23.i, %if.else60.i ], [ %call23.i, %if.then59.i ], [ %call23.i, %bdrv_reset_options_allowed.exit.i ], [ %call23.i, %if.then44.i ], [ %call23.i, %if.then34.i ], [ %call23.i, %if.then29.i ]
  call void @qemu_opts_del(ptr noundef %call12.i) #29
  %tobool164.not.i = icmp eq ptr %call11.i, null
  br i1 %tobool164.not.i, label %bdrv_reopen_prepare.exit, label %lor.lhs.false.i99.i

lor.lhs.false.i99.i:                              ; preds = %if.end162.i
  %refcnt.i100.i = getelementptr inbounds %struct.QObjectBase_, ptr %call11.i, i64 0, i32 1
  %73 = load i64, ptr %refcnt.i100.i, align 8
  %tobool1.not.i.i = icmp eq i64 %73, 0
  br i1 %tobool1.not.i.i, label %if.else.i102.i, label %land.lhs.true.i101.i

if.else.i102.i:                                   ; preds = %lor.lhs.false.i99.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i101.i:                             ; preds = %lor.lhs.false.i99.i
  %dec.i.i = add i64 %73, -1
  store i64 %dec.i.i, ptr %refcnt.i100.i, align 8
  %cmp.i.i = icmp eq i64 %dec.i.i, 0
  br i1 %cmp.i.i, label %if.then5.i.i, label %bdrv_reopen_prepare.exit

if.then5.i.i:                                     ; preds = %land.lhs.true.i101.i
  call void @qobject_destroy(ptr noundef nonnull %call11.i) #29
  br label %bdrv_reopen_prepare.exit

bdrv_reopen_prepare.exit:                         ; preds = %if.end162.i, %land.lhs.true.i101.i, %if.then5.i.i
  call void @g_free(ptr noundef %discard.0117.i) #29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %local_err.i)
  call void @aio_context_release(ptr noundef %5) #29
  %cmp33 = icmp slt i32 %ret.1118.i, 0
  br i1 %cmp33, label %abort, label %if.end35

if.end35:                                         ; preds = %bdrv_reopen_prepare.exit
  store i8 1, ptr %bs_entry.1159, align 8
  %entry37 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.1159, i64 0, i32 2
  %bs_entry.1 = load ptr, ptr %entry37, align 8
  %tobool20.not = icmp eq ptr %bs_entry.1, null
  br i1 %tobool20.not, label %for.cond39.preheader, label %for.body21, !llvm.loop !44

for.body41:                                       ; preds = %for.cond39.preheader, %for.inc56
  %bs_entry.2167 = phi ptr [ %bs_entry.2, %for.inc56 ], [ %bs_entry.2164.pre, %for.cond39.preheader ]
  %refresh_list.0166 = phi ptr [ %refresh_list.2, %for.inc56 ], [ null, %for.cond39.preheader ]
  %state43 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.2167, i64 0, i32 1
  %74 = load ptr, ptr %state43, align 8
  %call45 = call ptr @g_slist_prepend(ptr noundef %refresh_list.0166, ptr noundef %74) #29
  %old_backing_bs = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.2167, i64 0, i32 1, i32 4
  %75 = load ptr, ptr %old_backing_bs, align 8
  %tobool46.not = icmp eq ptr %75, null
  br i1 %tobool46.not, label %if.end50, label %if.then47

if.then47:                                        ; preds = %for.body41
  %call49 = call ptr @g_slist_prepend(ptr noundef %call45, ptr noundef nonnull %75) #29
  br label %if.end50

if.end50:                                         ; preds = %if.then47, %for.body41
  %refresh_list.1 = phi ptr [ %call45, %for.body41 ], [ %call49, %if.then47 ]
  %old_file_bs = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.2167, i64 0, i32 1, i32 5
  %76 = load ptr, ptr %old_file_bs, align 8
  %tobool51.not = icmp eq ptr %76, null
  br i1 %tobool51.not, label %for.inc56, label %if.then52

if.then52:                                        ; preds = %if.end50
  %call54 = call ptr @g_slist_prepend(ptr noundef %refresh_list.1, ptr noundef nonnull %76) #29
  br label %for.inc56

for.inc56:                                        ; preds = %if.end50, %if.then52
  %refresh_list.2 = phi ptr [ %refresh_list.1, %if.end50 ], [ %call54, %if.then52 ]
  %entry57 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.2167, i64 0, i32 2
  %bs_entry.2 = load ptr, ptr %entry57, align 8
  %tobool40.not = icmp eq ptr %bs_entry.2, null
  br i1 %tobool40.not, label %for.end58, label %for.body41, !llvm.loop !45

for.end58:                                        ; preds = %for.inc56, %for.cond.preheader, %for.cond19.preheader, %for.cond39.preheader
  %refresh_list.0.lcssa = phi ptr [ null, %for.cond39.preheader ], [ null, %for.cond19.preheader ], [ null, %for.cond.preheader ], [ %refresh_list.2, %for.inc56 ]
  call void @bdrv_graph_rdlock_main_loop() #29
  %call59 = call fastcc i32 @bdrv_list_refresh_perms(ptr noundef %refresh_list.0.lcssa, ptr noundef nonnull %bs_queue, ptr noundef %call, ptr noundef %errp), !range !14
  call void @bdrv_graph_rdunlock_main_loop() #29
  %cmp60 = icmp slt i32 %call59, 0
  br i1 %cmp60, label %abort, label %if.end62

if.end62:                                         ; preds = %for.end58
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %bs_queue, i64 0, i32 1
  %.pn60168 = load ptr, ptr %tql_prev, align 8
  %bs_entry.3.in.in169 = getelementptr inbounds %struct.QTailQLink, ptr %.pn60168, i64 0, i32 1
  %bs_entry.3.in170 = load ptr, ptr %bs_entry.3.in.in169, align 8
  %bs_entry.3171 = load ptr, ptr %bs_entry.3.in170, align 8
  %tobool65.not172 = icmp eq ptr %bs_entry.3171, null
  br i1 %tobool65.not172, label %for.end76, label %for.body66

for.body66:                                       ; preds = %if.end62, %bdrv_reopen_commit.exit
  %bs_entry.3173 = phi ptr [ %bs_entry.3, %bdrv_reopen_commit.exit ], [ %bs_entry.3171, %if.end62 ]
  %state67 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.3173, i64 0, i32 1
  %77 = load ptr, ptr %state67, align 8
  %tobool.not.i70 = icmp eq ptr %77, null
  br i1 %tobool.not.i70, label %cond.false.i74, label %cond.true.i71

cond.true.i71:                                    ; preds = %for.body66
  %aio_context.i72 = getelementptr inbounds %struct.BlockDriverState, ptr %77, i64 0, i32 8
  %78 = load ptr, ptr %aio_context.i72, align 8
  br label %bdrv_get_aio_context.exit76

cond.false.i74:                                   ; preds = %for.body66
  %call.i75 = call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit76

bdrv_get_aio_context.exit76:                      ; preds = %cond.true.i71, %cond.false.i74
  %cond.i73 = phi ptr [ %78, %cond.true.i71 ], [ %call.i75, %cond.false.i74 ]
  call void @aio_context_acquire(ptr noundef %cond.i73) #29
  %79 = load ptr, ptr %state67, align 8
  %drv2.i = getelementptr inbounds %struct.BlockDriverState, ptr %79, i64 0, i32 6
  %80 = load ptr, ptr %drv2.i, align 8
  %cmp3.not.i = icmp eq ptr %80, null
  br i1 %cmp3.not.i, label %if.else5.i, label %do.body.i77

if.else5.i:                                       ; preds = %bdrv_get_aio_context.exit76
  call void @__assert_fail(ptr noundef nonnull @.str.240, ptr noundef nonnull @.str.2, i32 noundef 5138, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_commit) #31
  unreachable

do.body.i77:                                      ; preds = %bdrv_get_aio_context.exit76
  %call.i78 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i78, label %do.end.i79, label %if.else8.i

if.else8.i:                                       ; preds = %do.body.i77
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5139, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_commit) #31
  unreachable

do.end.i79:                                       ; preds = %do.body.i77
  %bdrv_reopen_commit.i = getelementptr inbounds %struct.BlockDriver, ptr %80, i64 0, i32 19
  %81 = load ptr, ptr %bdrv_reopen_commit.i, align 8
  %tobool.not.i80 = icmp eq ptr %81, null
  br i1 %tobool.not.i80, label %if.end12.i, label %if.then10.i

if.then10.i:                                      ; preds = %do.end.i79
  call void %81(ptr noundef nonnull %state67) #29
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.then10.i, %do.end.i79
  call void @bdrv_graph_rdlock_main_loop() #29
  %explicit_options.i = getelementptr inbounds %struct.BlockDriverState, ptr %79, i64 0, i32 34
  %82 = load ptr, ptr %explicit_options.i, align 8
  %tobool14.not.i = icmp eq ptr %82, null
  br i1 %tobool14.not.i, label %qobject_unref_impl.exit.i, label %lor.lhs.false.i.i81

lor.lhs.false.i.i81:                              ; preds = %if.end12.i
  %refcnt.i.i82 = getelementptr inbounds %struct.QObjectBase_, ptr %82, i64 0, i32 1
  %83 = load i64, ptr %refcnt.i.i82, align 8
  %tobool1.not.i.i83 = icmp eq i64 %83, 0
  br i1 %tobool1.not.i.i83, label %if.else.i.i102, label %land.lhs.true.i.i84

if.else.i.i102:                                   ; preds = %lor.lhs.false.i.i81
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i.i84:                              ; preds = %lor.lhs.false.i.i81
  %dec.i.i85 = add i64 %83, -1
  store i64 %dec.i.i85, ptr %refcnt.i.i82, align 8
  %cmp.i.i86 = icmp eq i64 %dec.i.i85, 0
  br i1 %cmp.i.i86, label %if.then5.i.i101, label %qobject_unref_impl.exit.i

if.then5.i.i101:                                  ; preds = %land.lhs.true.i.i84
  call void @qobject_destroy(ptr noundef nonnull %82) #29
  br label %qobject_unref_impl.exit.i

qobject_unref_impl.exit.i:                        ; preds = %if.then5.i.i101, %land.lhs.true.i.i84, %if.end12.i
  %options.i87 = getelementptr inbounds %struct.BlockDriverState, ptr %79, i64 0, i32 33
  %84 = load ptr, ptr %options.i87, align 8
  %tobool17.not.i = icmp eq ptr %84, null
  br i1 %tobool17.not.i, label %qobject_unref_impl.exit47.i, label %lor.lhs.false.i39.i

lor.lhs.false.i39.i:                              ; preds = %qobject_unref_impl.exit.i
  %refcnt.i40.i = getelementptr inbounds %struct.QObjectBase_, ptr %84, i64 0, i32 1
  %85 = load i64, ptr %refcnt.i40.i, align 8
  %tobool1.not.i41.i = icmp eq i64 %85, 0
  br i1 %tobool1.not.i41.i, label %if.else.i46.i, label %land.lhs.true.i42.i

if.else.i46.i:                                    ; preds = %lor.lhs.false.i39.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i42.i:                              ; preds = %lor.lhs.false.i39.i
  %dec.i43.i = add i64 %85, -1
  store i64 %dec.i43.i, ptr %refcnt.i40.i, align 8
  %cmp.i44.i = icmp eq i64 %dec.i43.i, 0
  br i1 %cmp.i44.i, label %if.then5.i45.i, label %qobject_unref_impl.exit47.i

if.then5.i45.i:                                   ; preds = %land.lhs.true.i42.i
  call void @qobject_destroy(ptr noundef nonnull %84) #29
  br label %qobject_unref_impl.exit47.i

qobject_unref_impl.exit47.i:                      ; preds = %if.then5.i45.i, %land.lhs.true.i42.i, %qobject_unref_impl.exit.i
  %explicit_options26.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.3173, i64 0, i32 1, i32 7
  %86 = load ptr, ptr %explicit_options26.i, align 8
  %tobool28.not.i = icmp eq ptr %86, null
  br i1 %tobool28.not.i, label %qobject_ref_impl.exit.i90, label %if.then.i.i88

if.then.i.i88:                                    ; preds = %qobject_unref_impl.exit47.i
  %refcnt.i48.i = getelementptr inbounds %struct.QObjectBase_, ptr %86, i64 0, i32 1
  %87 = load i64, ptr %refcnt.i48.i, align 8
  %inc.i.i89 = add i64 %87, 1
  store i64 %inc.i.i89, ptr %refcnt.i48.i, align 8
  br label %qobject_ref_impl.exit.i90

qobject_ref_impl.exit.i90:                        ; preds = %if.then.i.i88, %qobject_unref_impl.exit47.i
  %options39.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.3173, i64 0, i32 1, i32 6
  %88 = load ptr, ptr %options39.i, align 8
  %tobool41.not.i = icmp eq ptr %88, null
  br i1 %tobool41.not.i, label %qobject_ref_impl.exit52.i, label %if.then.i49.i

if.then.i49.i:                                    ; preds = %qobject_ref_impl.exit.i90
  %refcnt.i50.i = getelementptr inbounds %struct.QObjectBase_, ptr %88, i64 0, i32 1
  %89 = load i64, ptr %refcnt.i50.i, align 8
  %inc.i51.i = add i64 %89, 1
  store i64 %inc.i51.i, ptr %refcnt.i50.i, align 8
  br label %qobject_ref_impl.exit52.i

qobject_ref_impl.exit52.i:                        ; preds = %if.then.i49.i, %qobject_ref_impl.exit.i90
  %90 = load ptr, ptr %explicit_options26.i, align 8
  store ptr %90, ptr %explicit_options.i, align 8
  %91 = load ptr, ptr %options39.i, align 8
  store ptr %91, ptr %options.i87, align 8
  %flags.i91 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.3173, i64 0, i32 1, i32 1
  %92 = load i32, ptr %flags.i91, align 8
  store i32 %92, ptr %79, align 8
  %detect_zeroes.i92 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.3173, i64 0, i32 1, i32 2
  %93 = load i32, ptr %detect_zeroes.i92, align 4
  %detect_zeroes55.i = getelementptr inbounds %struct.BlockDriverState, ptr %79, i64 0, i32 35
  store i32 %93, ptr %detect_zeroes55.i, align 8
  %children.i93 = getelementptr inbounds %struct.BlockDriverState, ptr %79, i64 0, i32 29
  %child.053.i = load ptr, ptr %children.i93, align 8
  %tobool56.not54.i = icmp eq ptr %child.053.i, null
  br i1 %tobool56.not54.i, label %bdrv_reopen_commit.exit, label %for.body.i94

for.body.i94:                                     ; preds = %qobject_ref_impl.exit52.i, %for.body.i94
  %child.055.i = phi ptr [ %child.0.i97, %for.body.i94 ], [ %child.053.i, %qobject_ref_impl.exit52.i ]
  %94 = load ptr, ptr %explicit_options.i, align 8
  %name.i95 = getelementptr inbounds %struct.BdrvChild, ptr %child.055.i, i64 0, i32 1
  %95 = load ptr, ptr %name.i95, align 8
  call void @qdict_del(ptr noundef %94, ptr noundef %95) #29
  %96 = load ptr, ptr %options.i87, align 8
  %97 = load ptr, ptr %name.i95, align 8
  call void @qdict_del(ptr noundef %96, ptr noundef %97) #29
  %next.i96 = getelementptr inbounds %struct.BdrvChild, ptr %child.055.i, i64 0, i32 9
  %child.0.i97 = load ptr, ptr %next.i96, align 8
  %tobool56.not.i98 = icmp eq ptr %child.0.i97, null
  br i1 %tobool56.not.i98, label %glib_autoptr_cleanup_GraphLockableMainloop.exit.loopexit.i, label %for.body.i94, !llvm.loop !46

glib_autoptr_cleanup_GraphLockableMainloop.exit.loopexit.i: ; preds = %for.body.i94
  %.pre.i99 = load ptr, ptr %explicit_options.i, align 8
  br label %bdrv_reopen_commit.exit

bdrv_reopen_commit.exit:                          ; preds = %qobject_ref_impl.exit52.i, %glib_autoptr_cleanup_GraphLockableMainloop.exit.loopexit.i
  %98 = phi ptr [ %.pre.i99, %glib_autoptr_cleanup_GraphLockableMainloop.exit.loopexit.i ], [ %90, %qobject_ref_impl.exit52.i ]
  call void @qdict_del(ptr noundef %98, ptr noundef nonnull @.str.89) #29
  %99 = load ptr, ptr %options.i87, align 8
  call void @qdict_del(ptr noundef %99, ptr noundef nonnull @.str.89) #29
  call void @bdrv_refresh_limits(ptr noundef nonnull %79, ptr noundef null, ptr noundef null) #29
  %total_sectors.i = getelementptr inbounds %struct.BlockDriverState, ptr %79, i64 0, i32 37
  %100 = load i64, ptr %total_sectors.i, align 8
  %call62.i = call i32 @bdrv_refresh_total_sectors(ptr noundef nonnull %79, i64 noundef %100) #29
  call void @bdrv_graph_rdunlock_main_loop() #29
  call void @aio_context_release(ptr noundef %cond.i73) #29
  %tql_prev73 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.3173, i64 0, i32 2, i32 0, i32 1
  %.pn60 = load ptr, ptr %tql_prev73, align 8
  %bs_entry.3.in.in = getelementptr inbounds %struct.QTailQLink, ptr %.pn60, i64 0, i32 1
  %bs_entry.3.in = load ptr, ptr %bs_entry.3.in.in, align 8
  %bs_entry.3 = load ptr, ptr %bs_entry.3.in, align 8
  %tobool65.not = icmp eq ptr %bs_entry.3, null
  br i1 %tobool65.not, label %for.end76, label %for.body66, !llvm.loop !47

for.end76:                                        ; preds = %bdrv_reopen_commit.exit, %if.end62
  call void @bdrv_graph_wrlock(ptr noundef null) #29
  call void @tran_commit(ptr noundef %call) #29
  call void @bdrv_graph_wrunlock(ptr noundef null) #29
  %.pn174 = load ptr, ptr %tql_prev, align 8
  %bs_entry.4.in.in175 = getelementptr inbounds %struct.QTailQLink, ptr %.pn174, i64 0, i32 1
  %bs_entry.4.in176 = load ptr, ptr %bs_entry.4.in.in175, align 8
  %bs_entry.4177 = load ptr, ptr %bs_entry.4.in176, align 8
  %tobool81.not178 = icmp eq ptr %bs_entry.4177, null
  br i1 %tobool81.not178, label %cleanup, label %for.body82

for.body82:                                       ; preds = %for.end76, %for.inc93
  %bs_entry.4179 = phi ptr [ %bs_entry.4, %for.inc93 ], [ %bs_entry.4177, %for.end76 ]
  %state84 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.4179, i64 0, i32 1
  %101 = load ptr, ptr %state84, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %101, i64 0, i32 6
  %102 = load ptr, ptr %drv, align 8
  %bdrv_reopen_commit_post = getelementptr inbounds %struct.BlockDriver, ptr %102, i64 0, i32 20
  %103 = load ptr, ptr %bdrv_reopen_commit_post, align 8
  %tobool86.not = icmp eq ptr %103, null
  br i1 %tobool86.not, label %for.inc93, label %bdrv_get_aio_context.exit109

bdrv_get_aio_context.exit109:                     ; preds = %for.body82
  %aio_context.i105 = getelementptr inbounds %struct.BlockDriverState, ptr %101, i64 0, i32 8
  %104 = load ptr, ptr %aio_context.i105, align 8
  call void @aio_context_acquire(ptr noundef %104) #29
  %105 = load ptr, ptr %drv, align 8
  %bdrv_reopen_commit_post90 = getelementptr inbounds %struct.BlockDriver, ptr %105, i64 0, i32 20
  %106 = load ptr, ptr %bdrv_reopen_commit_post90, align 8
  call void %106(ptr noundef nonnull %state84) #29
  call void @aio_context_release(ptr noundef %104) #29
  br label %for.inc93

for.inc93:                                        ; preds = %for.body82, %bdrv_get_aio_context.exit109
  %tql_prev95 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.4179, i64 0, i32 2, i32 0, i32 1
  %.pn = load ptr, ptr %tql_prev95, align 8
  %bs_entry.4.in.in = getelementptr inbounds %struct.QTailQLink, ptr %.pn, i64 0, i32 1
  %bs_entry.4.in = load ptr, ptr %bs_entry.4.in.in, align 8
  %bs_entry.4 = load ptr, ptr %bs_entry.4.in, align 8
  %tobool81.not = icmp eq ptr %bs_entry.4, null
  br i1 %tobool81.not, label %cleanup, label %for.body82, !llvm.loop !48

abort:                                            ; preds = %bdrv_reopen_prepare.exit, %for.end58, %if.then16
  %refresh_list.3 = phi ptr [ %refresh_list.0.lcssa, %for.end58 ], [ null, %if.then16 ], [ null, %bdrv_reopen_prepare.exit ]
  %ret.0 = phi i32 [ %call59, %for.end58 ], [ %call14, %if.then16 ], [ %ret.1118.i, %bdrv_reopen_prepare.exit ]
  call void @bdrv_graph_wrlock(ptr noundef null) #29
  call void @tran_abort(ptr noundef %call) #29
  call void @bdrv_graph_wrunlock(ptr noundef null) #29
  %107 = load ptr, ptr %bs_queue, align 8
  %tobool100.not180 = icmp eq ptr %107, null
  br i1 %tobool100.not180, label %cleanup, label %land.rhs

land.rhs:                                         ; preds = %abort, %for.inc111
  %bs_entry.5181 = phi ptr [ %108, %for.inc111 ], [ %107, %abort ]
  %entry101 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.5181, i64 0, i32 2
  %108 = load ptr, ptr %entry101, align 8
  %109 = load i8, ptr %bs_entry.5181, align 8
  %110 = and i8 %109, 1
  %tobool104.not = icmp eq i8 %110, 0
  br i1 %tobool104.not, label %for.inc111, label %if.then105

if.then105:                                       ; preds = %land.rhs
  %state106 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %bs_entry.5181, i64 0, i32 1
  %111 = load ptr, ptr %state106, align 8
  %tobool.not.i110 = icmp eq ptr %111, null
  br i1 %tobool.not.i110, label %cond.false.i114, label %cond.true.i111

cond.true.i111:                                   ; preds = %if.then105
  %aio_context.i112 = getelementptr inbounds %struct.BlockDriverState, ptr %111, i64 0, i32 8
  %112 = load ptr, ptr %aio_context.i112, align 8
  br label %bdrv_get_aio_context.exit116

cond.false.i114:                                  ; preds = %if.then105
  %call.i115 = call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit116

bdrv_get_aio_context.exit116:                     ; preds = %cond.true.i111, %cond.false.i114
  %cond.i113 = phi ptr [ %112, %cond.true.i111 ], [ %call.i115, %cond.false.i114 ]
  call void @aio_context_acquire(ptr noundef %cond.i113) #29
  %113 = load ptr, ptr %state106, align 8
  %drv1.i117 = getelementptr inbounds %struct.BlockDriverState, ptr %113, i64 0, i32 6
  %114 = load ptr, ptr %drv1.i117, align 8
  %cmp2.not.i118 = icmp eq ptr %114, null
  br i1 %cmp2.not.i118, label %if.else4.i125, label %do.body.i119

if.else4.i125:                                    ; preds = %bdrv_get_aio_context.exit116
  call void @__assert_fail(ptr noundef nonnull @.str.240, ptr noundef nonnull @.str.2, i32 noundef 5183, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_abort) #31
  unreachable

do.body.i119:                                     ; preds = %bdrv_get_aio_context.exit116
  %call.i120 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i120, label %do.end.i122, label %if.else7.i121

if.else7.i121:                                    ; preds = %do.body.i119
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5184, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_abort) #31
  unreachable

do.end.i122:                                      ; preds = %do.body.i119
  %bdrv_reopen_abort.i123 = getelementptr inbounds %struct.BlockDriver, ptr %114, i64 0, i32 21
  %115 = load ptr, ptr %bdrv_reopen_abort.i123, align 8
  %tobool.not.i124 = icmp eq ptr %115, null
  br i1 %tobool.not.i124, label %bdrv_reopen_abort.exit, label %if.then9.i

if.then9.i:                                       ; preds = %do.end.i122
  call void %115(ptr noundef nonnull %state106) #29
  br label %bdrv_reopen_abort.exit

bdrv_reopen_abort.exit:                           ; preds = %do.end.i122, %if.then9.i
  call void @aio_context_release(ptr noundef %cond.i113) #29
  br label %for.inc111

for.inc111:                                       ; preds = %land.rhs, %bdrv_reopen_abort.exit
  %tobool100.not = icmp eq ptr %108, null
  br i1 %tobool100.not, label %cleanup, label %land.rhs, !llvm.loop !49

cleanup:                                          ; preds = %for.inc93, %for.inc111, %for.end76, %abort
  %refresh_list.4 = phi ptr [ %refresh_list.3, %abort ], [ %refresh_list.0.lcssa, %for.end76 ], [ %refresh_list.3, %for.inc111 ], [ %refresh_list.0.lcssa, %for.inc93 ]
  %ret.1 = phi i32 [ %ret.0, %abort ], [ 0, %for.end76 ], [ %ret.0, %for.inc111 ], [ 0, %for.inc93 ]
  call void @bdrv_reopen_queue_free(ptr noundef nonnull %bs_queue)
  %tobool.not.i.i126 = icmp eq ptr %refresh_list.4, null
  br i1 %tobool.not.i.i126, label %glib_autoptr_cleanup_GSList.exit, label %if.then.i.i127

if.then.i.i127:                                   ; preds = %cleanup
  call void @g_slist_free(ptr noundef nonnull %refresh_list.4) #29
  br label %glib_autoptr_cleanup_GSList.exit

glib_autoptr_cleanup_GSList.exit:                 ; preds = %cleanup, %if.then.i.i127
  ret i32 %ret.1
}

declare ptr @qemu_get_current_aio_context() local_unnamed_addr #5

declare i32 @bdrv_flush(ptr noundef) #5

declare ptr @g_slist_prepend(ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_list_refresh_perms(ptr noundef readonly %list, ptr noundef %q, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %call = tail call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  %tobool.not6 = icmp eq ptr %list, null
  br i1 %tobool.not6, label %for.end.thread, label %for.body

for.end.thread:                                   ; preds = %entry
  %call210 = tail call fastcc i32 @bdrv_do_refresh_perms(ptr noundef null, ptr noundef %q, ptr noundef %tran, ptr noundef %errp), !range !14
  br label %glib_autoptr_cleanup_GSList.exit

for.body:                                         ; preds = %entry, %for.body
  %list.addr.08 = phi ptr [ %1, %for.body ], [ %list, %entry ]
  %refresh_list.07 = phi ptr [ %call1, %for.body ], [ null, %entry ]
  %0 = load ptr, ptr %list.addr.08, align 8
  %call1 = tail call fastcc ptr @bdrv_topological_dfs(ptr noundef %refresh_list.07, ptr noundef %call, ptr noundef %0)
  %next = getelementptr inbounds %struct._GSList, ptr %list.addr.08, i64 0, i32 1
  %1 = load ptr, ptr %next, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !50

for.end:                                          ; preds = %for.body
  %call2 = tail call fastcc i32 @bdrv_do_refresh_perms(ptr noundef %call1, ptr noundef %q, ptr noundef %tran, ptr noundef %errp), !range !14
  %tobool.not.i.i = icmp eq ptr %call1, null
  br i1 %tobool.not.i.i, label %glib_autoptr_cleanup_GSList.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.end
  tail call void @g_slist_free(ptr noundef nonnull %call1) #29
  br label %glib_autoptr_cleanup_GSList.exit

glib_autoptr_cleanup_GSList.exit:                 ; preds = %for.end.thread, %for.end, %if.then.i.i
  %call212 = phi i32 [ %call210, %for.end.thread ], [ %call2, %for.end ], [ %call2, %if.then.i.i ]
  %tobool.not.i.i3 = icmp eq ptr %call, null
  br i1 %tobool.not.i.i3, label %glib_autoptr_cleanup_GHashTable.exit, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %glib_autoptr_cleanup_GSList.exit
  tail call void @g_hash_table_unref(ptr noundef nonnull %call) #29
  br label %glib_autoptr_cleanup_GHashTable.exit

glib_autoptr_cleanup_GHashTable.exit:             ; preds = %glib_autoptr_cleanup_GSList.exit, %if.then.i.i4
  ret i32 %call212
}

declare void @tran_commit(ptr noundef) local_unnamed_addr #5

declare void @tran_abort(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_reopen(ptr noundef %bs, ptr noundef %opts, i1 noundef zeroext %keep_old_opts, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4698, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen) #31
  unreachable

do.end:                                           ; preds = %bdrv_get_aio_context.exit
  %call.i5 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i5, label %bdrv_reopen_queue.exit, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4530, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_queue) #31
  unreachable

bdrv_reopen_queue.exit:                           ; preds = %do.end
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2.i = tail call fastcc ptr @bdrv_reopen_queue_child(ptr noundef null, ptr noundef %bs, ptr noundef %opts, ptr noundef null, i32 noundef 0, i1 noundef zeroext false, ptr noundef null, i32 noundef 0, i1 noundef zeroext %keep_old_opts)
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  %call3 = tail call ptr @qemu_get_aio_context() #29
  %cmp.not = icmp eq ptr %cond.i, %call3
  br i1 %cmp.not, label %if.end5, label %if.then4

if.then4:                                         ; preds = %bdrv_reopen_queue.exit
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %bdrv_reopen_queue.exit
  %call6 = tail call i32 @bdrv_reopen_multiple(ptr noundef %call2.i, ptr noundef %errp), !range !14
  %call7 = tail call ptr @qemu_get_aio_context() #29
  %cmp8.not = icmp eq ptr %cond.i, %call7
  br i1 %cmp8.not, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end5
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end5
  ret i32 %call6
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_reopen_set_read_only(ptr noundef %bs, i1 noundef zeroext %read_only, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @qdict_new() #29
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4719, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_set_read_only) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @qdict_put_bool(ptr noundef %call, ptr noundef nonnull @.str.51, i1 noundef zeroext %read_only) #29
  %call2 = tail call i32 @bdrv_reopen(ptr noundef %bs, ptr noundef %call, i1 noundef zeroext true, ptr noundef %errp), !range !14
  ret i32 %call2
}

declare void @qdict_put_bool(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_close_all() local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5259, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close_all) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call ptr @job_next(ptr noundef null) #29
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %if.end4, label %if.else3

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.86, ptr noundef nonnull @.str.2, i32 noundef 5260, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close_all) #31
  unreachable

if.end4:                                          ; preds = %do.end
  tail call void @bdrv_drain_all() #29
  tail call void @blk_remove_all_bs() #29
  tail call void @blockdev_close_all_bdrv_states() #29
  %0 = load ptr, ptr @all_bdrv_states, align 8
  %cmp5 = icmp eq ptr %0, null
  br i1 %cmp5, label %if.end8, label %if.else7

if.else7:                                         ; preds = %if.end4
  tail call void @__assert_fail(ptr noundef nonnull @.str.87, ptr noundef nonnull @.str.2, i32 noundef 5269, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_close_all) #31
  unreachable

if.end8:                                          ; preds = %if.end4
  ret void
}

declare ptr @job_next(ptr noundef) local_unnamed_addr #5

declare void @bdrv_drain_all() local_unnamed_addr #5

declare void @blk_remove_all_bs() local_unnamed_addr #5

declare void @blockdev_close_all_bdrv_states() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_replace_node(ptr noundef %from, ptr noundef %to, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call fastcc i32 @bdrv_replace_node_common(ptr noundef %from, ptr noundef %to, i1 noundef zeroext true, i1 noundef zeroext false, ptr noundef %errp), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_replace_node_common(ptr noundef %from, ptr noundef %to, i1 noundef zeroext %auto_skip, i1 noundef zeroext %detach_subchain, ptr noundef %errp) unnamed_addr #4 {
entry:
  %call = tail call ptr @tran_new() #29
  %call2 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call2, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5446, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_common) #31
  unreachable

do.end:                                           ; preds = %entry
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %from, i64 0, i32 46
  %0 = load i32, ptr %quiesce_counter, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.else4, label %if.end5

if.else4:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.268, ptr noundef nonnull @.str.2, i32 noundef 5448, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_common) #31
  unreachable

if.end5:                                          ; preds = %do.end
  %quiesce_counter6 = getelementptr inbounds %struct.BlockDriverState, ptr %to, i64 0, i32 46
  %1 = load i32, ptr %quiesce_counter6, align 8
  %tobool7.not = icmp eq i32 %1, 0
  br i1 %tobool7.not, label %if.else9, label %bdrv_get_aio_context.exit29

if.else9:                                         ; preds = %if.end5
  tail call void @__assert_fail(ptr noundef nonnull @.str.269, ptr noundef nonnull @.str.2, i32 noundef 5449, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_common) #31
  unreachable

bdrv_get_aio_context.exit29:                      ; preds = %if.end5
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %from, i64 0, i32 8
  %2 = load ptr, ptr %aio_context.i, align 8
  %aio_context.i25 = getelementptr inbounds %struct.BlockDriverState, ptr %to, i64 0, i32 8
  %3 = load ptr, ptr %aio_context.i25, align 8
  %cmp = icmp eq ptr %2, %3
  br i1 %cmp, label %if.end15, label %if.else14

if.else14:                                        ; preds = %bdrv_get_aio_context.exit29
  tail call void @__assert_fail(ptr noundef nonnull @.str.270, ptr noundef nonnull @.str.2, i32 noundef 5450, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_common) #31
  unreachable

if.end15:                                         ; preds = %bdrv_get_aio_context.exit29
  br i1 %detach_subchain, label %if.then17, label %if.end29.thread

if.then17:                                        ; preds = %if.end15
  %call.i30 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i30, label %while.cond.preheader.i, label %if.else.i

while.cond.preheader.i:                           ; preds = %if.then17
  %cmp5.i.not = icmp eq ptr %from, %to
  br i1 %cmp5.i.not, label %if.else24, label %while.body.i

if.else.i:                                        ; preds = %if.then17
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6537, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_chain_contains) #31
  unreachable

while.body.i:                                     ; preds = %while.cond.preheader.i, %bdrv_filter_or_cow_bs.exit.i
  %top.addr.06.i = phi ptr [ %4, %bdrv_filter_or_cow_bs.exit.i ], [ %from, %while.cond.preheader.i ]
  %call.i.i = tail call ptr @bdrv_filter_or_cow_child(ptr noundef nonnull %top.addr.06.i)
  %tobool.not.i.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i.i, label %if.else20, label %bdrv_filter_or_cow_bs.exit.i

bdrv_filter_or_cow_bs.exit.i:                     ; preds = %while.body.i
  %4 = load ptr, ptr %call.i.i, align 8
  %tobool.i = icmp ne ptr %4, null
  %cmp.i = icmp ne ptr %4, %to
  %5 = and i1 %tobool.i, %cmp.i
  br i1 %5, label %while.body.i, label %bdrv_chain_contains.exit, !llvm.loop !51

bdrv_chain_contains.exit:                         ; preds = %bdrv_filter_or_cow_bs.exit.i
  br i1 %tobool.i, label %if.end21, label %if.else20

if.else20:                                        ; preds = %while.body.i, %bdrv_chain_contains.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.271, ptr noundef nonnull @.str.2, i32 noundef 5453, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_common) #31
  unreachable

if.end21:                                         ; preds = %bdrv_chain_contains.exit
  br i1 %cmp5.i.not, label %if.else24, label %for.cond

if.else24:                                        ; preds = %while.cond.preheader.i, %if.end21
  tail call void @__assert_fail(ptr noundef nonnull @.str.272, ptr noundef nonnull @.str.2, i32 noundef 5454, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_common) #31
  unreachable

for.cond:                                         ; preds = %if.end21, %for.cond.backedge
  %to_cow_parent.0 = phi ptr [ %to_cow_parent.0.be, %for.cond.backedge ], [ %from, %if.end21 ]
  %call.i31 = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %to_cow_parent.0)
  %tobool.not.i.i = icmp eq ptr %call.i31, null
  br i1 %tobool.not.i.i, label %bdrv_filter_or_cow_bs.exit, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %for.cond
  %6 = load ptr, ptr %call.i31, align 8
  br label %bdrv_filter_or_cow_bs.exit

bdrv_filter_or_cow_bs.exit:                       ; preds = %for.cond, %cond.true.i.i
  %cond.i.i = phi ptr [ %6, %cond.true.i.i ], [ null, %for.cond ]
  %cmp27.not = icmp eq ptr %cond.i.i, %to
  br i1 %cmp27.not, label %if.end29, label %for.inc

for.inc:                                          ; preds = %bdrv_filter_or_cow_bs.exit
  %call.i32 = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %to_cow_parent.0)
  %tobool.not.i.i33 = icmp eq ptr %call.i32, null
  br i1 %tobool.not.i.i33, label %for.cond.backedge, label %cond.true.i.i34

for.cond.backedge:                                ; preds = %for.inc, %cond.true.i.i34
  %to_cow_parent.0.be = phi ptr [ %7, %cond.true.i.i34 ], [ null, %for.inc ]
  br label %for.cond, !llvm.loop !52

cond.true.i.i34:                                  ; preds = %for.inc
  %7 = load ptr, ptr %call.i32, align 8
  br label %for.cond.backedge

if.end29:                                         ; preds = %bdrv_filter_or_cow_bs.exit
  %call31 = tail call fastcc i32 @bdrv_replace_node_noperm(ptr noundef %from, ptr noundef %to, i1 noundef zeroext %auto_skip, ptr noundef %call, ptr noundef %errp), !range !28
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %if.then.i, label %if.then36

if.end29.thread:                                  ; preds = %if.end15
  %call3142 = tail call fastcc i32 @bdrv_replace_node_noperm(ptr noundef nonnull %from, ptr noundef nonnull %to, i1 noundef zeroext %auto_skip, ptr noundef %call, ptr noundef %errp), !range !28
  %cmp3243 = icmp slt i32 %call3142, 0
  br i1 %cmp3243, label %if.then.i, label %out

if.then36:                                        ; preds = %if.end29
  %call37 = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %to_cow_parent.0)
  tail call fastcc void @bdrv_remove_child(ptr noundef %call37, ptr noundef %call)
  br label %out

out:                                              ; preds = %if.end29.thread, %if.then36
  %call39 = tail call ptr @g_slist_prepend(ptr noundef null, ptr noundef %to) #29
  %call40 = tail call ptr @g_slist_prepend(ptr noundef %call39, ptr noundef %from) #29
  %call41 = tail call fastcc i32 @bdrv_list_refresh_perms(ptr noundef %call40, ptr noundef null, ptr noundef %call, ptr noundef %errp), !range !14
  %cmp.i37 = icmp slt i32 %call41, 0
  br i1 %cmp.i37, label %if.then.i, label %if.else.i38

if.then.i:                                        ; preds = %if.end29.thread, %if.end29, %out
  %ret.052 = phi i32 [ %call41, %out ], [ %call3142, %if.end29.thread ], [ %call31, %if.end29 ]
  %refresh_list.050 = phi ptr [ %call40, %out ], [ null, %if.end29.thread ], [ null, %if.end29 ]
  tail call void @tran_abort(ptr noundef %call) #29
  br label %tran_finalize.exit

if.else.i38:                                      ; preds = %out
  tail call void @tran_commit(ptr noundef %call) #29
  br label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %if.then.i, %if.else.i38
  %ret.051 = phi i32 [ %ret.052, %if.then.i ], [ 0, %if.else.i38 ]
  %refresh_list.049 = phi ptr [ %refresh_list.050, %if.then.i ], [ %call40, %if.else.i38 ]
  %tobool.not.i.i39 = icmp eq ptr %refresh_list.049, null
  br i1 %tobool.not.i.i39, label %glib_autoptr_cleanup_GSList.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %tran_finalize.exit
  tail call void @g_slist_free(ptr noundef nonnull %refresh_list.049) #29
  br label %glib_autoptr_cleanup_GSList.exit

glib_autoptr_cleanup_GSList.exit:                 ; preds = %tran_finalize.exit, %if.then.i.i
  ret i32 %ret.051
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_drop_filter(ptr noundef %bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5505, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_drop_filter) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call.i = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %bs)
  %tobool.not.i.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i.i, label %bdrv_filter_or_cow_bs.exit, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %do.end
  %0 = load ptr, ptr %call.i, align 8
  br label %bdrv_filter_or_cow_bs.exit

bdrv_filter_or_cow_bs.exit:                       ; preds = %do.end, %cond.true.i.i
  %cond.i.i = phi ptr [ %0, %cond.true.i.i ], [ null, %do.end ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  tail call void @bdrv_drained_begin(ptr noundef %cond.i.i) #29
  tail call void @bdrv_graph_wrlock(ptr noundef %bs) #29
  %call2 = tail call fastcc i32 @bdrv_replace_node_common(ptr noundef %bs, ptr noundef %cond.i.i, i1 noundef zeroext true, i1 noundef zeroext true, ptr noundef %errp), !range !14
  tail call void @bdrv_graph_wrunlock(ptr noundef %bs) #29
  tail call void @bdrv_drained_end(ptr noundef %cond.i.i) #29
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_append(ptr noundef %bs_new, ptr noundef %bs_top, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @tran_new() #29
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5542, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_append) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %bs_new, i64 0, i32 30
  %0 = load ptr, ptr %backing, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end4, label %if.else3

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.88, ptr noundef nonnull @.str.2, i32 noundef 5545, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_append) #31
  unreachable

if.end4:                                          ; preds = %do.end
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  %tobool.not.i = icmp eq ptr %bs_top, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end4
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs_top, i64 0, i32 8
  %1 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit40

cond.false.i:                                     ; preds = %if.end4
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit40

bdrv_get_aio_context.exit40:                      ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %1, %cond.true.i ], [ %call.i, %cond.false.i ]
  tail call void @bdrv_drained_begin(ptr noundef %bs_top) #29
  %aio_context.i36 = getelementptr inbounds %struct.BlockDriverState, ptr %bs_new, i64 0, i32 8
  %2 = load ptr, ptr %aio_context.i36, align 8
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  tail call void @aio_context_acquire(ptr noundef %2) #29
  tail call void @bdrv_drained_begin(ptr noundef nonnull %bs_new) #29
  tail call void @aio_context_release(ptr noundef %2) #29
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  tail call void @bdrv_graph_wrlock(ptr noundef %bs_top) #29
  %3 = getelementptr i8, ptr %bs_new, i64 16
  %bs_new.val = load ptr, ptr %3, align 8
  %tobool.not.i41 = icmp eq ptr %bs_new.val, null
  br i1 %tobool.not.i41, label %if.else.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %bdrv_get_aio_context.exit40
  %is_filter.i = getelementptr inbounds %struct.BlockDriver, ptr %bs_new.val, i64 0, i32 2
  %4 = load i8, ptr %is_filter.i, align 4
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %if.else.i, label %bdrv_backing_role.exit

if.else.i:                                        ; preds = %land.lhs.true.i, %bdrv_get_aio_context.exit40
  br label %bdrv_backing_role.exit

bdrv_backing_role.exit:                           ; preds = %land.lhs.true.i, %if.else.i
  %retval.0.i = phi i32 [ 8, %if.else.i ], [ 20, %land.lhs.true.i ]
  %call8 = tail call fastcc ptr @bdrv_attach_child_noperm(ptr noundef nonnull %bs_new, ptr noundef %bs_top, ptr noundef nonnull @.str.89, ptr noundef nonnull @child_of_bds, i32 noundef %retval.0.i, ptr noundef %call, ptr noundef %errp)
  %tobool9.not = icmp eq ptr %call8, null
  br i1 %tobool9.not, label %if.then.i, label %if.end11

if.end11:                                         ; preds = %bdrv_backing_role.exit
  br i1 %tobool.not.i, label %cond.false.i46, label %cond.true.i43

cond.true.i43:                                    ; preds = %if.end11
  %aio_context.i44 = getelementptr inbounds %struct.BlockDriverState, ptr %bs_top, i64 0, i32 8
  %6 = load ptr, ptr %aio_context.i44, align 8
  br label %bdrv_get_aio_context.exit48

cond.false.i46:                                   ; preds = %if.end11
  %call.i47 = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit48

bdrv_get_aio_context.exit48:                      ; preds = %cond.true.i43, %cond.false.i46
  %cond.i45 = phi ptr [ %6, %cond.true.i43 ], [ %call.i47, %cond.false.i46 ]
  %cmp.not = icmp eq ptr %cond.i, %cond.i45
  br i1 %cmp.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %bdrv_get_aio_context.exit48
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  tail call void @aio_context_acquire(ptr noundef %cond.i45) #29
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %bdrv_get_aio_context.exit48
  %call15 = tail call fastcc i32 @bdrv_replace_node_noperm(ptr noundef %bs_top, ptr noundef nonnull %bs_new, i1 noundef zeroext true, ptr noundef %call, ptr noundef %errp), !range !28
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %if.then.i, label %out

out:                                              ; preds = %if.end14
  %call19 = tail call fastcc i32 @bdrv_refresh_perms(ptr noundef nonnull %bs_new, ptr noundef %call, ptr noundef %errp), !range !14
  %cmp.i = icmp slt i32 %call19, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i49

if.then.i:                                        ; preds = %bdrv_backing_role.exit, %if.end14, %out
  %new_context.056 = phi ptr [ %cond.i45, %out ], [ null, %bdrv_backing_role.exit ], [ %cond.i45, %if.end14 ]
  %ret.054 = phi i32 [ %call19, %out ], [ -22, %bdrv_backing_role.exit ], [ %call15, %if.end14 ]
  tail call void @tran_abort(ptr noundef %call) #29
  br label %tran_finalize.exit

if.else.i49:                                      ; preds = %out
  tail call void @tran_commit(ptr noundef %call) #29
  br label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %if.then.i, %if.else.i49
  %new_context.055 = phi ptr [ %new_context.056, %if.then.i ], [ %cond.i45, %if.else.i49 ]
  %ret.053 = phi i32 [ %ret.054, %if.then.i ], [ 0, %if.else.i49 ]
  tail call void @bdrv_refresh_limits(ptr noundef %bs_top, ptr noundef null, ptr noundef null) #29
  tail call void @bdrv_graph_wrunlock(ptr noundef %bs_top) #29
  tail call void @bdrv_drained_end(ptr noundef %bs_top) #29
  tail call void @bdrv_drained_end(ptr noundef nonnull %bs_new) #29
  %tobool20.not = icmp eq ptr %new_context.055, null
  %cmp21.not = icmp eq ptr %cond.i, %new_context.055
  %or.cond = select i1 %tobool20.not, i1 true, i1 %cmp21.not
  br i1 %or.cond, label %if.end23, label %if.then22

if.then22:                                        ; preds = %tran_finalize.exit
  tail call void @aio_context_release(ptr noundef nonnull %new_context.055) #29
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %tran_finalize.exit
  ret i32 %ret.053
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_replace_node_noperm(ptr noundef %from, ptr noundef %to, i1 noundef zeroext %auto_skip, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5398, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #31
  unreachable

do.end:                                           ; preds = %entry
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %from, i64 0, i32 46
  %0 = load i32, ptr %quiesce_counter, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.else2, label %if.end3

if.else2:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.268, ptr noundef nonnull @.str.2, i32 noundef 5400, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #31
  unreachable

if.end3:                                          ; preds = %do.end
  %quiesce_counter4 = getelementptr inbounds %struct.BlockDriverState, ptr %to, i64 0, i32 46
  %1 = load i32, ptr %quiesce_counter4, align 8
  %tobool5.not = icmp eq i32 %1, 0
  br i1 %tobool5.not, label %if.else7, label %if.end8

if.else7:                                         ; preds = %if.end3
  tail call void @__assert_fail(ptr noundef nonnull @.str.269, ptr noundef nonnull @.str.2, i32 noundef 5401, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #31
  unreachable

if.end8:                                          ; preds = %if.end3
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %from, i64 0, i32 32
  %2 = load ptr, ptr %parents, align 8
  %tobool9.not19 = icmp eq ptr %2, null
  br i1 %tobool9.not19, label %return, label %land.rhs

land.rhs:                                         ; preds = %if.end8, %for.inc
  %c.020 = phi ptr [ %3, %for.inc ], [ %2, %if.end8 ]
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %c.020, i64 0, i32 10
  %3 = load ptr, ptr %next_parent, align 8
  %4 = load ptr, ptr %c.020, align 8
  %cmp = icmp eq ptr %4, %from
  br i1 %cmp, label %if.end12, label %if.else11

if.else11:                                        ; preds = %land.rhs
  tail call void @__assert_fail(ptr noundef nonnull @.str.273, ptr noundef nonnull @.str.2, i32 noundef 5404, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #31
  unreachable

if.end12:                                         ; preds = %land.rhs
  %klass.i = getelementptr inbounds %struct.BdrvChild, ptr %c.020, i64 0, i32 2
  %5 = load ptr, ptr %klass.i, align 8
  %6 = load i8, ptr %5, align 8
  %7 = and i8 %6, 1
  %tobool.not.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then14

if.end.i:                                         ; preds = %if.end12
  %call.i = tail call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  %call1.i = tail call i32 @g_hash_table_add(ptr noundef %call.i, ptr noundef %to) #29
  %call2.i = tail call ptr @g_queue_new() #29
  tail call void @g_queue_push_tail(ptr noundef %call2.i, ptr noundef %to) #29
  %call319.i = tail call i32 @g_queue_is_empty(ptr noundef %call2.i) #29
  %tobool4.not20.i = icmp eq i32 %call319.i, 0
  br i1 %tobool4.not20.i, label %while.body.i, label %if.end18.critedge

while.body.i:                                     ; preds = %if.end.i, %for.end.i
  %ret.021.i = phi i8 [ %ret.1.i, %for.end.i ], [ 1, %if.end.i ]
  %call5.i = tail call ptr @g_queue_pop_head(ptr noundef %call2.i) #29
  %children.i = getelementptr inbounds %struct.BlockDriverState, ptr %call5.i, i64 0, i32 29
  %c2.015.i = load ptr, ptr %children.i, align 8
  %tobool6.not16.i = icmp eq ptr %c2.015.i, null
  br i1 %tobool6.not16.i, label %for.end.i, label %for.body.i

for.body.i:                                       ; preds = %while.body.i, %for.inc.i
  %c2.017.i = phi ptr [ %c2.0.i, %for.inc.i ], [ %c2.015.i, %while.body.i ]
  %cmp.i = icmp eq ptr %c2.017.i, %c.020
  br i1 %cmp.i, label %for.end.i, label %if.end8.i

if.end8.i:                                        ; preds = %for.body.i
  %8 = load ptr, ptr %c2.017.i, align 8
  %call9.i = tail call i32 @g_hash_table_contains(ptr noundef %call.i, ptr noundef %8) #29
  %tobool10.not.i = icmp eq i32 %call9.i, 0
  br i1 %tobool10.not.i, label %if.end12.i, label %for.inc.i

if.end12.i:                                       ; preds = %if.end8.i
  %9 = load ptr, ptr %c2.017.i, align 8
  tail call void @g_queue_push_tail(ptr noundef %call2.i, ptr noundef %9) #29
  %10 = load ptr, ptr %c2.017.i, align 8
  %call15.i = tail call i32 @g_hash_table_add(ptr noundef %call.i, ptr noundef %10) #29
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end12.i, %if.end8.i
  %next.i = getelementptr inbounds %struct.BdrvChild, ptr %c2.017.i, i64 0, i32 9
  %c2.0.i = load ptr, ptr %next.i, align 8
  %tobool6.not.i = icmp eq ptr %c2.0.i, null
  br i1 %tobool6.not.i, label %for.end.i, label %for.body.i, !llvm.loop !53

for.end.i:                                        ; preds = %for.inc.i, %for.body.i, %while.body.i
  %ret.1.i = phi i8 [ %ret.021.i, %while.body.i ], [ %ret.021.i, %for.inc.i ], [ 0, %for.body.i ]
  %call3.i = tail call i32 @g_queue_is_empty(ptr noundef %call2.i) #29
  %tobool4.not.i = icmp eq i32 %call3.i, 0
  br i1 %tobool4.not.i, label %while.body.i, label %while.end.loopexit.i, !llvm.loop !54

while.end.loopexit.i:                             ; preds = %for.end.i
  %11 = and i8 %ret.1.i, 1
  %.not = icmp eq i8 %11, 0
  tail call void @g_queue_free(ptr noundef %call2.i) #29
  tail call void @g_hash_table_destroy(ptr noundef %call.i) #29
  br i1 %.not, label %if.then14, label %if.end18

if.then14:                                        ; preds = %if.end12, %while.end.loopexit.i
  br i1 %auto_skip, label %for.inc, label %if.end17

if.end17:                                         ; preds = %if.then14
  %name = getelementptr inbounds %struct.BdrvChild, ptr %c.020, i64 0, i32 1
  %12 = load ptr, ptr %name, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %from, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5410, ptr noundef nonnull @__func__.bdrv_replace_node_noperm, ptr noundef nonnull @.str.274, ptr noundef %12, ptr noundef nonnull %node_name) #29
  br label %return

if.end18.critedge:                                ; preds = %if.end.i
  tail call void @g_queue_free(ptr noundef %call2.i) #29
  tail call void @g_hash_table_destroy(ptr noundef %call.i) #29
  br label %if.end18

if.end18:                                         ; preds = %if.end18.critedge, %while.end.loopexit.i
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %c.020, i64 0, i32 7
  %13 = load i8, ptr %frozen, align 8
  %14 = and i8 %13, 1
  %tobool19.not = icmp eq i8 %14, 0
  br i1 %tobool19.not, label %if.end24, label %if.then20

if.then20:                                        ; preds = %if.end18
  %name21 = getelementptr inbounds %struct.BdrvChild, ptr %c.020, i64 0, i32 1
  %15 = load ptr, ptr %name21, align 8
  %node_name22 = getelementptr inbounds %struct.BlockDriverState, ptr %from, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5415, ptr noundef nonnull @__func__.bdrv_replace_node_noperm, ptr noundef nonnull @.str.275, ptr noundef %15, ptr noundef nonnull %node_name22) #29
  br label %return

if.end24:                                         ; preds = %if.end18
  tail call fastcc void @bdrv_replace_child_tran(ptr noundef nonnull %c.020, ptr noundef %to, ptr noundef %tran)
  br label %for.inc

for.inc:                                          ; preds = %if.then14, %if.end24
  %tobool9.not = icmp eq ptr %3, null
  br i1 %tobool9.not, label %return, label %land.rhs, !llvm.loop !55

return:                                           ; preds = %for.inc, %if.end8, %if.then20, %if.end17
  %retval.0 = phi i32 [ -1, %if.then20 ], [ -22, %if.end17 ], [ 0, %if.end8 ], [ 0, %for.inc ]
  ret i32 %retval.0
}

declare void @bdrv_refresh_limits(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_replace_child_bs(ptr noundef %child, ptr noundef %new_bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call ptr @tran_new() #29
  %0 = load ptr, ptr %child, align 8
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5618, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_bs) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_ref.exit, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %do.end
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 26
  %1 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %1, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  tail call void @bdrv_drained_begin(ptr noundef %0) #29
  tail call void @bdrv_drained_begin(ptr noundef %new_bs) #29
  tail call void @bdrv_graph_wrlock(ptr noundef %new_bs) #29
  tail call fastcc void @bdrv_replace_child_tran(ptr noundef nonnull %child, ptr noundef %new_bs, ptr noundef %call)
  %call2 = tail call ptr @g_slist_prepend(ptr noundef null, ptr noundef %0) #29
  %call3 = tail call ptr @g_slist_prepend(ptr noundef %call2, ptr noundef %new_bs) #29
  %call4 = tail call fastcc i32 @bdrv_list_refresh_perms(ptr noundef %call3, ptr noundef null, ptr noundef %call, ptr noundef %errp), !range !14
  %cmp.i = icmp slt i32 %call4, 0
  br i1 %cmp.i, label %if.then.i, label %if.else.i14

if.then.i:                                        ; preds = %bdrv_ref.exit
  tail call void @tran_abort(ptr noundef %call) #29
  br label %tran_finalize.exit

if.else.i14:                                      ; preds = %bdrv_ref.exit
  tail call void @tran_commit(ptr noundef %call) #29
  br label %tran_finalize.exit

tran_finalize.exit:                               ; preds = %if.then.i, %if.else.i14
  tail call void @bdrv_graph_wrunlock(ptr noundef %new_bs) #29
  tail call void @bdrv_drained_end(ptr noundef nonnull %0) #29
  tail call void @bdrv_drained_end(ptr noundef %new_bs) #29
  tail call void @bdrv_unref(ptr noundef nonnull %0)
  %tobool.not.i.i = icmp eq ptr %call3, null
  br i1 %tobool.not.i.i, label %glib_autoptr_cleanup_GSList.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %tran_finalize.exit
  tail call void @g_slist_free(ptr noundef nonnull %call3) #29
  br label %glib_autoptr_cleanup_GSList.exit

glib_autoptr_cleanup_GSList.exit:                 ; preds = %tran_finalize.exit, %if.then.i.i
  ret i32 %call4
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @bdrv_replace_child_tran(ptr noundef %child, ptr noundef %new_bs, ptr noundef %tran) unnamed_addr #4 {
entry:
  %call = tail call noalias dereferenceable_or_null(16) ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #32
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 8
  %0 = load i8, ptr %quiesced_parent, align 1
  %1 = and i8 %0, 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.215, ptr noundef nonnull @.str.2, i32 noundef 2464, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_tran) #31
  unreachable

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq ptr %new_bs, null
  br i1 %tobool1.not, label %if.end5.split, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %new_bs, i64 0, i32 46
  %2 = load i32, ptr %quiesce_counter, align 8
  %tobool2.not = icmp eq i32 %2, 0
  br i1 %tobool2.not, label %if.else4, label %if.then8

if.else4:                                         ; preds = %lor.lhs.false
  tail call void @__assert_fail(ptr noundef nonnull @.str.276, ptr noundef nonnull @.str.2, i32 noundef 2465, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_tran) #31
  unreachable

if.end5.split:                                    ; preds = %if.end
  %3 = load ptr, ptr %child, align 8
  store ptr %child, ptr %call, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.c = getelementptr inbounds i8, ptr %call, i64 8
  store ptr %3, ptr %.compoundliteral.sroa.2.0..sroa_idx.c, align 8
  tail call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_replace_child_drv, ptr noundef nonnull %call) #29
  tail call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %child, ptr noundef null)
  br label %if.end9

if.then8:                                         ; preds = %lor.lhs.false
  %4 = load ptr, ptr %child, align 8
  store ptr %child, ptr %call, align 8
  %.compoundliteral.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 8
  store ptr %4, ptr %.compoundliteral.sroa.2.0..sroa_idx, align 8
  tail call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_replace_child_drv, ptr noundef nonnull %call) #29
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_ref.exit, label %if.else.i

if.else.i:                                        ; preds = %if.then8
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %if.then8
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %new_bs, i64 0, i32 26
  %5 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %5, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  tail call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %child, ptr noundef nonnull %new_bs)
  br label %if.end9

if.end9:                                          ; preds = %if.end5.split, %bdrv_ref.exit
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_insert_node(ptr noundef %bs, ptr noundef %options, i32 noundef %flags, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %_auto_errp_prop = alloca %struct.ErrorPropagator, align 8
  store ptr null, ptr %_auto_errp_prop, align 8
  %errp1 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i64 0, i32 1
  store ptr %errp, ptr %errp1, align 8
  %tobool = icmp eq ptr %errp, null
  %cmp = icmp eq ptr %errp, @error_fatal
  %or.cond = or i1 %tobool, %cmp
  %spec.select = select i1 %or.cond, ptr %_auto_errp_prop, ptr %errp
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call3 = tail call ptr @qdict_get_try_str(ptr noundef %options, ptr noundef nonnull @.str.20) #29
  %tobool4.not = icmp eq ptr %call3, null
  br i1 %tobool4.not, label %if.then5, label %if.end6

if.then5:                                         ; preds = %bdrv_get_aio_context.exit
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %spec.select, ptr noundef nonnull @.str.2, i32 noundef 5686, ptr noundef nonnull @__func__.bdrv_insert_node, ptr noundef nonnull @.str.90) #29
  br label %fail

if.end6:                                          ; preds = %bdrv_get_aio_context.exit
  %call.i33 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i33, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.end6
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_format) #31
  unreachable

do.end.i:                                         ; preds = %if.end6
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %for.cond.preheader.i.i, label %if.else.i.i

for.cond.preheader.i.i:                           ; preds = %do.end.i
  %drv1.04.i.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not5.i.i = icmp eq ptr %drv1.04.i.i, null
  br i1 %tobool.not5.i.i, label %if.then9, label %for.body.i.i

if.else.i.i:                                      ; preds = %do.end.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 444, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_format) #31
  unreachable

for.body.i.i:                                     ; preds = %for.cond.preheader.i.i, %for.inc.i.i
  %drv1.06.i.i = phi ptr [ %drv1.0.i.i, %for.inc.i.i ], [ %drv1.04.i.i, %for.cond.preheader.i.i ]
  %1 = load ptr, ptr %drv1.06.i.i, align 8
  %call2.i.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %1, ptr noundef nonnull dereferenceable(1) %call3) #28
  %tobool3.not.i.i = icmp eq i32 %call2.i.i, 0
  br i1 %tobool3.not.i.i, label %if.end10, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %list.i.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i, i64 0, i32 61
  %drv1.0.i.i = load ptr, ptr %list.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %drv1.0.i.i, null
  br i1 %tobool.not.i.i, label %if.then9, label %for.body.i.i, !llvm.loop !8

if.then9:                                         ; preds = %for.inc.i.i, %for.cond.preheader.i.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %spec.select, ptr noundef nonnull @.str.2, i32 noundef 5692, ptr noundef nonnull @__func__.bdrv_insert_node, ptr noundef nonnull @.str.91, ptr noundef nonnull %call3) #29
  br label %fail

if.end10:                                         ; preds = %for.body.i.i
  %call11 = tail call ptr @qdict_get_try_str(ptr noundef %options, ptr noundef nonnull @.str.44) #29
  %call13 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call13, label %do.end17, label %if.else

if.else:                                          ; preds = %if.end10
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5698, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_insert_node) #31
  unreachable

do.end17:                                         ; preds = %if.end10
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  %call18 = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_context_acquire(ptr noundef %call18) #29
  %call19 = call ptr @bdrv_new_open_driver_opts(ptr noundef nonnull %drv1.06.i.i, ptr noundef %call11, ptr noundef %options, i32 noundef %flags, ptr noundef %spec.select)
  %call20 = call ptr @qemu_get_aio_context() #29
  call void @aio_context_release(ptr noundef %call20) #29
  call void @aio_context_acquire(ptr noundef %cond.i) #29
  br i1 %tobool.not.i, label %cond.false.i38, label %cond.true.i35

cond.true.i35:                                    ; preds = %do.end17
  %aio_context.i36 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %2 = load ptr, ptr %aio_context.i36, align 8
  br label %bdrv_get_aio_context.exit40

cond.false.i38:                                   ; preds = %do.end17
  %call.i39 = call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit40

bdrv_get_aio_context.exit40:                      ; preds = %cond.true.i35, %cond.false.i38
  %cond.i37 = phi ptr [ %2, %cond.true.i35 ], [ %call.i39, %cond.false.i38 ]
  %cmp22 = icmp eq ptr %cond.i37, %cond.i
  br i1 %cmp22, label %if.end25, label %if.else24

if.else24:                                        ; preds = %bdrv_get_aio_context.exit40
  call void @__assert_fail(ptr noundef nonnull @.str.92, ptr noundef nonnull @.str.2, i32 noundef 5706, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_insert_node) #31
  unreachable

if.end25:                                         ; preds = %bdrv_get_aio_context.exit40
  %tobool26.not = icmp eq ptr %call19, null
  br i1 %tobool26.not, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end25
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %spec.select, ptr noundef nonnull @.str.93) #29
  br label %qobject_unref_impl.exit

if.end28:                                         ; preds = %if.end25
  %call.i41 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i41, label %bdrv_ref.exit, label %if.else.i42

if.else.i42:                                      ; preds = %if.end28
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %if.end28
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 26
  %3 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %3, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  call void @bdrv_drained_begin(ptr noundef %bs) #29
  call void @bdrv_drained_begin(ptr noundef nonnull %call19) #29
  call void @bdrv_graph_wrlock(ptr noundef nonnull %call19) #29
  %call.i44 = call fastcc i32 @bdrv_replace_node_common(ptr noundef %bs, ptr noundef nonnull %call19, i1 noundef zeroext true, i1 noundef zeroext false, ptr noundef %spec.select), !range !14
  call void @bdrv_graph_wrunlock(ptr noundef nonnull %call19) #29
  call void @bdrv_drained_end(ptr noundef nonnull %call19) #29
  call void @bdrv_drained_end(ptr noundef %bs) #29
  call void @bdrv_unref(ptr noundef %bs)
  %cmp30 = icmp slt i32 %call.i44, 0
  br i1 %cmp30, label %if.then31, label %cleanup

if.then31:                                        ; preds = %bdrv_ref.exit
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %spec.select, ptr noundef nonnull @.str.94) #29
  br label %qobject_unref_impl.exit

fail:                                             ; preds = %if.then9, %if.then5
  %tobool33.not = icmp eq ptr %options, null
  br i1 %tobool33.not, label %qobject_unref_impl.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %fail
  %refcnt.i45 = getelementptr inbounds %struct.QObjectBase_, ptr %options, i64 0, i32 1
  %4 = load i64, ptr %refcnt.i45, align 8
  %tobool1.not.i = icmp eq i64 %4, 0
  br i1 %tobool1.not.i, label %if.else.i46, label %land.lhs.true.i

if.else.i46:                                      ; preds = %lor.lhs.false.i
  call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %4, -1
  store i64 %dec.i, ptr %refcnt.i45, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %qobject_unref_impl.exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  call void @qobject_destroy(ptr noundef nonnull %options) #29
  br label %qobject_unref_impl.exit

qobject_unref_impl.exit:                          ; preds = %if.then27, %if.then31, %fail, %land.lhs.true.i, %if.then5.i
  %new_node_bs.052 = phi ptr [ null, %fail ], [ null, %land.lhs.true.i ], [ null, %if.then5.i ], [ null, %if.then27 ], [ %call19, %if.then31 ]
  call void @bdrv_unref(ptr noundef %new_node_bs.052)
  br label %cleanup

cleanup:                                          ; preds = %bdrv_ref.exit, %qobject_unref_impl.exit
  %retval.0 = phi ptr [ null, %qobject_unref_impl.exit ], [ %call19, %bdrv_ref.exit ]
  %_auto_errp_prop.val = load ptr, ptr %_auto_errp_prop, align 8
  %_auto_errp_prop.val32 = load ptr, ptr %errp1, align 8
  call void @error_propagate(ptr noundef %_auto_errp_prop.val32, ptr noundef %_auto_errp_prop.val) #29
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_check(ptr noundef %bs, ptr noundef %res, i32 noundef %fix) #4 {
entry:
  tail call void @assert_bdrv_graph_readable() #29
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %bdrv_co_check = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 106
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_check, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 773, ptr null)
  %2 = load ptr, ptr %1, align 8
  %cmp2 = icmp eq ptr %2, null
  br i1 %cmp2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(64) %res, i8 0, i64 64, i1 false)
  %3 = load ptr, ptr %drv, align 8
  %bdrv_co_check6 = getelementptr inbounds %struct.BlockDriver, ptr %3, i64 0, i32 106
  %4 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_check6, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 773, ptr null)
  %5 = load ptr, ptr %4, align 8
  %call = tail call i32 %5(ptr noundef nonnull %bs, ptr noundef %res, i32 noundef %fix) #29
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i32 [ %call, %if.end4 ], [ -123, %entry ], [ -95, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #16

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_change_backing_file(ptr noundef %bs, ptr noundef %backing_file, ptr noundef %backing_fmt, i1 noundef zeroext %require) #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool2 = icmp eq ptr %backing_fmt, null
  %tobool3 = icmp ne ptr %backing_file, null
  %or.cond1 = and i1 %tobool3, %require
  %1 = xor i1 %tobool3, true
  %or.cond19 = select i1 %tobool2, i1 %or.cond1, i1 %1
  br i1 %or.cond19, label %return, label %if.end12

if.end12:                                         ; preds = %if.end
  %bdrv_co_change_backing_file = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 40
  %2 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_change_backing_file, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 334, ptr null)
  %3 = load ptr, ptr %2, align 8
  %cmp.not = icmp eq ptr %3, null
  br i1 %cmp.not, label %return, label %if.end15

if.end15:                                         ; preds = %if.end12
  %4 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_change_backing_file, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 334, ptr null)
  %5 = load ptr, ptr %4, align 8
  %call = tail call i32 %5(ptr noundef nonnull %bs, ptr noundef %backing_file, ptr noundef %backing_fmt) #29
  %cmp16 = icmp eq i32 %call, 0
  br i1 %cmp16, label %if.then17, label %return

if.then17:                                        ; preds = %if.end15
  %backing_file18 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 12
  %..str.95 = select i1 %tobool3, ptr %backing_file, ptr @.str.95
  tail call void @pstrcpy(ptr noundef nonnull %backing_file18, i32 noundef 4096, ptr noundef nonnull %..str.95) #29
  %backing_format = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 14
  %cond25 = select i1 %tobool2, ptr @.str.95, ptr %backing_fmt
  tail call void @pstrcpy(ptr noundef nonnull %backing_format, i32 noundef 16, ptr noundef nonnull %cond25) #29
  %auto_backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 13
  tail call void @pstrcpy(ptr noundef nonnull %auto_backing_file, i32 noundef 4096, ptr noundef nonnull %..str.95) #29
  br label %return

return:                                           ; preds = %if.end12, %if.end15, %if.then17, %if.end, %entry
  %retval.0 = phi i32 [ -123, %entry ], [ -22, %if.end ], [ 0, %if.then17 ], [ %call, %if.end15 ], [ -95, %if.end12 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_overlay(ptr noundef %active, ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5823, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_overlay) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %bs, i1 noundef zeroext false)
  %call.i6 = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %active, i1 noundef zeroext false)
  br label %while.cond

while.cond:                                       ; preds = %bdrv_backing_chain_next.exit, %do.end
  %active.addr.0 = phi ptr [ %call.i6, %do.end ], [ %call.i1.i, %bdrv_backing_chain_next.exit ]
  %tobool.not = icmp eq ptr %active.addr.0, null
  br i1 %tobool.not, label %return, label %while.body

while.body:                                       ; preds = %while.cond
  %call.i.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef nonnull %active.addr.0, i1 noundef zeroext false)
  %tobool.not.i.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i.i, label %bdrv_backing_chain_next.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %while.body
  %drv.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %call.i.i, i64 0, i32 6
  %0 = load ptr, ptr %drv.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq ptr %0, null
  br i1 %tobool1.not.i.i.i, label %bdrv_backing_chain_next.exit, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %lor.lhs.false.i.i.i
  %is_filter.i.i.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter.i.i.i, align 4
  %2 = and i8 %1, 1
  %tobool3.not.i.i.i = icmp eq i8 %2, 0
  br i1 %tobool3.not.i.i.i, label %if.end5.i.i.i, label %bdrv_backing_chain_next.exit

if.end5.i.i.i:                                    ; preds = %if.end.i.i.i
  %backing.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %call.i.i, i64 0, i32 30
  %3 = load ptr, ptr %backing.i.i.i, align 8
  %tobool6.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool6.not.i.i.i, label %bdrv_backing_chain_next.exit, label %if.end8.i.i.i

if.end8.i.i.i:                                    ; preds = %if.end5.i.i.i
  %role.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %role.i.i.i, align 8
  %and.i.i.i = and i32 %4, 8
  %tobool10.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool10.not.i.i.i, label %if.else.i.i.i, label %cond.true.i.i.i

if.else.i.i.i:                                    ; preds = %if.end8.i.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

cond.true.i.i.i:                                  ; preds = %if.end8.i.i.i
  %5 = load ptr, ptr %3, align 8
  br label %bdrv_backing_chain_next.exit

bdrv_backing_chain_next.exit:                     ; preds = %while.body, %lor.lhs.false.i.i.i, %if.end.i.i.i, %if.end5.i.i.i, %cond.true.i.i.i
  %cond.i.i.i = phi ptr [ %5, %cond.true.i.i.i ], [ null, %lor.lhs.false.i.i.i ], [ null, %while.body ], [ null, %if.end.i.i.i ], [ null, %if.end5.i.i.i ]
  %call.i1.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %cond.i.i.i, i1 noundef zeroext false)
  %cmp = icmp eq ptr %call.i, %call.i1.i
  br i1 %cmp, label %return, label %while.cond, !llvm.loop !56

return:                                           ; preds = %while.cond, %bdrv_backing_chain_next.exit
  ret ptr %active.addr.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_skip_filters(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %call = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %bs, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_backing_chain_next(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %call.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %bs, i1 noundef zeroext false)
  %tobool.not.i.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i.i, label %bdrv_cow_bs.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %entry
  %drv.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %call.i, i64 0, i32 6
  %0 = load ptr, ptr %drv.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %0, null
  br i1 %tobool1.not.i.i, label %bdrv_cow_bs.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %lor.lhs.false.i.i
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter.i.i, align 4
  %2 = and i8 %1, 1
  %tobool3.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool3.not.i.i, label %if.end5.i.i, label %bdrv_cow_bs.exit

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %call.i, i64 0, i32 30
  %3 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %3, null
  br i1 %tobool6.not.i.i, label %bdrv_cow_bs.exit, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %if.end5.i.i
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %4, 8
  %tobool10.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool10.not.i.i, label %if.else.i.i, label %cond.true.i.i

if.else.i.i:                                      ; preds = %if.end8.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

cond.true.i.i:                                    ; preds = %if.end8.i.i
  %5 = load ptr, ptr %3, align 8
  br label %bdrv_cow_bs.exit

bdrv_cow_bs.exit:                                 ; preds = %entry, %lor.lhs.false.i.i, %if.end.i.i, %if.end5.i.i, %cond.true.i.i
  %cond.i.i = phi ptr [ %5, %cond.true.i.i ], [ null, %lor.lhs.false.i.i ], [ null, %entry ], [ null, %if.end.i.i ], [ null, %if.end5.i.i ]
  %call.i1 = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %cond.i.i, i1 noundef zeroext false)
  ret ptr %call.i1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_base(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5842, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_base) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call ptr @bdrv_find_overlay(ptr noundef %bs, ptr noundef null)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_freeze_backing_chain(ptr noundef %bs, ptr noundef readnone %base, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5887, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_freeze_backing_chain) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %for.cond.preheader.i, label %if.else.i

for.cond.preheader.i:                             ; preds = %do.end
  %cmp.not12.not.i = icmp eq ptr %bs, %base
  br i1 %cmp.not12.not.i, label %return, label %for.body.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5859, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_is_backing_chain_frozen) #31
  unreachable

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %i.013.i = phi ptr [ %phi.call.i, %for.inc.i ], [ %bs, %for.cond.preheader.i ]
  %call1.i = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %i.013.i)
  %tobool.not.i = icmp eq ptr %call1.i, null
  br i1 %tobool.not.i, label %for.inc.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %for.body.i
  %frozen.i = getelementptr inbounds %struct.BdrvChild, ptr %call1.i, i64 0, i32 7
  %0 = load i8, ptr %frozen.i, align 8
  %1 = and i8 %0, 1
  %tobool2.not.i = icmp eq i8 %1, 0
  br i1 %tobool2.not.i, label %child_bs.exit.i, label %bdrv_is_backing_chain_frozen.exit.thread

child_bs.exit.i:                                  ; preds = %land.lhs.true.i
  %2 = load ptr, ptr %call1.i, align 8
  br label %for.inc.i

bdrv_is_backing_chain_frozen.exit.thread:         ; preds = %land.lhs.true.i
  %name.i = getelementptr inbounds %struct.BdrvChild, ptr %call1.i, i64 0, i32 1
  %3 = load ptr, ptr %name.i, align 8
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %i.013.i, i64 0, i32 22
  %4 = load ptr, ptr %call1.i, align 8
  %node_name5.i = getelementptr inbounds %struct.BlockDriverState, ptr %4, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5866, ptr noundef nonnull @__func__.bdrv_is_backing_chain_frozen, ptr noundef nonnull @.str.279, ptr noundef %3, ptr noundef nonnull %node_name.i, ptr noundef nonnull %node_name5.i) #29
  br label %return

for.inc.i:                                        ; preds = %child_bs.exit.i, %for.body.i
  %phi.call.i = phi ptr [ %2, %child_bs.exit.i ], [ null, %for.body.i ]
  %cmp.not.not.i = icmp eq ptr %phi.call.i, %base
  br i1 %cmp.not.not.i, label %bdrv_is_backing_chain_frozen.exit, label %for.body.i, !llvm.loop !57

bdrv_is_backing_chain_frozen.exit:                ; preds = %for.inc.i
  br i1 %cmp.not12.not.i, label %return, label %for.body

for.cond11.preheader:                             ; preds = %for.inc
  br i1 %cmp.not12.not.i, label %return, label %for.body13

for.body:                                         ; preds = %bdrv_is_backing_chain_frozen.exit, %for.inc
  %i.031 = phi ptr [ %phi.call, %for.inc ], [ %bs, %bdrv_is_backing_chain_frozen.exit ]
  %call4 = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %i.031)
  %tobool.not = icmp eq ptr %call4, null
  br i1 %tobool.not, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load ptr, ptr %call4, align 8
  %never_freeze = getelementptr inbounds %struct.BlockDriverState, ptr %5, i64 0, i32 53
  %6 = load i8, ptr %never_freeze, align 8
  %7 = and i8 %6, 1
  %tobool6.not = icmp eq i8 %7, 0
  br i1 %tobool6.not, label %for.inc, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %name = getelementptr inbounds %struct.BdrvChild, ptr %call4, i64 0, i32 1
  %8 = load ptr, ptr %name, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %5, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 5897, ptr noundef nonnull @__func__.bdrv_freeze_backing_chain, ptr noundef nonnull @.str.96, ptr noundef %8, ptr noundef nonnull %node_name) #29
  br label %return

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %phi.call = phi ptr [ null, %for.body ], [ %5, %land.lhs.true ]
  %cmp.not = icmp eq ptr %phi.call, %base
  br i1 %cmp.not, label %for.cond11.preheader, label %for.body, !llvm.loop !58

for.body13:                                       ; preds = %for.cond11.preheader, %for.inc18
  %i.133 = phi ptr [ %phi.call20, %for.inc18 ], [ %bs, %for.cond11.preheader ]
  %call14 = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %i.133)
  %tobool15.not = icmp eq ptr %call14, null
  br i1 %tobool15.not, label %for.inc18, label %child_bs.exit26

child_bs.exit26:                                  ; preds = %for.body13
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %call14, i64 0, i32 7
  store i8 1, ptr %frozen, align 8
  %9 = load ptr, ptr %call14, align 8
  br label %for.inc18

for.inc18:                                        ; preds = %for.body13, %child_bs.exit26
  %phi.call20 = phi ptr [ %9, %child_bs.exit26 ], [ null, %for.body13 ]
  %cmp12.not = icmp eq ptr %phi.call20, %base
  br i1 %cmp12.not, label %return, label %for.body13, !llvm.loop !59

return:                                           ; preds = %for.inc18, %for.cond.preheader.i, %bdrv_is_backing_chain_frozen.exit, %for.cond11.preheader, %bdrv_is_backing_chain_frozen.exit.thread, %if.then7
  %retval.0 = phi i32 [ -1, %if.then7 ], [ -1, %bdrv_is_backing_chain_frozen.exit.thread ], [ 0, %for.cond11.preheader ], [ 0, %bdrv_is_backing_chain_frozen.exit ], [ 0, %for.cond.preheader.i ], [ 0, %for.inc18 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_filter_or_cow_child(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %if.end, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %entry
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv.i, align 8
  %tobool1.not.i = icmp eq ptr %0, null
  br i1 %tobool1.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  %is_filter.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter.i, align 4
  %2 = and i8 %1, 1
  %tobool3.not.i = icmp eq i8 %2, 0
  br i1 %tobool3.not.i, label %if.end5.i, label %if.end.i8

if.end5.i:                                        ; preds = %if.end.i
  %backing.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %3 = load ptr, ptr %backing.i, align 8
  %tobool6.not.i = icmp eq ptr %3, null
  br i1 %tobool6.not.i, label %if.end.i8, label %if.end8.i

if.end8.i:                                        ; preds = %if.end5.i
  %role.i = getelementptr inbounds %struct.BdrvChild, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %role.i, align 8
  %and.i = and i32 %4, 8
  %tobool10.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool10.not.i, label %if.else.i, label %if.end.i8

if.else.i:                                        ; preds = %if.end8.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

if.end.i8:                                        ; preds = %if.end.i, %if.end5.i, %if.end8.i
  %retval.0.i.ph.ph = phi ptr [ null, %if.end.i ], [ null, %if.end5.i ], [ %3, %if.end8.i ]
  %is_filter.i9 = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %5 = load i8, ptr %is_filter.i9, align 4
  %6 = and i8 %5, 1
  %tobool3.not.i10 = icmp eq i8 %6, 0
  br i1 %tobool3.not.i10, label %if.end, label %if.end5.i11

if.end5.i11:                                      ; preds = %if.end.i8
  %backing.i12 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %7 = load ptr, ptr %backing.i12, align 8
  %tobool6.not.i13 = icmp eq ptr %7, null
  %file12.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 31
  %8 = load ptr, ptr %file12.i, align 8
  %tobool13.not.i = icmp eq ptr %8, null
  br i1 %tobool6.not.i13, label %cond.end.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end5.i11
  br i1 %tobool13.not.i, label %if.end15.i, label %if.else.i14

if.else.i14:                                      ; preds = %land.lhs.true.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i:                                       ; preds = %if.end5.i11
  br i1 %tobool13.not.i, label %if.end, label %if.end15.i

if.end15.i:                                       ; preds = %cond.end.i, %land.lhs.true.i
  %cond12.i = phi ptr [ %8, %cond.end.i ], [ %7, %land.lhs.true.i ]
  %role.i15 = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i, i64 0, i32 3
  %9 = load i32, ptr %role.i15, align 8
  %and.i16 = and i32 %9, 4
  %tobool16.not.i = icmp eq i32 %and.i16, 0
  br i1 %tobool16.not.i, label %if.else18.i, label %bdrv_filter_child.exit

if.else18.i:                                      ; preds = %if.end15.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

bdrv_filter_child.exit:                           ; preds = %if.end15.i
  %tobool.not = icmp eq ptr %retval.0.i.ph.ph, null
  br i1 %tobool.not, label %if.end, label %if.else

if.else:                                          ; preds = %bdrv_filter_child.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.154, ptr noundef nonnull @.str.2, i32 noundef 8484, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_or_cow_child) #31
  unreachable

if.end:                                           ; preds = %cond.end.i, %if.end.i8, %entry, %lor.lhs.false.i, %bdrv_filter_child.exit
  %tobool28 = phi ptr [ %cond12.i, %bdrv_filter_child.exit ], [ null, %entry ], [ %retval.0.i.ph.ph, %cond.end.i ], [ %retval.0.i.ph.ph, %if.end.i8 ], [ null, %lor.lhs.false.i ]
  ret ptr %tobool28
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_unfreeze_backing_chain(ptr noundef %bs, ptr noundef readnone %base) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.cond.preheader, label %if.else

for.cond.preheader:                               ; preds = %entry
  %cmp.not7 = icmp eq ptr %bs, %base
  br i1 %cmp.not7, label %for.end, label %for.body

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5923, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unfreeze_backing_chain) #31
  unreachable

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %i.08 = phi ptr [ %phi.call, %for.inc ], [ %bs, %for.cond.preheader ]
  %call1 = tail call ptr @bdrv_filter_or_cow_child(ptr noundef %i.08)
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %for.inc, label %if.then2

if.then2:                                         ; preds = %for.body
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %call1, i64 0, i32 7
  %0 = load i8, ptr %frozen, align 8
  %1 = and i8 %0, 1
  %tobool3.not = icmp eq i8 %1, 0
  br i1 %tobool3.not, label %if.else5, label %child_bs.exit

if.else5:                                         ; preds = %if.then2
  tail call void @__assert_fail(ptr noundef nonnull @.str.97, ptr noundef nonnull @.str.2, i32 noundef 5928, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_unfreeze_backing_chain) #31
  unreachable

child_bs.exit:                                    ; preds = %if.then2
  store i8 0, ptr %frozen, align 8
  %2 = load ptr, ptr %call1, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %child_bs.exit
  %phi.call = phi ptr [ %2, %child_bs.exit ], [ null, %for.body ]
  %cmp.not = icmp eq ptr %phi.call, %base
  br i1 %cmp.not, label %for.end, label %for.body, !llvm.loop !60

for.end:                                          ; preds = %for.inc, %for.cond.preheader
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_drop_intermediate(ptr noundef %top, ptr noundef %base, ptr noundef %backing_file_str) local_unnamed_addr #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5974, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_drop_intermediate) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_ref.exit, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %do.end
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %top, i64 0, i32 26
  %0 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %0, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  tail call void @bdrv_drained_begin(ptr noundef %base) #29
  tail call void @bdrv_graph_wrlock(ptr noundef %base) #29
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %top, i64 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %exit_wrlock, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %bdrv_ref.exit
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %base, i64 0, i32 6
  %2 = load ptr, ptr %drv1, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %exit_wrlock, label %if.end4

if.end4:                                          ; preds = %lor.lhs.false
  %call.i31 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i31, label %while.cond.preheader.i, label %if.else.i32

while.cond.preheader.i:                           ; preds = %if.end4
  %cmp5.i.not = icmp eq ptr %top, %base
  br i1 %cmp5.i.not, label %if.end7, label %while.body.i

if.else.i32:                                      ; preds = %if.end4
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6537, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_chain_contains) #31
  unreachable

while.body.i:                                     ; preds = %while.cond.preheader.i, %bdrv_filter_or_cow_bs.exit.i
  %top.addr.06.i = phi ptr [ %3, %bdrv_filter_or_cow_bs.exit.i ], [ %top, %while.cond.preheader.i ]
  %call.i.i = tail call ptr @bdrv_filter_or_cow_child(ptr noundef nonnull %top.addr.06.i)
  %tobool.not.i.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i.i, label %exit_wrlock, label %bdrv_filter_or_cow_bs.exit.i

bdrv_filter_or_cow_bs.exit.i:                     ; preds = %while.body.i
  %3 = load ptr, ptr %call.i.i, align 8
  %tobool.i = icmp ne ptr %3, null
  %cmp.i = icmp ne ptr %3, %base
  %4 = and i1 %tobool.i, %cmp.i
  br i1 %4, label %while.body.i, label %bdrv_chain_contains.exit, !llvm.loop !51

bdrv_chain_contains.exit:                         ; preds = %bdrv_filter_or_cow_bs.exit.i
  br i1 %tobool.i, label %if.end7, label %exit_wrlock

if.end7:                                          ; preds = %while.cond.preheader.i, %bdrv_chain_contains.exit
  %call.i33 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i33, label %bdrv_skip_implicit_filters.exit, label %if.else.i34

if.else.i34:                                      ; preds = %if.end7
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8555, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_skip_implicit_filters) #31
  unreachable

bdrv_skip_implicit_filters.exit:                  ; preds = %if.end7
  %call1.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %top, i1 noundef zeroext true)
  %tobool4.i35 = icmp ne ptr %base, null
  %cmp5.i36 = icmp ne ptr %call1.i, %base
  %5 = and i1 %tobool4.i35, %cmp5.i36
  br i1 %5, label %while.body.i38, label %bdrv_inherits_from_recursive.exit

while.body.i38:                                   ; preds = %bdrv_skip_implicit_filters.exit, %while.body.i38
  %child.addr.06.i = phi ptr [ %6, %while.body.i38 ], [ %base, %bdrv_skip_implicit_filters.exit ]
  %inherits_from.i = getelementptr inbounds %struct.BlockDriverState, ptr %child.addr.06.i, i64 0, i32 28
  %6 = load ptr, ptr %inherits_from.i, align 8
  %tobool.i39 = icmp ne ptr %6, null
  %cmp.i40 = icmp ne ptr %6, %call1.i
  %7 = and i1 %tobool.i39, %cmp.i40
  br i1 %7, label %while.body.i38, label %bdrv_inherits_from_recursive.exit, !llvm.loop !29

bdrv_inherits_from_recursive.exit:                ; preds = %while.body.i38, %bdrv_skip_implicit_filters.exit
  %tobool.lcssa.i37 = phi i1 [ %tobool4.i35, %bdrv_skip_implicit_filters.exit ], [ %tobool.i39, %while.body.i38 ]
  %tobool10.not = icmp eq ptr %backing_file_str, null
  br i1 %tobool10.not, label %if.then11, label %if.end12

if.then11:                                        ; preds = %bdrv_inherits_from_recursive.exit
  tail call void @bdrv_refresh_filename(ptr noundef %base)
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %base, i64 0, i32 11
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %bdrv_inherits_from_recursive.exit
  %backing_file_str.addr.0 = phi ptr [ %backing_file_str, %bdrv_inherits_from_recursive.exit ], [ %filename, %if.then11 ]
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %top, i64 0, i32 32
  %c.042 = load ptr, ptr %parents, align 8
  %tobool13.not43 = icmp eq ptr %c.042, null
  br i1 %tobool13.not43, label %for.end, label %for.body

for.body:                                         ; preds = %if.end12, %for.body
  %c.045 = phi ptr [ %c.0, %for.body ], [ %c.042, %if.end12 ]
  %updated_children.044 = phi ptr [ %call14, %for.body ], [ null, %if.end12 ]
  %call14 = tail call ptr @g_slist_prepend(ptr noundef %updated_children.044, ptr noundef nonnull %c.045) #29
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %c.045, i64 0, i32 10
  %c.0 = load ptr, ptr %next_parent, align 8
  %tobool13.not = icmp eq ptr %c.0, null
  br i1 %tobool13.not, label %for.end, label %for.body, !llvm.loop !61

for.end:                                          ; preds = %for.body, %if.end12
  %updated_children.0.lcssa = phi ptr [ null, %if.end12 ], [ %call14, %for.body ]
  %call15 = call fastcc i32 @bdrv_replace_node_common(ptr noundef %top, ptr noundef %base, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef nonnull %local_err), !range !14
  call void @bdrv_graph_wrunlock(ptr noundef %base) #29
  %8 = load ptr, ptr %local_err, align 8
  %tobool16.not = icmp eq ptr %8, null
  br i1 %tobool16.not, label %for.cond19.preheader, label %if.then17

for.cond19.preheader:                             ; preds = %for.end
  %tobool20.not46 = icmp eq ptr %updated_children.0.lcssa, null
  br i1 %tobool20.not46, label %for.end31, label %for.body21

if.then17:                                        ; preds = %for.end
  call void @error_report_err(ptr noundef nonnull %8) #29
  br label %exit

for.body21:                                       ; preds = %for.cond19.preheader, %for.inc30
  %p.0.in.sroa.speculated47 = phi ptr [ %p.0.in.sroa.speculate.load.for.inc30, %for.inc30 ], [ %updated_children.0.lcssa, %for.cond19.preheader ]
  %9 = load ptr, ptr %p.0.in.sroa.speculated47, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %klass, align 8
  %update_filename = getelementptr inbounds %struct.BdrvChildClass, ptr %10, i64 0, i32 12
  %11 = load ptr, ptr %update_filename, align 8
  %tobool22.not = icmp eq ptr %11, null
  br i1 %tobool22.not, label %for.inc30, label %if.then23

if.then23:                                        ; preds = %for.body21
  %call26 = call i32 %11(ptr noundef nonnull %9, ptr noundef %base, ptr noundef nonnull %backing_file_str.addr.0, ptr noundef nonnull %local_err) #29
  %cmp = icmp slt i32 %call26, 0
  br i1 %cmp, label %if.then27, label %for.inc30

if.then27:                                        ; preds = %if.then23
  %12 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %12) #29
  br label %exit

for.inc30:                                        ; preds = %for.body21, %if.then23
  %next = getelementptr inbounds %struct._GSList, ptr %p.0.in.sroa.speculated47, i64 0, i32 1
  %p.0.in.sroa.speculate.load.for.inc30 = load ptr, ptr %next, align 8
  %tobool20.not = icmp eq ptr %p.0.in.sroa.speculate.load.for.inc30, null
  br i1 %tobool20.not, label %for.end31, label %for.body21, !llvm.loop !62

for.end31:                                        ; preds = %for.inc30, %for.cond19.preheader
  br i1 %tobool.lcssa.i37, label %if.then33, label %exit

if.then33:                                        ; preds = %for.end31
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %call1.i, i64 0, i32 28
  %13 = load ptr, ptr %inherits_from, align 8
  %inherits_from34 = getelementptr inbounds %struct.BlockDriverState, ptr %base, i64 0, i32 28
  store ptr %13, ptr %inherits_from34, align 8
  br label %exit

exit_wrlock:                                      ; preds = %while.body.i, %bdrv_chain_contains.exit, %bdrv_ref.exit, %lor.lhs.false
  tail call void @bdrv_graph_wrunlock(ptr noundef %base) #29
  br label %exit

exit:                                             ; preds = %for.end31, %if.then33, %exit_wrlock, %if.then27, %if.then17
  %updated_children.1 = phi ptr [ null, %exit_wrlock ], [ %updated_children.0.lcssa, %if.then33 ], [ %updated_children.0.lcssa, %for.end31 ], [ %updated_children.0.lcssa, %if.then27 ], [ %updated_children.0.lcssa, %if.then17 ]
  %ret.0 = phi i32 [ -5, %exit_wrlock ], [ 0, %if.then33 ], [ 0, %for.end31 ], [ %call26, %if.then27 ], [ -5, %if.then17 ]
  call void @bdrv_drained_end(ptr noundef %base) #29
  call void @bdrv_unref(ptr noundef %top)
  %tobool.not.i.i = icmp eq ptr %updated_children.1, null
  br i1 %tobool.not.i.i, label %glib_autoptr_cleanup_GSList.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %exit
  call void @g_slist_free(ptr noundef nonnull %updated_children.1) #29
  br label %glib_autoptr_cleanup_GSList.exit

glib_autoptr_cleanup_GSList.exit:                 ; preds = %exit, %if.then.i.i
  ret i32 %ret.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_chain_contains(ptr noundef %top, ptr noundef readnone %base) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %while.cond.preheader, label %if.else

while.cond.preheader:                             ; preds = %entry
  %tobool4 = icmp ne ptr %top, null
  %cmp5 = icmp ne ptr %top, %base
  %0 = and i1 %tobool4, %cmp5
  br i1 %0, label %while.body, label %while.end

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6537, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_chain_contains) #31
  unreachable

while.body:                                       ; preds = %while.cond.preheader, %bdrv_filter_or_cow_bs.exit
  %top.addr.06 = phi ptr [ %1, %bdrv_filter_or_cow_bs.exit ], [ %top, %while.cond.preheader ]
  %call.i = tail call ptr @bdrv_filter_or_cow_child(ptr noundef nonnull %top.addr.06)
  %tobool.not.i.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i.i, label %while.end, label %bdrv_filter_or_cow_bs.exit

bdrv_filter_or_cow_bs.exit:                       ; preds = %while.body
  %1 = load ptr, ptr %call.i, align 8
  %tobool = icmp ne ptr %1, null
  %cmp = icmp ne ptr %1, %base
  %2 = and i1 %tobool, %cmp
  br i1 %2, label %while.body, label %while.end, !llvm.loop !51

while.end:                                        ; preds = %while.body, %bdrv_filter_or_cow_bs.exit, %while.cond.preheader
  %tobool.lcssa = phi i1 [ %tobool4, %while.cond.preheader ], [ false, %while.body ], [ %tobool, %bdrv_filter_or_cow_bs.exit ]
  ret i1 %tobool.lcssa
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_skip_implicit_filters(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8555, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_skip_implicit_filters) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %bs, i1 noundef zeroext true)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_co_get_allocated_file_size(ptr noundef %bs) #4 {
entry:
  %drv117 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv117, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not18 = icmp eq ptr %0, null
  br i1 %tobool.not18, label %return, label %if.end

if.end:                                           ; preds = %entry, %bdrv_filter_bs.exit
  %1 = phi ptr [ %16, %bdrv_filter_bs.exit ], [ %0, %entry ]
  %drv120 = phi ptr [ %drv1, %bdrv_filter_bs.exit ], [ %drv117, %entry ]
  %bs.tr19 = phi ptr [ %cond.i.i, %bdrv_filter_bs.exit ], [ %bs, %entry ]
  %bdrv_co_get_allocated_file_size = getelementptr inbounds %struct.BlockDriver, ptr %1, i64 0, i32 89
  %2 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_get_allocated_file_size, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 717, ptr null)
  %3 = load ptr, ptr %2, align 8
  %tobool2.not = icmp eq ptr %3, null
  br i1 %tobool2.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %4 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_get_allocated_file_size, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 717, ptr null)
  %5 = load ptr, ptr %4, align 8
  %call = tail call i64 %5(ptr noundef nonnull %bs.tr19) #29
  br label %return

if.end5:                                          ; preds = %if.end
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %1, i64 0, i32 24
  %6 = load ptr, ptr %bdrv_file_open, align 8
  %tobool6.not = icmp eq ptr %6, null
  br i1 %tobool6.not, label %if.else, label %return

if.else:                                          ; preds = %if.end5
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %1, i64 0, i32 2
  %7 = load i8, ptr %is_filter, align 4
  %8 = and i8 %7, 1
  %tobool8.not = icmp eq i8 %8, 0
  br i1 %tobool8.not, label %if.else12, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.else
  %9 = load ptr, ptr %drv120, align 8
  %tobool1.not.i.i = icmp eq ptr %9, null
  br i1 %tobool1.not.i.i, label %bdrv_filter_bs.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %lor.lhs.false.i.i
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %9, i64 0, i32 2
  %10 = load i8, ptr %is_filter.i.i, align 4
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %bdrv_filter_bs.exit, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr19, i64 0, i32 30
  %12 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %12, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr19, i64 0, i32 31
  %13 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %13, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %bdrv_filter_bs.exit, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %13, %cond.end.i.i ], [ %12, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %14 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %14, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %cond.true.i.i

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.true.i.i:                                    ; preds = %if.end15.i.i
  %15 = load ptr, ptr %cond12.i.i, align 8
  br label %bdrv_filter_bs.exit

bdrv_filter_bs.exit:                              ; preds = %lor.lhs.false.i.i, %if.end.i.i, %cond.end.i.i, %cond.true.i.i
  %cond.i.i = phi ptr [ %15, %cond.true.i.i ], [ null, %lor.lhs.false.i.i ], [ null, %if.end.i.i ], [ null, %cond.end.i.i ]
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %cond.i.i, i64 0, i32 6
  %16 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %16, null
  br i1 %tobool.not, label %return, label %if.end

if.else12:                                        ; preds = %if.else
  %children.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr19, i64 0, i32 29
  %child.0.i22 = load ptr, ptr %children.i, align 8
  %tobool.not.i23 = icmp eq ptr %child.0.i22, null
  br i1 %tobool.not.i23, label %return, label %for.body.i

for.body.i:                                       ; preds = %if.else12, %for.inc.i
  %child.0.i25 = phi ptr [ %child.0.i, %for.inc.i ], [ %child.0.i22, %if.else12 ]
  %sum.0.i24 = phi i64 [ %sum.1.i, %for.inc.i ], [ 0, %if.else12 ]
  %role.i = getelementptr inbounds %struct.BdrvChild, ptr %child.0.i25, i64 0, i32 3
  %17 = load i32, ptr %role.i, align 8
  %and.i = and i32 %17, 7
  %tobool1.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool1.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %18 = load ptr, ptr %child.0.i25, align 8
  %call.i = tail call i64 @bdrv_co_get_allocated_file_size(ptr noundef %18)
  %cmp.i = icmp slt i64 %call.i, 0
  br i1 %cmp.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then.i
  %add.i = add i64 %call.i, %sum.0.i24
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %for.body.i
  %sum.1.i = phi i64 [ %add.i, %if.end.i ], [ %sum.0.i24, %for.body.i ]
  %next.i = getelementptr inbounds %struct.BdrvChild, ptr %child.0.i25, i64 0, i32 9
  %child.0.i = load ptr, ptr %next.i, align 8
  %tobool.not.i = icmp eq ptr %child.0.i, null
  br i1 %tobool.not.i, label %return, label %for.body.i, !llvm.loop !63

return:                                           ; preds = %bdrv_filter_bs.exit, %if.end5, %for.inc.i, %if.then.i, %entry, %if.else12, %if.then3
  %retval.0 = phi i64 [ %call, %if.then3 ], [ 0, %if.else12 ], [ -123, %entry ], [ %sum.1.i, %for.inc.i ], [ %call.i, %if.then.i ], [ -123, %bdrv_filter_bs.exit ], [ -95, %if.end5 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @bdrv_sum_allocated_file_size(ptr nocapture noundef readonly %bs) #4 {
entry:
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.07 = load ptr, ptr %children, align 8
  %tobool.not8 = icmp eq ptr %child.07, null
  br i1 %tobool.not8, label %return, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %child.010 = phi ptr [ %child.0, %for.inc ], [ %child.07, %entry ]
  %sum.09 = phi i64 [ %sum.1, %for.inc ], [ 0, %entry ]
  %role = getelementptr inbounds %struct.BdrvChild, ptr %child.010, i64 0, i32 3
  %0 = load i32, ptr %role, align 8
  %and = and i32 %0, 7
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %1 = load ptr, ptr %child.010, align 8
  %call = tail call i64 @bdrv_co_get_allocated_file_size(ptr noundef %1)
  %cmp = icmp slt i64 %call, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %add = add i64 %call, %sum.09
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %sum.1 = phi i64 [ %add, %if.end ], [ %sum.09, %for.body ]
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.010, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool.not = icmp eq ptr %child.0, null
  br i1 %tobool.not, label %return, label %for.body, !llvm.loop !63

return:                                           ; preds = %if.then, %for.inc, %entry
  %retval.0 = phi i64 [ 0, %entry ], [ %sum.1, %for.inc ], [ %call, %if.then ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_measure(ptr nocapture noundef readonly %drv, ptr noundef %opts, ptr noundef %in_bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %bdrv_measure = getelementptr inbounds %struct.BlockDriver, ptr %drv, i64 0, i32 90
  %0 = load ptr, ptr %bdrv_measure, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %drv, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 6150, ptr noundef nonnull @__func__.bdrv_measure, ptr noundef nonnull @.str.98, ptr noundef %1) #29
  br label %return

if.end:                                           ; preds = %entry
  %call = tail call ptr %0(ptr noundef %opts, ptr noundef %in_bs, ptr noundef %errp) #29
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi ptr [ %call, %if.end ], [ null, %if.then ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_co_nb_sectors(ptr noundef %bs) #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %has_variable_length = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 12
  %1 = load i8, ptr %has_variable_length, align 4
  %2 = and i8 %1, 1
  %tobool2.not = icmp eq i8 %2, 0
  br i1 %tobool2.not, label %if.end6, label %if.then3

if.then3:                                         ; preds = %if.end
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %3 = load i64, ptr %total_sectors, align 8
  %4 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i, label %if.then4, label %if.end.i

if.end.i:                                         ; preds = %if.then3
  %sg.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 2
  %5 = load i8, ptr %sg.i.i, align 1
  %6 = and i8 %5, 1
  %tobool.i.not.i = icmp eq i8 %6, 0
  br i1 %tobool.i.not.i, label %if.end3.i, label %if.end6

if.end3.i:                                        ; preds = %if.end.i
  %bdrv_co_getlength.i = getelementptr inbounds %struct.BlockDriver, ptr %4, i64 0, i32 88
  %7 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_getlength.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 714, ptr null)
  %8 = load ptr, ptr %7, align 8
  %tobool4.not.i = icmp eq ptr %8, null
  br i1 %tobool4.not.i, label %if.end10.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.end3.i
  %9 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_getlength.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 714, ptr null)
  %10 = load ptr, ptr %9, align 8
  %call7.i = tail call i64 %10(ptr noundef nonnull %bs) #29
  %cmp.i = icmp slt i64 %call7.i, 0
  br i1 %cmp.i, label %bdrv_co_refresh_total_sectors.exit, label %if.end9.i

if.end9.i:                                        ; preds = %if.then5.i
  %sub.i = add nuw i64 %call7.i, 511
  %div9.i = lshr i64 %sub.i, 9
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.end9.i, %if.end3.i
  %hint.addr.0.i = phi i64 [ %div9.i, %if.end9.i ], [ %3, %if.end3.i ]
  store i64 %hint.addr.0.i, ptr %total_sectors, align 8
  %mul.i = shl i64 %hint.addr.0.i, 9
  %cmp12.i = icmp ugt i64 %mul.i, 9223372035781033984
  br i1 %cmp12.i, label %if.then4, label %if.end6

bdrv_co_refresh_total_sectors.exit:               ; preds = %if.then5.i
  %11 = and i64 %call7.i, 2147483648
  %cmp.not = icmp eq i64 %11, 0
  br i1 %cmp.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end10.i, %if.then3, %bdrv_co_refresh_total_sectors.exit
  %retval.0.i8 = phi i64 [ %call7.i, %bdrv_co_refresh_total_sectors.exit ], [ -123, %if.then3 ], [ -27, %if.end10.i ]
  %sext = shl i64 %retval.0.i8, 32
  %conv = ashr exact i64 %sext, 32
  br label %return

if.end6:                                          ; preds = %if.end10.i, %if.end.i, %bdrv_co_refresh_total_sectors.exit, %if.end
  %total_sectors7 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %12 = load i64, ptr %total_sectors7, align 8
  br label %return

return:                                           ; preds = %entry, %if.end6, %if.then4
  %retval.0 = phi i64 [ %conv, %if.then4 ], [ %12, %if.end6 ], [ -123, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_nb_sectors(ptr noundef %bs) #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %has_variable_length = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 12
  %1 = load i8, ptr %has_variable_length, align 4
  %2 = and i8 %1, 1
  %tobool2.not = icmp eq i8 %2, 0
  br i1 %tobool2.not, label %if.end6, label %if.then3

if.then3:                                         ; preds = %if.end
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %3 = load i64, ptr %total_sectors, align 8
  %call = tail call i32 @bdrv_refresh_total_sectors(ptr noundef nonnull %bs, i64 noundef %3) #29
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then3
  %conv = sext i32 %call to i64
  br label %return

if.end6:                                          ; preds = %if.then3, %if.end
  %total_sectors7 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %4 = load i64, ptr %total_sectors7, align 8
  br label %return

return:                                           ; preds = %entry, %if.end6, %if.then4
  %retval.0 = phi i64 [ %conv, %if.then4 ], [ %4, %if.end6 ], [ -123, %entry ]
  ret i64 %retval.0
}

declare i32 @bdrv_refresh_total_sectors(ptr noundef, i64 noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_co_getlength(ptr noundef %bs) #4 {
entry:
  tail call void @assert_bdrv_graph_readable() #29
  %drv1.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1.i, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %.thread, label %if.end.i

if.end.i:                                         ; preds = %entry
  %has_variable_length.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 17, i32 12
  %1 = load i8, ptr %has_variable_length.i, align 4
  %2 = and i8 %1, 1
  %tobool2.not.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i, label %if.end6.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  %total_sectors.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %3 = load i64, ptr %total_sectors.i, align 8
  %4 = load ptr, ptr %drv1.i, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i, label %if.then4.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then3.i
  %sg.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 2
  %5 = load i8, ptr %sg.i.i.i, align 1
  %6 = and i8 %5, 1
  %tobool.i.not.i.i = icmp eq i8 %6, 0
  br i1 %tobool.i.not.i.i, label %if.end3.i.i, label %if.end6.i

if.end3.i.i:                                      ; preds = %if.end.i.i
  %bdrv_co_getlength.i.i = getelementptr inbounds %struct.BlockDriver, ptr %4, i64 0, i32 88
  %7 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_getlength.i.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 714, ptr null)
  %8 = load ptr, ptr %7, align 8
  %tobool4.not.i.i = icmp eq ptr %8, null
  br i1 %tobool4.not.i.i, label %if.end10.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.end3.i.i
  %9 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_getlength.i.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 714, ptr null)
  %10 = load ptr, ptr %9, align 8
  %call7.i.i = tail call i64 %10(ptr noundef nonnull %bs) #29
  %cmp.i.i = icmp slt i64 %call7.i.i, 0
  br i1 %cmp.i.i, label %bdrv_co_refresh_total_sectors.exit.i, label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.then5.i.i
  %sub.i.i = add nuw i64 %call7.i.i, 511
  %div9.i.i = lshr i64 %sub.i.i, 9
  br label %if.end10.i.i

if.end10.i.i:                                     ; preds = %if.end9.i.i, %if.end3.i.i
  %hint.addr.0.i.i = phi i64 [ %div9.i.i, %if.end9.i.i ], [ %3, %if.end3.i.i ]
  store i64 %hint.addr.0.i.i, ptr %total_sectors.i, align 8
  %mul.i.i = shl i64 %hint.addr.0.i.i, 9
  %cmp12.i.i = icmp ugt i64 %mul.i.i, 9223372035781033984
  br i1 %cmp12.i.i, label %if.then4.i, label %if.end6.i

bdrv_co_refresh_total_sectors.exit.i:             ; preds = %if.then5.i.i
  %11 = and i64 %call7.i.i, 2147483648
  %cmp.not.i = icmp eq i64 %11, 0
  br i1 %cmp.not.i, label %if.end6.i, label %if.then4.i

if.then4.i:                                       ; preds = %bdrv_co_refresh_total_sectors.exit.i, %if.end10.i.i, %if.then3.i
  %retval.0.i8.i = phi i64 [ %call7.i.i, %bdrv_co_refresh_total_sectors.exit.i ], [ -123, %if.then3.i ], [ -27, %if.end10.i.i ]
  %sext.i = shl i64 %retval.0.i8.i, 32
  %conv.i = ashr exact i64 %sext.i, 32
  br label %bdrv_co_nb_sectors.exit

if.end6.i:                                        ; preds = %bdrv_co_refresh_total_sectors.exit.i, %if.end10.i.i, %if.end.i.i, %if.end.i
  %total_sectors7.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %12 = load i64, ptr %total_sectors7.i, align 8
  br label %bdrv_co_nb_sectors.exit

bdrv_co_nb_sectors.exit:                          ; preds = %if.then4.i, %if.end6.i
  %retval.0.i = phi i64 [ %conv.i, %if.then4.i ], [ %12, %if.end6.i ]
  %retval.0.i.fr = freeze i64 %retval.0.i
  %cmp1 = icmp ugt i64 %retval.0.i.fr, 18014398509481983
  br i1 %cmp1, label %13, label %14

13:                                               ; preds = %bdrv_co_nb_sectors.exit
  %cmp = icmp slt i64 %retval.0.i.fr, 0
  %spec.select = select i1 %cmp, i64 %retval.0.i.fr, i64 -27
  br label %.thread

14:                                               ; preds = %bdrv_co_nb_sectors.exit
  %mul = shl nuw nsw i64 %retval.0.i.fr, 9
  br label %.thread

.thread:                                          ; preds = %13, %entry, %14
  %15 = phi i64 [ %mul, %14 ], [ -123, %entry ], [ %spec.select, %13 ]
  ret i64 %15
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_supports_compressed_writes(ptr nocapture noundef readonly %bs) local_unnamed_addr #4 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %bdrv_filter_bs.exit, %entry
  %bs.tr = phi ptr [ %bs, %entry ], [ %10, %bdrv_filter_bs.exit ]
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %tailrecurse
  %bdrv_co_pwritev_compressed.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 91
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_pwritev_compressed.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 723, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %block_driver_can_compress.exit, label %if.end.i.i

block_driver_can_compress.exit:                   ; preds = %lor.lhs.false
  %bdrv_co_pwritev_compressed_part.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 92
  %3 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_pwritev_compressed_part.i, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 727, ptr null)
  %4 = load ptr, ptr %3, align 8
  %tobool1.i.not = icmp eq ptr %4, null
  br i1 %tobool1.i.not, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %lor.lhs.false, %block_driver_can_compress.exit
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %5 = load i8, ptr %is_filter.i.i, align 4
  %6 = and i8 %5, 1
  %tobool3.not.i.i = icmp eq i8 %6, 0
  br i1 %tobool3.not.i.i, label %return, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 30
  %7 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %7, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 31
  %8 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %8, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %return, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %8, %cond.end.i.i ], [ %7, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %9 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %9, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %bdrv_filter_bs.exit

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

bdrv_filter_bs.exit:                              ; preds = %if.end15.i.i
  %10 = load ptr, ptr %cond12.i.i, align 8
  %tobool3.not = icmp eq ptr %10, null
  br i1 %tobool3.not, label %return, label %tailrecurse

return:                                           ; preds = %cond.end.i.i, %if.end.i.i, %bdrv_filter_bs.exit, %tailrecurse, %block_driver_can_compress.exit
  %retval.0 = phi i1 [ false, %block_driver_can_compress.exit ], [ false, %tailrecurse ], [ true, %bdrv_filter_bs.exit ], [ true, %if.end.i.i ], [ true, %cond.end.i.i ]
  ret i1 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @bdrv_get_format_name(ptr nocapture noundef readonly %bs) local_unnamed_addr #17 {
entry:
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %0, align 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ null, %entry ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_iterate_format(ptr nocapture noundef readonly %it, ptr noundef %opaque, i1 noundef zeroext %read_only) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.cond.preheader, label %if.else

for.cond.preheader:                               ; preds = %entry
  %drv.043 = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not44 = icmp eq ptr %drv.043, null
  br i1 %tobool.not44, label %for.end72.thread, label %for.body

for.end72.thread:                                 ; preds = %for.cond.preheader
  tail call void @qsort(ptr noundef null, i64 noundef 0, i64 noundef 8, ptr noundef nonnull @qsort_strcmp) #29
  br label %for.end82

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6269, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_iterate_format) #31
  unreachable

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %drv.049 = phi ptr [ %drv.0, %for.inc ], [ %drv.043, %for.cond.preheader ]
  %formats.047 = phi ptr [ %formats.1, %for.inc ], [ null, %for.cond.preheader ]
  %count.045 = phi i32 [ %count.1, %for.inc ], [ 0, %for.cond.preheader ]
  %formats.047.fr = freeze ptr %formats.047
  %0 = load ptr, ptr %drv.049, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %for.inc, label %if.then2

if.then2:                                         ; preds = %for.body
  %.b = load i1, ptr @use_bdrv_whitelist, align 4
  br i1 %.b, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.then2
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %if.end8, label %if.else.i

if.else.i:                                        ; preds = %land.lhs.true
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 517, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_is_whitelisted) #31
  unreachable

if.end8:                                          ; preds = %land.lhs.true, %if.then2
  %tobool9 = icmp eq ptr %formats.047.fr, null
  %tobool1140 = icmp eq i32 %count.045, 0
  %or.cond.not41 = select i1 %tobool9, i1 true, i1 %tobool1140
  br i1 %or.cond.not41, label %if.then19, label %while.body.preheader

while.body.preheader:                             ; preds = %if.end8
  %1 = load ptr, ptr %drv.049, align 8
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %while.body
  %i.042 = phi i32 [ %dec, %while.body ], [ %count.045, %while.body.preheader ]
  %dec = add i32 %i.042, -1
  %idxprom = sext i32 %dec to i64
  %arrayidx = getelementptr ptr, ptr %formats.047.fr, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  %call14 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %2, ptr noundef nonnull dereferenceable(1) %1) #28
  %tobool15.not = icmp eq i32 %call14, 0
  %tobool11 = icmp eq i32 %dec, 0
  %3 = select i1 %tobool11, i1 true, i1 %tobool15.not
  br i1 %3, label %while.end, label %while.body, !llvm.loop !64

while.end:                                        ; preds = %while.body
  br i1 %tobool15.not, label %for.inc, label %if.then19

if.then19:                                        ; preds = %if.end8, %while.end
  %add = add i32 %count.045, 1
  %conv = sext i32 %add to i64
  %call20 = tail call ptr @g_realloc_n(ptr noundef %formats.047.fr, i64 noundef %conv, i64 noundef 8) #29
  %4 = load ptr, ptr %drv.049, align 8
  %idxprom22 = sext i32 %count.045 to i64
  %arrayidx23 = getelementptr ptr, ptr %call20, i64 %idxprom22
  store ptr %4, ptr %arrayidx23, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then19, %while.end
  %count.1 = phi i32 [ %count.045, %while.end ], [ %add, %if.then19 ], [ %count.045, %for.body ]
  %formats.1 = phi ptr [ %formats.047.fr, %while.end ], [ %call20, %if.then19 ], [ %formats.047.fr, %for.body ]
  %list = getelementptr inbounds %struct.BlockDriver, ptr %drv.049, i64 0, i32 61
  %drv.0 = load ptr, ptr %list, align 8
  %tobool.not = icmp eq ptr %drv.0, null
  br i1 %tobool.not, label %for.end72, label %for.body, !llvm.loop !65

for.end72:                                        ; preds = %for.inc
  %conv73 = sext i32 %count.1 to i64
  tail call void @qsort(ptr noundef %formats.1, i64 noundef %conv73, i64 noundef 8, ptr noundef nonnull @qsort_strcmp) #29
  %cmp7552 = icmp sgt i32 %count.1, 0
  br i1 %cmp7552, label %for.body77.preheader, label %for.end82

for.body77.preheader:                             ; preds = %for.end72
  %wide.trip.count = zext nneg i32 %count.1 to i64
  br label %for.body77

for.body77:                                       ; preds = %for.body77.preheader, %for.body77
  %indvars.iv = phi i64 [ 0, %for.body77.preheader ], [ %indvars.iv.next, %for.body77 ]
  %arrayidx79 = getelementptr ptr, ptr %formats.1, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx79, align 8
  tail call void %it(ptr noundef %opaque, ptr noundef %5) #29
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end82, label %for.body77, !llvm.loop !66

for.end82:                                        ; preds = %for.body77, %for.end72.thread, %for.end72
  %formats.0.lcssa60 = phi ptr [ null, %for.end72.thread ], [ %formats.1, %for.end72 ], [ %formats.1, %for.body77 ]
  tail call void @g_free(ptr noundef %formats.0.lcssa60) #29
  ret void
}

declare ptr @g_realloc_n(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #5

; Function Attrs: nofree
declare void @qsort(ptr noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #18

; Function Attrs: mustprogress nofree nounwind sspstrong willreturn memory(read, inaccessiblemem: none) uwtable
define internal i32 @qsort_strcmp(ptr nocapture noundef readonly %a, ptr nocapture noundef readonly %b) #19 {
entry:
  %0 = load ptr, ptr %a, align 8
  %1 = load ptr, ptr %b, align 8
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull dereferenceable(1) %1) #28
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_node(ptr noundef readonly %node_name) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %node_name, null
  br i1 %tobool.not, label %if.else, label %do.body

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.99, ptr noundef nonnull @.str.2, i32 noundef 6328, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

do.body:                                          ; preds = %entry
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.cond.preheader, label %if.else2

for.cond.preheader:                               ; preds = %do.body
  %bs.05 = load ptr, ptr @graph_bdrv_states, align 8
  %tobool4.not6 = icmp eq ptr %bs.05, null
  br i1 %tobool4.not6, label %return, label %for.body

if.else2:                                         ; preds = %do.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6329, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %bs.07 = phi ptr [ %bs.0, %for.inc ], [ %bs.05, %for.cond.preheader ]
  %node_name5 = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07, i64 0, i32 22
  %call6 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %node_name, ptr noundef nonnull dereferenceable(1) %node_name5) #28
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %return, label %for.inc

for.inc:                                          ; preds = %for.body
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07, i64 0, i32 23
  %bs.0 = load ptr, ptr %node_list, align 8
  %tobool4.not = icmp eq ptr %bs.0, null
  br i1 %tobool4.not, label %return, label %for.body, !llvm.loop !15

return:                                           ; preds = %for.body, %for.inc, %for.cond.preheader
  %bs.0.lcssa = phi ptr [ null, %for.cond.preheader ], [ null, %for.inc ], [ %bs.07, %for.body ]
  ret ptr %bs.0.lcssa
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_named_nodes_list(i1 noundef zeroext %flat, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6346, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_named_nodes_list) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %bs.09 = load ptr, ptr @graph_bdrv_states, align 8
  %tobool.not10 = icmp eq ptr %bs.09, null
  br i1 %tobool.not10, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body

for.body:                                         ; preds = %do.end, %do.body7
  %bs.012 = phi ptr [ %bs.0, %do.body7 ], [ %bs.09, %do.end ]
  %list.011 = phi ptr [ %call8, %do.body7 ], [ null, %do.end ]
  %call3 = tail call ptr @bdrv_block_device_info(ptr noundef null, ptr noundef nonnull %bs.012, i1 noundef zeroext %flat, ptr noundef %errp) #29
  %tobool4.not = icmp eq ptr %call3, null
  br i1 %tobool4.not, label %if.then5, label %do.body7

if.then5:                                         ; preds = %for.body
  tail call void @qapi_free_BlockDeviceInfoList(ptr noundef %list.011) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

do.body7:                                         ; preds = %for.body
  %call8 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc(i64 noundef 16) #30
  %value = getelementptr inbounds %struct.BlockDeviceInfoList, ptr %call8, i64 0, i32 1
  store ptr %call3, ptr %value, align 8
  store ptr %list.011, ptr %call8, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %bs.012, i64 0, i32 23
  %bs.0 = load ptr, ptr %node_list, align 8
  %tobool.not = icmp eq ptr %bs.0, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body, !llvm.loop !67

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %do.body7, %do.end, %if.then5
  %retval.0 = phi ptr [ null, %if.then5 ], [ null, %do.end ], [ %call8, %do.body7 ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret ptr %retval.0
}

declare ptr @bdrv_block_device_info(ptr noundef, ptr noundef, i1 noundef zeroext, ptr noundef) local_unnamed_addr #5

declare void @qapi_free_BlockDeviceInfoList(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_xdbg_block_graph(ptr nocapture noundef readnone %errp) local_unnamed_addr #4 {
entry:
  %call.i = tail call noalias dereferenceable_or_null(16) ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #32
  %call1.i = tail call noalias dereferenceable_or_null(16) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 16) #32
  store ptr %call1.i, ptr %call.i, align 8
  %call2.i = tail call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  %graph_nodes.i = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %call.i, i64 0, i32 1
  store ptr %call2.i, ptr %graph_nodes.i, align 8
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6455, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_xdbg_block_graph) #31
  unreachable

do.end:                                           ; preds = %entry
  %call2 = tail call ptr @blk_all_next(ptr noundef null) #29
  %tobool.not33 = icmp eq ptr %call2, null
  br i1 %tobool.not33, label %for.end, label %for.body

for.body:                                         ; preds = %do.end, %for.inc
  %blk.034 = phi ptr [ %call13, %for.inc ], [ %call2, %do.end ]
  %call3 = tail call ptr @blk_name(ptr noundef nonnull %blk.034) #29
  %0 = load i8, ptr %call3, align 1
  %tobool4.not = icmp eq i8 %0, 0
  br i1 %tobool4.not, label %if.then5, label %if.end7

if.then5:                                         ; preds = %for.body
  %call6 = tail call ptr @blk_get_attached_dev_id(ptr noundef nonnull %blk.034) #29
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %for.body
  %allocated_name.0 = phi ptr [ null, %for.body ], [ %call6, %if.then5 ]
  %name.0 = phi ptr [ %call3, %for.body ], [ %call6, %if.then5 ]
  tail call fastcc void @xdbg_graph_add_node(ptr noundef nonnull %call.i, ptr noundef nonnull %blk.034, i32 noundef 0, ptr noundef %name.0)
  tail call void @g_free(ptr noundef %allocated_name.0) #29
  %call8 = tail call ptr @blk_root(ptr noundef nonnull %blk.034) #29
  %tobool9.not = icmp eq ptr %call8, null
  br i1 %tobool9.not, label %for.inc, label %if.then10

if.then10:                                        ; preds = %if.end7
  %call11 = tail call ptr @blk_root(ptr noundef nonnull %blk.034) #29
  tail call fastcc void @xdbg_graph_add_edge(ptr noundef nonnull %call.i, ptr noundef nonnull %blk.034, ptr noundef %call11)
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then10
  %call13 = tail call ptr @blk_all_next(ptr noundef nonnull %blk.034) #29
  %tobool.not = icmp eq ptr %call13, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !68

for.end:                                          ; preds = %for.inc, %do.end
  %1 = load atomic i64, ptr @qemu_mutex_lock_func monotonic, align 8
  %2 = inttoptr i64 %1 to ptr
  tail call void %2(ptr noundef nonnull @job_mutex, ptr noundef nonnull @.str.280, i32 noundef 122) #29
  %call18 = tail call ptr @block_job_next_locked(ptr noundef null) #29
  %tobool20.not38 = icmp eq ptr %call18, null
  br i1 %tobool20.not38, label %qemu_lockable_auto_unlock.exit, label %for.body21

for.body21:                                       ; preds = %for.end, %for.inc28
  %3 = phi ptr [ %8, %for.inc28 ], [ %call2.i, %for.end ]
  %job.039 = phi ptr [ %call29, %for.inc28 ], [ %call18, %for.end ]
  %4 = load ptr, ptr %job.039, align 8
  %call.i29 = tail call noalias dereferenceable_or_null(24) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #32
  %call.i.i = tail call ptr @g_hash_table_lookup(ptr noundef %3, ptr noundef nonnull %job.039) #29
  %cmp.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %cmp.not.i.i, label %if.end.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body21
  %5 = ptrtoint ptr %call.i.i to i64
  br label %xdbg_graph_add_node.exit

if.end.i.i:                                       ; preds = %for.body21
  %call2.i.i = tail call i32 @g_hash_table_size(ptr noundef %3) #29
  %add.i.i = add i32 %call2.i.i, 1
  %conv.i.i = zext i32 %add.i.i to i64
  %6 = load ptr, ptr %graph_nodes.i, align 8
  %7 = inttoptr i64 %conv.i.i to ptr
  %call4.i.i = tail call i32 @g_hash_table_insert(ptr noundef %6, ptr noundef nonnull %job.039, ptr noundef %7) #29
  br label %xdbg_graph_add_node.exit

xdbg_graph_add_node.exit:                         ; preds = %if.then.i.i, %if.end.i.i
  %8 = phi ptr [ %3, %if.then.i.i ], [ %6, %if.end.i.i ]
  %retval.0.i.i = phi i64 [ %5, %if.then.i.i ], [ %conv.i.i, %if.end.i.i ]
  store i64 %retval.0.i.i, ptr %call.i29, align 8
  %type2.i = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %call.i29, i64 0, i32 1
  store i32 1, ptr %type2.i, align 8
  %call3.i = tail call noalias ptr @g_strdup(ptr noundef %4) #29
  %name4.i = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %call.i29, i64 0, i32 2
  store ptr %call3.i, ptr %name4.i, align 8
  %call5.i = tail call noalias dereferenceable_or_null(16) ptr @g_malloc(i64 noundef 16) #30
  %value.i = getelementptr inbounds %struct.XDbgBlockGraphNodeList, ptr %call5.i, i64 0, i32 1
  store ptr %call.i29, ptr %value.i, align 8
  %9 = load ptr, ptr %call.i, align 8
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %call5.i, align 8
  store ptr %call5.i, ptr %9, align 8
  %nodes = getelementptr inbounds %struct.BlockJob, ptr %job.039, i64 0, i32 10
  %el.035 = load ptr, ptr %nodes, align 8
  %tobool24.not36 = icmp eq ptr %el.035, null
  br i1 %tobool24.not36, label %for.inc28, label %for.body25

for.body25:                                       ; preds = %xdbg_graph_add_node.exit, %for.body25
  %el.037 = phi ptr [ %el.0, %for.body25 ], [ %el.035, %xdbg_graph_add_node.exit ]
  %11 = load ptr, ptr %el.037, align 8
  tail call fastcc void @xdbg_graph_add_edge(ptr noundef nonnull %call.i, ptr noundef nonnull %job.039, ptr noundef %11)
  %next = getelementptr inbounds %struct._GSList, ptr %el.037, i64 0, i32 1
  %el.0 = load ptr, ptr %next, align 8
  %tobool24.not = icmp eq ptr %el.0, null
  br i1 %tobool24.not, label %for.inc28, label %for.body25, !llvm.loop !69

for.inc28:                                        ; preds = %for.body25, %xdbg_graph_add_node.exit
  %call29 = tail call ptr @block_job_next_locked(ptr noundef nonnull %job.039) #29
  %tobool20.not = icmp eq ptr %call29, null
  br i1 %tobool20.not, label %qemu_lockable_auto_unlock.exit, label %for.body21, !llvm.loop !70

qemu_lockable_auto_unlock.exit:                   ; preds = %for.inc28, %for.end
  %12 = phi ptr [ %call2.i, %for.end ], [ %8, %for.inc28 ]
  %13 = phi ptr [ %call1.i, %for.end ], [ %9, %for.inc28 ]
  tail call void @qemu_mutex_unlock_impl(ptr noundef nonnull @job_mutex, ptr noundef nonnull @.str.280, i32 noundef 132) #29
  %bs.044 = load ptr, ptr @graph_bdrv_states, align 8
  %tobool34.not45 = icmp eq ptr %bs.044, null
  br i1 %tobool34.not45, label %for.end43, label %for.body35

for.body35:                                       ; preds = %qemu_lockable_auto_unlock.exit, %for.inc42
  %bs.046 = phi ptr [ %bs.0, %for.inc42 ], [ %bs.044, %qemu_lockable_auto_unlock.exit ]
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %bs.046, i64 0, i32 22
  tail call fastcc void @xdbg_graph_add_node(ptr noundef nonnull %call.i, ptr noundef nonnull %bs.046, i32 noundef 2, ptr noundef nonnull %node_name)
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs.046, i64 0, i32 29
  %child.041 = load ptr, ptr %children, align 8
  %tobool37.not42 = icmp eq ptr %child.041, null
  br i1 %tobool37.not42, label %for.inc42, label %for.body38

for.body38:                                       ; preds = %for.body35, %for.body38
  %child.043 = phi ptr [ %child.0, %for.body38 ], [ %child.041, %for.body35 ]
  tail call fastcc void @xdbg_graph_add_edge(ptr noundef nonnull %call.i, ptr noundef nonnull %bs.046, ptr noundef nonnull %child.043)
  %next40 = getelementptr inbounds %struct.BdrvChild, ptr %child.043, i64 0, i32 9
  %child.0 = load ptr, ptr %next40, align 8
  %tobool37.not = icmp eq ptr %child.0, null
  br i1 %tobool37.not, label %for.inc42, label %for.body38, !llvm.loop !71

for.inc42:                                        ; preds = %for.body38, %for.body35
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %bs.046, i64 0, i32 23
  %bs.0 = load ptr, ptr %node_list, align 8
  %tobool34.not = icmp eq ptr %bs.0, null
  br i1 %tobool34.not, label %for.end43.loopexit, label %for.body35, !llvm.loop !72

for.end43.loopexit:                               ; preds = %for.inc42
  %.pre = load ptr, ptr %call.i, align 8
  %.pre47 = load ptr, ptr %graph_nodes.i, align 8
  br label %for.end43

for.end43:                                        ; preds = %for.end43.loopexit, %qemu_lockable_auto_unlock.exit
  %14 = phi ptr [ %.pre47, %for.end43.loopexit ], [ %12, %qemu_lockable_auto_unlock.exit ]
  %15 = phi ptr [ %.pre, %for.end43.loopexit ], [ %13, %qemu_lockable_auto_unlock.exit ]
  tail call void @g_hash_table_destroy(ptr noundef %14) #29
  tail call void @g_free(ptr noundef nonnull %call.i) #29
  ret ptr %15
}

declare ptr @blk_all_next(ptr noundef) local_unnamed_addr #5

declare ptr @blk_name(ptr noundef) local_unnamed_addr #5

declare ptr @blk_get_attached_dev_id(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @xdbg_graph_add_node(ptr nocapture noundef readonly %gr, ptr noundef %node, i32 noundef %type, ptr noundef %name) unnamed_addr #4 {
entry:
  %call = tail call noalias dereferenceable_or_null(24) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #32
  %graph_nodes.i = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %gr, i64 0, i32 1
  %0 = load ptr, ptr %graph_nodes.i, align 8
  %call.i = tail call ptr @g_hash_table_lookup(ptr noundef %0, ptr noundef %node) #29
  %cmp.not.i = icmp eq ptr %call.i, null
  br i1 %cmp.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %1 = ptrtoint ptr %call.i to i64
  br label %xdbg_graph_node_num.exit

if.end.i:                                         ; preds = %entry
  %2 = load ptr, ptr %graph_nodes.i, align 8
  %call2.i = tail call i32 @g_hash_table_size(ptr noundef %2) #29
  %add.i = add i32 %call2.i, 1
  %conv.i = zext i32 %add.i to i64
  %3 = load ptr, ptr %graph_nodes.i, align 8
  %4 = inttoptr i64 %conv.i to ptr
  %call4.i = tail call i32 @g_hash_table_insert(ptr noundef %3, ptr noundef %node, ptr noundef %4) #29
  br label %xdbg_graph_node_num.exit

xdbg_graph_node_num.exit:                         ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %1, %if.then.i ], [ %conv.i, %if.end.i ]
  store i64 %retval.0.i, ptr %call, align 8
  %type2 = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %call, i64 0, i32 1
  store i32 %type, ptr %type2, align 8
  %call3 = tail call noalias ptr @g_strdup(ptr noundef %name) #29
  %name4 = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %call, i64 0, i32 2
  store ptr %call3, ptr %name4, align 8
  %call5 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc(i64 noundef 16) #30
  %value = getelementptr inbounds %struct.XDbgBlockGraphNodeList, ptr %call5, i64 0, i32 1
  store ptr %call, ptr %value, align 8
  %5 = load ptr, ptr %gr, align 8
  %6 = load ptr, ptr %5, align 8
  store ptr %6, ptr %call5, align 8
  store ptr %call5, ptr %5, align 8
  ret void
}

declare ptr @blk_root(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @xdbg_graph_add_edge(ptr nocapture noundef readonly %gr, ptr noundef %parent, ptr nocapture noundef readonly %child) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6424, ptr noundef nonnull @__PRETTY_FUNCTION__.xdbg_graph_add_edge) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call noalias dereferenceable_or_null(40) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 40) #32
  %graph_nodes.i = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %gr, i64 0, i32 1
  %0 = load ptr, ptr %graph_nodes.i, align 8
  %call.i = tail call ptr @g_hash_table_lookup(ptr noundef %0, ptr noundef %parent) #29
  %cmp.not.i = icmp eq ptr %call.i, null
  br i1 %cmp.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %do.end
  %1 = ptrtoint ptr %call.i to i64
  br label %xdbg_graph_node_num.exit

if.end.i:                                         ; preds = %do.end
  %2 = load ptr, ptr %graph_nodes.i, align 8
  %call2.i = tail call i32 @g_hash_table_size(ptr noundef %2) #29
  %add.i = add i32 %call2.i, 1
  %conv.i = zext i32 %add.i to i64
  %3 = load ptr, ptr %graph_nodes.i, align 8
  %4 = inttoptr i64 %conv.i to ptr
  %call4.i = tail call i32 @g_hash_table_insert(ptr noundef %3, ptr noundef %parent, ptr noundef %4) #29
  br label %xdbg_graph_node_num.exit

xdbg_graph_node_num.exit:                         ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %1, %if.then.i ], [ %conv.i, %if.end.i ]
  store i64 %retval.0.i, ptr %call1, align 8
  %5 = load ptr, ptr %child, align 8
  %6 = load ptr, ptr %graph_nodes.i, align 8
  %call.i26 = tail call ptr @g_hash_table_lookup(ptr noundef %6, ptr noundef %5) #29
  %cmp.not.i27 = icmp eq ptr %call.i26, null
  br i1 %cmp.not.i27, label %if.end.i30, label %if.then.i28

if.then.i28:                                      ; preds = %xdbg_graph_node_num.exit
  %7 = ptrtoint ptr %call.i26 to i64
  br label %xdbg_graph_node_num.exit35

if.end.i30:                                       ; preds = %xdbg_graph_node_num.exit
  %8 = load ptr, ptr %graph_nodes.i, align 8
  %call2.i31 = tail call i32 @g_hash_table_size(ptr noundef %8) #29
  %add.i32 = add i32 %call2.i31, 1
  %conv.i33 = zext i32 %add.i32 to i64
  %9 = load ptr, ptr %graph_nodes.i, align 8
  %10 = inttoptr i64 %conv.i33 to ptr
  %call4.i34 = tail call i32 @g_hash_table_insert(ptr noundef %9, ptr noundef %5, ptr noundef %10) #29
  br label %xdbg_graph_node_num.exit35

xdbg_graph_node_num.exit35:                       ; preds = %if.then.i28, %if.end.i30
  %retval.0.i29 = phi i64 [ %7, %if.then.i28 ], [ %conv.i33, %if.end.i30 ]
  %child5 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %call1, i64 0, i32 1
  store i64 %retval.0.i29, ptr %child5, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 1
  %11 = load ptr, ptr %name, align 8
  %call6 = tail call noalias ptr @g_strdup(ptr noundef %11) #29
  %name7 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %call1, i64 0, i32 2
  store ptr %call6, ptr %name7, align 8
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 5
  %perm12 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %call1, i64 0, i32 3
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 6
  %shared_perm23 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %call1, i64 0, i32 4
  br label %bdrv_qapi_perm_to_blk_perm.exit

bdrv_qapi_perm_to_blk_perm.exit:                  ; preds = %xdbg_graph_node_num.exit35, %for.inc
  %indvars.iv = phi i64 [ 0, %xdbg_graph_node_num.exit35 ], [ %indvars.iv.next, %for.inc ]
  %arrayidx.i = getelementptr [4 x i64], ptr @bdrv_qapi_perm_to_blk_perm.permissions, i64 0, i64 %indvars.iv
  %12 = load i64, ptr %arrayidx.i, align 8
  %13 = load i64, ptr %perm, align 8
  %and = and i64 %13, %12
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end15, label %do.body10

do.body10:                                        ; preds = %bdrv_qapi_perm_to_blk_perm.exit
  %call11 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc(i64 noundef 16) #30
  %value = getelementptr inbounds %struct.BlockPermissionList, ptr %call11, i64 0, i32 1
  %14 = trunc i64 %indvars.iv to i32
  store i32 %14, ptr %value, align 8
  %15 = load ptr, ptr %perm12, align 8
  store ptr %15, ptr %call11, align 8
  store ptr %call11, ptr %perm12, align 8
  br label %if.end15

if.end15:                                         ; preds = %do.body10, %bdrv_qapi_perm_to_blk_perm.exit
  %16 = load i64, ptr %shared_perm, align 8
  %and16 = and i64 %16, %12
  %tobool17.not = icmp eq i64 %and16, 0
  br i1 %tobool17.not, label %for.inc, label %do.body19

do.body19:                                        ; preds = %if.end15
  %call21 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc(i64 noundef 16) #30
  %value22 = getelementptr inbounds %struct.BlockPermissionList, ptr %call21, i64 0, i32 1
  %17 = trunc i64 %indvars.iv to i32
  store i32 %17, ptr %value22, align 8
  %18 = load ptr, ptr %shared_perm23, align 8
  store ptr %18, ptr %call21, align 8
  store ptr %call21, ptr %shared_perm23, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end15, %do.body19
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 4
  br i1 %exitcond.not, label %do.body28, label %bdrv_qapi_perm_to_blk_perm.exit, !llvm.loop !73

do.body28:                                        ; preds = %for.inc
  %call30 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc(i64 noundef 16) #30
  %value31 = getelementptr inbounds %struct.XDbgBlockGraphEdgeList, ptr %call30, i64 0, i32 1
  store ptr %call1, ptr %value31, align 8
  %19 = load ptr, ptr %gr, align 8
  %edges = getelementptr inbounds %struct.XDbgBlockGraph, ptr %19, i64 0, i32 1
  %20 = load ptr, ptr %edges, align 8
  store ptr %20, ptr %call30, align 8
  store ptr %call30, ptr %edges, align 8
  ret void
}

declare ptr @block_job_next_locked(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_lookup_bs(ptr noundef %device, ptr noundef %node_name, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6503, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_lookup_bs) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %device, null
  br i1 %tobool.not, label %if.end10, label %if.then1

if.then1:                                         ; preds = %do.end
  %call2 = tail call ptr @blk_by_name(ptr noundef nonnull %device) #29
  %tobool3.not = icmp eq ptr %call2, null
  br i1 %tobool3.not, label %if.end10, label %if.then4

if.then4:                                         ; preds = %if.then1
  %call5 = tail call ptr @blk_bs(ptr noundef nonnull %call2) #29
  %tobool6.not = icmp eq ptr %call5, null
  br i1 %tobool6.not, label %if.then7, label %return

if.then7:                                         ; preds = %if.then4
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 6511, ptr noundef nonnull @__func__.bdrv_lookup_bs, ptr noundef nonnull @.str.100, ptr noundef nonnull %device) #29
  br label %return

if.end10:                                         ; preds = %if.then1, %do.end
  %tobool11.not = icmp eq ptr %node_name, null
  br i1 %tobool11.not, label %if.end17, label %do.body.i

do.body.i:                                        ; preds = %if.end10
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %for.cond.preheader.i, label %if.else2.i

for.cond.preheader.i:                             ; preds = %do.body.i
  %bs.05.i = load ptr, ptr @graph_bdrv_states, align 8
  %tobool4.not6.i = icmp eq ptr %bs.05.i, null
  br i1 %tobool4.not6.i, label %if.end17, label %for.body.i

if.else2.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6329, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %bs.07.i = phi ptr [ %bs.0.i, %for.inc.i ], [ %bs.05.i, %for.cond.preheader.i ]
  %node_name5.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07.i, i64 0, i32 22
  %call6.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %node_name, ptr noundef nonnull dereferenceable(1) %node_name5.i) #28
  %tobool7.not.i = icmp eq i32 %call6.i, 0
  br i1 %tobool7.not.i, label %return, label %for.inc.i

for.inc.i:                                        ; preds = %for.body.i
  %node_list.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07.i, i64 0, i32 23
  %bs.0.i = load ptr, ptr %node_list.i, align 8
  %tobool4.not.i = icmp eq ptr %bs.0.i, null
  br i1 %tobool4.not.i, label %if.end17, label %for.body.i, !llvm.loop !15

if.end17:                                         ; preds = %for.inc.i, %for.cond.preheader.i, %if.end10
  %cond23 = phi ptr [ @.str.95, %if.end10 ], [ %node_name, %for.cond.preheader.i ], [ %node_name, %for.inc.i ]
  %cond = select i1 %tobool.not, ptr @.str.95, ptr %device
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 6528, ptr noundef nonnull @__func__.bdrv_lookup_bs, ptr noundef nonnull @.str.101, ptr noundef nonnull %cond, ptr noundef nonnull %cond23) #29
  br label %return

return:                                           ; preds = %for.body.i, %if.then4, %if.then7, %if.end17
  %retval.0 = phi ptr [ null, %if.end17 ], [ null, %if.then7 ], [ %call5, %if.then4 ], [ %bs.07.i, %for.body.i ]
  ret ptr %retval.0
}

declare ptr @blk_by_name(ptr noundef) local_unnamed_addr #5

declare ptr @blk_bs(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_next_node(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6548, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_next_node) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %bs, null
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 23
  %retval.0.in = select i1 %tobool.not, ptr @graph_bdrv_states, ptr %node_list
  %retval.0 = load ptr, ptr %retval.0.in, align 8
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_next_all_states(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6557, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_next_all_states) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %bs, null
  %bs_list = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 24
  %retval.0.in = select i1 %tobool.not, ptr @all_bdrv_states, ptr %bs_list
  %retval.0 = load ptr, ptr %retval.0.in, align 8
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local nonnull ptr @bdrv_get_node_name(ptr noundef readnone %bs) local_unnamed_addr #20 {
entry:
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 22
  ret ptr %node_name
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_parent_name(ptr nocapture noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.07 = load ptr, ptr %parents, align 8
  %tobool.not8 = icmp eq ptr %c.07, null
  br i1 %tobool.not8, label %return, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %c.09 = phi ptr [ %c.0, %for.inc ], [ %c.07, %entry ]
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %c.09, i64 0, i32 2
  %0 = load ptr, ptr %klass, align 8
  %get_name = getelementptr inbounds %struct.BdrvChildClass, ptr %0, i64 0, i32 15
  %1 = load ptr, ptr %get_name, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %call = tail call ptr %1(ptr noundef nonnull %c.09) #29
  %tobool4.not = icmp eq ptr %call, null
  br i1 %tobool4.not, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %2 = load i8, ptr %call, align 1
  %tobool5.not = icmp eq i8 %2, 0
  br i1 %tobool5.not, label %for.inc, label %return

for.inc:                                          ; preds = %for.body, %land.lhs.true, %if.then
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %c.09, i64 0, i32 10
  %c.0 = load ptr, ptr %next_parent, align 8
  %tobool.not = icmp eq ptr %c.0, null
  br i1 %tobool.not, label %return, label %for.body, !llvm.loop !5

return:                                           ; preds = %land.lhs.true, %for.inc, %entry
  %retval.0 = phi ptr [ null, %entry ], [ null, %for.inc ], [ %call, %land.lhs.true ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_device_name(ptr nocapture noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.07.i = load ptr, ptr %parents.i, align 8
  %tobool.not8.i = icmp eq ptr %c.07.i, null
  br i1 %tobool.not8.i, label %bdrv_get_parent_name.exit, label %for.body.i

for.body.i:                                       ; preds = %entry, %for.inc.i
  %c.09.i = phi ptr [ %c.0.i, %for.inc.i ], [ %c.07.i, %entry ]
  %klass.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i, i64 0, i32 2
  %0 = load ptr, ptr %klass.i, align 8
  %get_name.i = getelementptr inbounds %struct.BdrvChildClass, ptr %0, i64 0, i32 15
  %1 = load ptr, ptr %get_name.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %call.i = tail call ptr %1(ptr noundef nonnull %c.09.i) #29
  %tobool4.not.i = icmp eq ptr %call.i, null
  br i1 %tobool4.not.i, label %for.inc.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.then.i
  %2 = load i8, ptr %call.i, align 1
  %tobool5.not.i = icmp eq i8 %2, 0
  br i1 %tobool5.not.i, label %for.inc.i, label %bdrv_get_parent_name.exit

for.inc.i:                                        ; preds = %land.lhs.true.i, %if.then.i, %for.body.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i, i64 0, i32 10
  %c.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool.not.i, label %bdrv_get_parent_name.exit, label %for.body.i, !llvm.loop !5

bdrv_get_parent_name.exit:                        ; preds = %land.lhs.true.i, %for.inc.i, %entry
  %retval.0.i = phi ptr [ null, %entry ], [ %call.i, %land.lhs.true.i ], [ null, %for.inc.i ]
  %tobool.not = icmp eq ptr %retval.0.i, null
  %cond = select i1 %tobool.not, ptr @.str.95, ptr %retval.0.i
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_device_or_node_name(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.07.i = load ptr, ptr %parents.i, align 8
  %tobool.not8.i = icmp eq ptr %c.07.i, null
  br i1 %tobool.not8.i, label %bdrv_get_parent_name.exit, label %for.body.i

for.body.i:                                       ; preds = %entry, %for.inc.i
  %c.09.i = phi ptr [ %c.0.i, %for.inc.i ], [ %c.07.i, %entry ]
  %klass.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i, i64 0, i32 2
  %0 = load ptr, ptr %klass.i, align 8
  %get_name.i = getelementptr inbounds %struct.BdrvChildClass, ptr %0, i64 0, i32 15
  %1 = load ptr, ptr %get_name.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %call.i = tail call ptr %1(ptr noundef nonnull %c.09.i) #29
  %tobool4.not.i = icmp eq ptr %call.i, null
  br i1 %tobool4.not.i, label %for.inc.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.then.i
  %2 = load i8, ptr %call.i, align 1
  %tobool5.not.i = icmp eq i8 %2, 0
  br i1 %tobool5.not.i, label %for.inc.i, label %bdrv_get_parent_name.exit

for.inc.i:                                        ; preds = %land.lhs.true.i, %if.then.i, %for.body.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i, i64 0, i32 10
  %c.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool.not.i, label %bdrv_get_parent_name.exit, label %for.body.i, !llvm.loop !5

bdrv_get_parent_name.exit:                        ; preds = %land.lhs.true.i, %for.inc.i, %entry
  %retval.0.i = phi ptr [ null, %entry ], [ %call.i, %land.lhs.true.i ], [ null, %for.inc.i ]
  %tobool.not = icmp eq ptr %retval.0.i, null
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 22
  %cond = select i1 %tobool.not, ptr %node_name, ptr %retval.0.i
  ret ptr %cond
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local i32 @bdrv_get_flags(ptr nocapture noundef readonly %bs) local_unnamed_addr #3 {
entry:
  %0 = load i32, ptr %bs, align 8
  ret i32 %0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_has_zero_init_1(ptr nocapture noundef readnone %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6614, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_has_zero_init_1) #31
  unreachable

do.end:                                           ; preds = %entry
  ret i32 1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_has_zero_init(ptr noundef %bs) #4 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %bdrv_filter_bs.exit, %entry
  %bs.tr = phi ptr [ %bs, %entry ], [ %11, %bdrv_filter_bs.exit ]
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %tailrecurse
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6621, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_has_zero_init) #31
  unreachable

do.end:                                           ; preds = %tailrecurse
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end.i

if.end.i:                                         ; preds = %do.end
  %is_filter.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter.i, align 4
  %2 = and i8 %1, 1
  %tobool3.not.i = icmp eq i8 %2, 0
  br i1 %tobool3.not.i, label %if.end5.i, label %if.end6.thread

if.end5.i:                                        ; preds = %if.end.i
  %backing.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 30
  %3 = load ptr, ptr %backing.i, align 8
  %tobool6.not.i = icmp eq ptr %3, null
  br i1 %tobool6.not.i, label %if.end6, label %if.end8.i

if.end8.i:                                        ; preds = %if.end5.i
  %role.i = getelementptr inbounds %struct.BdrvChild, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %role.i, align 8
  %and.i = and i32 %4, 8
  %tobool10.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool10.not.i, label %if.else.i, label %return

if.else.i:                                        ; preds = %if.end8.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

if.end6:                                          ; preds = %if.end5.i
  %bdrv_has_zero_init = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 46
  %5 = load ptr, ptr %bdrv_has_zero_init, align 8
  %tobool8.not = icmp eq ptr %5, null
  br i1 %tobool8.not, label %return, label %if.then9

if.end6.thread:                                   ; preds = %if.end.i
  %bdrv_has_zero_init27 = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 46
  %6 = load ptr, ptr %bdrv_has_zero_init27, align 8
  %tobool8.not28 = icmp eq ptr %6, null
  br i1 %tobool8.not28, label %if.end5.i.i, label %if.then9

if.then9:                                         ; preds = %if.end6.thread, %if.end6
  %7 = phi ptr [ %5, %if.end6 ], [ %6, %if.end6.thread ]
  %call12 = tail call i32 %7(ptr noundef nonnull %bs.tr) #29
  br label %return

if.end5.i.i:                                      ; preds = %if.end6.thread
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 30
  %8 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %8, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 31
  %9 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %9, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %return, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %9, %cond.end.i.i ], [ %8, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %10 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %10, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %bdrv_filter_bs.exit

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

bdrv_filter_bs.exit:                              ; preds = %if.end15.i.i
  %11 = load ptr, ptr %cond12.i.i, align 8
  %tobool15.not = icmp eq ptr %11, null
  br i1 %tobool15.not, label %return, label %tailrecurse

return:                                           ; preds = %cond.end.i.i, %bdrv_filter_bs.exit, %do.end, %if.end6, %if.end8.i, %if.then9
  %retval.0 = phi i32 [ %call12, %if.then9 ], [ 0, %if.end8.i ], [ 0, %if.end6 ], [ 0, %do.end ], [ 0, %bdrv_filter_bs.exit ], [ 0, %cond.end.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_cow_child(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter, align 4
  %2 = and i8 %1, 1
  %tobool3.not = icmp eq i8 %2, 0
  br i1 %tobool3.not, label %if.end5, label %return

if.end5:                                          ; preds = %if.end
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %3 = load ptr, ptr %backing, align 8
  %tobool6.not = icmp eq ptr %3, null
  br i1 %tobool6.not, label %return, label %if.end8

if.end8:                                          ; preds = %if.end5
  %role = getelementptr inbounds %struct.BdrvChild, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %role, align 8
  %and = and i32 %4, 8
  %tobool10.not = icmp eq i32 %and, 0
  br i1 %tobool10.not, label %if.else, label %return

if.else:                                          ; preds = %if.end8
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

return:                                           ; preds = %if.end8, %if.end5, %if.end, %entry, %lor.lhs.false
  %retval.0 = phi ptr [ null, %lor.lhs.false ], [ null, %entry ], [ null, %if.end ], [ null, %if.end5 ], [ %3, %if.end8 ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable
define dso_local zeroext i1 @bdrv_can_write_zeroes_with_unmap(ptr nocapture noundef readonly %bs) local_unnamed_addr #3 {
entry:
  %0 = load i32, ptr %bs, align 8
  %and = and i32 %0, 16384
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %supported_zero_flags = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 20
  %1 = load i32, ptr %supported_zero_flags, align 8
  %and1 = and i32 %1, 4
  %tobool2 = icmp ne i32 %and1, 0
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i1 [ %tobool2, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_get_backing_filename(ptr noundef %bs, ptr noundef %filename, i32 noundef %filename_size) local_unnamed_addr #4 {
entry:
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 12
  tail call void @pstrcpy(ptr noundef %filename, i32 noundef %filename_size, ptr noundef nonnull %backing_file) #29
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_get_info(ptr noundef %bs, ptr noundef %bdi) #4 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %bdrv_filter_bs.exit, %entry
  %bs.tr = phi ptr [ %bs, %entry ], [ %9, %bdrv_filter_bs.exit ]
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %tailrecurse
  %bdrv_co_get_info = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 93
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_get_info, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 731, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %lor.lhs.false.i.i, label %if.end8

lor.lhs.false.i.i:                                ; preds = %if.end
  %3 = load ptr, ptr %drv1, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %lor.lhs.false.i.i
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %3, i64 0, i32 2
  %4 = load i8, ptr %is_filter.i.i, align 4
  %5 = and i8 %4, 1
  %tobool3.not.i.i = icmp eq i8 %5, 0
  br i1 %tobool3.not.i.i, label %return, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 30
  %6 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %6, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 31
  %7 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %7, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %return, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %7, %cond.end.i.i ], [ %6, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %8 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %8, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %bdrv_filter_bs.exit

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

bdrv_filter_bs.exit:                              ; preds = %if.end15.i.i
  %9 = load ptr, ptr %cond12.i.i, align 8
  %tobool4.not = icmp eq ptr %9, null
  br i1 %tobool4.not, label %return, label %tailrecurse

if.end8:                                          ; preds = %if.end
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %bdi, i8 0, i64 24, i1 false)
  %10 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_get_info, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 731, ptr null)
  %11 = load ptr, ptr %10, align 8
  %call10 = tail call i32 %11(ptr noundef nonnull %bs.tr, ptr noundef %bdi) #29
  %subcluster_size = getelementptr inbounds %struct.BlockDriverInfo, ptr %bdi, i64 0, i32 1
  %12 = load i32, ptr %subcluster_size, align 4
  %cmp = icmp eq i32 %12, 0
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %13 = load i32, ptr %bdi, align 8
  store i32 %13, ptr %subcluster_size, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  %cmp14 = icmp slt i32 %call10, 0
  br i1 %cmp14, label %return, label %if.end16

if.end16:                                         ; preds = %if.end13
  %14 = load i32, ptr %bdi, align 8
  %cmp18 = icmp sgt i32 %14, 1073741824
  %. = select i1 %cmp18, i32 -22, i32 0
  br label %return

return:                                           ; preds = %cond.end.i.i, %if.end.i.i, %lor.lhs.false.i.i, %bdrv_filter_bs.exit, %tailrecurse, %if.end16, %if.end13
  %retval.0 = phi i32 [ %call10, %if.end13 ], [ %., %if.end16 ], [ -95, %cond.end.i.i ], [ -95, %if.end.i.i ], [ -95, %lor.lhs.false.i.i ], [ -95, %bdrv_filter_bs.exit ], [ -123, %tailrecurse ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_specific_info(ptr noundef %bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %bdrv_get_specific_info = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 94
  %1 = load ptr, ptr %bdrv_get_specific_info, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = tail call ptr %1(ptr noundef nonnull %bs, ptr noundef %errp) #29
  br label %return

return:                                           ; preds = %entry, %land.lhs.true, %if.then
  %retval.0 = phi ptr [ %call, %if.then ], [ null, %land.lhs.true ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_specific_stats(ptr noundef %bs) local_unnamed_addr #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bdrv_get_specific_stats = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 95
  %1 = load ptr, ptr %bdrv_get_specific_stats, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call = tail call ptr %1(ptr noundef nonnull %bs) #29
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi ptr [ %call, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_debug_event(ptr noundef %bs, i32 noundef %event) #4 {
entry:
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %bdrv_co_debug_event = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 107
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_debug_event, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 776, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool4.not = icmp eq ptr %2, null
  br i1 %tobool4.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %3 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_debug_event, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 776, ptr null)
  %4 = load ptr, ptr %3, align 8
  tail call void %4(ptr noundef nonnull %bs, i32 noundef %event) #29
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %lor.lhs.false2, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_debug_breakpoint(ptr noundef %bs, ptr noundef %event, ptr noundef %tag) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6752, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_debug_breakpoint) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2 = tail call fastcc ptr @bdrv_find_debug_node(ptr noundef %bs)
  %tobool.not = icmp eq ptr %call2, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.then3

if.then3:                                         ; preds = %do.end
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %call2, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %bdrv_debug_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 41
  %1 = load ptr, ptr %bdrv_debug_breakpoint, align 8
  %call4 = tail call i32 %1(ptr noundef nonnull %call2, ptr noundef %event, ptr noundef %tag) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %do.end, %if.then3
  %retval.0 = phi i32 [ %call4, %if.then3 ], [ -95, %do.end ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_find_debug_node(ptr noundef readonly %bs) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %while.cond.preheader, label %if.else

while.cond.preheader:                             ; preds = %entry
  %tobool.not13 = icmp eq ptr %bs, null
  br i1 %tobool.not13, label %return, label %land.lhs.true

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6736, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_debug_node) #31
  unreachable

land.lhs.true:                                    ; preds = %while.cond.preheader, %bdrv_primary_bs.exit
  %bs.addr.014 = phi ptr [ %4, %bdrv_primary_bs.exit ], [ %bs, %while.cond.preheader ]
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.014, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true
  %bdrv_debug_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 41
  %1 = load ptr, ptr %bdrv_debug_breakpoint, align 8
  %tobool3.not = icmp eq ptr %1, null
  br i1 %tobool3.not, label %while.body, label %if.then13

while.body:                                       ; preds = %land.rhs
  %2 = getelementptr i8, ptr %bs.addr.014, i64 16824
  %bs.addr.0.val = load ptr, ptr %2, align 8
  %tobool.not7.i.i = icmp eq ptr %bs.addr.0.val, null
  br i1 %tobool.not7.i.i, label %return, label %for.body.i.i

for.body.i.i:                                     ; preds = %while.body, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %bs.addr.0.val, %while.body ]
  %found.08.i.i = phi ptr [ %found.1.i.i, %for.inc.i.i ], [ null, %while.body ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 3
  %3 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %3, 16
  %tobool1.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %tobool2.not.i.i = icmp eq ptr %found.08.i.i, null
  br i1 %tobool2.not.i.i, label %for.inc.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.155, ptr noundef nonnull @.str.2, i32 noundef 8506, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_primary_child) #31
  unreachable

for.inc.i.i:                                      ; preds = %if.then.i.i, %for.body.i.i
  %found.1.i.i = phi ptr [ %found.08.i.i, %for.body.i.i ], [ %c.09.i.i, %if.then.i.i ]
  %next.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 9
  %c.0.i.i = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_primary_child.exit.i, label %for.body.i.i, !llvm.loop !35

bdrv_primary_child.exit.i:                        ; preds = %for.inc.i.i
  %tobool.not.i1.i = icmp eq ptr %found.1.i.i, null
  br i1 %tobool.not.i1.i, label %return, label %bdrv_primary_bs.exit

bdrv_primary_bs.exit:                             ; preds = %bdrv_primary_child.exit.i
  %4 = load ptr, ptr %found.1.i.i, align 8
  %tobool.not = icmp eq ptr %4, null
  br i1 %tobool.not, label %return, label %land.lhs.true, !llvm.loop !74

if.then13:                                        ; preds = %land.rhs
  %bdrv_debug_remove_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 42
  %5 = load ptr, ptr %bdrv_debug_remove_breakpoint, align 8
  %tobool15.not = icmp eq ptr %5, null
  br i1 %tobool15.not, label %if.else17, label %return

if.else17:                                        ; preds = %if.then13
  tail call void @__assert_fail(ptr noundef nonnull @.str.281, ptr noundef nonnull @.str.2, i32 noundef 6742, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_debug_node) #31
  unreachable

return:                                           ; preds = %while.body, %bdrv_primary_child.exit.i, %bdrv_primary_bs.exit, %land.lhs.true, %while.cond.preheader, %if.then13
  %retval.0 = phi ptr [ %bs.addr.014, %if.then13 ], [ null, %while.cond.preheader ], [ null, %land.lhs.true ], [ null, %bdrv_primary_bs.exit ], [ null, %bdrv_primary_child.exit.i ], [ null, %while.body ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_debug_remove_breakpoint(ptr noundef %bs, ptr noundef %tag) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6765, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_debug_remove_breakpoint) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2 = tail call fastcc ptr @bdrv_find_debug_node(ptr noundef %bs)
  %tobool.not = icmp eq ptr %call2, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.then3

if.then3:                                         ; preds = %do.end
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %call2, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %bdrv_debug_remove_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 42
  %1 = load ptr, ptr %bdrv_debug_remove_breakpoint, align 8
  %call4 = tail call i32 %1(ptr noundef nonnull %call2, ptr noundef %tag) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %do.end, %if.then3
  %retval.0 = phi i32 [ %call4, %if.then3 ], [ -95, %do.end ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_debug_resume(ptr noundef %bs, ptr noundef %tag) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6778, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_debug_resume) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %tobool.not15 = icmp eq ptr %bs, null
  br i1 %tobool.not15, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %land.rhs

land.rhs:                                         ; preds = %do.end, %bdrv_primary_bs.exit
  %bs.addr.016 = phi ptr [ %4, %bdrv_primary_bs.exit ], [ %bs, %do.end ]
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.016, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %bdrv_debug_resume = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 43
  %1 = load ptr, ptr %bdrv_debug_resume, align 8
  %tobool4.not = icmp eq ptr %1, null
  br i1 %tobool4.not, label %while.body, label %if.then13

while.body:                                       ; preds = %land.rhs, %lor.rhs
  %2 = getelementptr i8, ptr %bs.addr.016, i64 16824
  %bs.addr.0.val = load ptr, ptr %2, align 8
  %tobool.not7.i.i = icmp eq ptr %bs.addr.0.val, null
  br i1 %tobool.not7.i.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %while.body, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %bs.addr.0.val, %while.body ]
  %found.08.i.i = phi ptr [ %found.1.i.i, %for.inc.i.i ], [ null, %while.body ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 3
  %3 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %3, 16
  %tobool1.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %tobool2.not.i.i = icmp eq ptr %found.08.i.i, null
  br i1 %tobool2.not.i.i, label %for.inc.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.155, ptr noundef nonnull @.str.2, i32 noundef 8506, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_primary_child) #31
  unreachable

for.inc.i.i:                                      ; preds = %if.then.i.i, %for.body.i.i
  %found.1.i.i = phi ptr [ %found.08.i.i, %for.body.i.i ], [ %c.09.i.i, %if.then.i.i ]
  %next.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 9
  %c.0.i.i = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_primary_child.exit.i, label %for.body.i.i, !llvm.loop !35

bdrv_primary_child.exit.i:                        ; preds = %for.inc.i.i
  %tobool.not.i1.i = icmp eq ptr %found.1.i.i, null
  br i1 %tobool.not.i1.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %bdrv_primary_bs.exit

bdrv_primary_bs.exit:                             ; preds = %bdrv_primary_child.exit.i
  %4 = load ptr, ptr %found.1.i.i, align 8
  %tobool.not = icmp eq ptr %4, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %land.rhs, !llvm.loop !75

if.then13:                                        ; preds = %lor.rhs
  %call16 = tail call i32 %1(ptr noundef nonnull %bs.addr.016, ptr noundef %tag) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %while.body, %bdrv_primary_child.exit.i, %bdrv_primary_bs.exit, %do.end, %if.then13
  %retval.0 = phi i32 [ %call16, %if.then13 ], [ -95, %do.end ], [ -95, %bdrv_primary_bs.exit ], [ -95, %bdrv_primary_child.exit.i ], [ -95, %while.body ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_debug_is_suspended(ptr noundef %bs, ptr noundef %tag) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6794, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_debug_is_suspended) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %tobool.not16 = icmp eq ptr %bs, null
  br i1 %tobool.not16, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end, %bdrv_primary_bs.exit
  %bs.addr.017 = phi ptr [ %4, %bdrv_primary_bs.exit ], [ %bs, %do.end ]
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.017, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true
  %bdrv_debug_is_suspended = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 44
  %1 = load ptr, ptr %bdrv_debug_is_suspended, align 8
  %tobool4.not = icmp eq ptr %1, null
  br i1 %tobool4.not, label %while.body, label %if.then14

while.body:                                       ; preds = %land.rhs
  %2 = getelementptr i8, ptr %bs.addr.017, i64 16824
  %bs.addr.0.val = load ptr, ptr %2, align 8
  %tobool.not7.i.i = icmp eq ptr %bs.addr.0.val, null
  br i1 %tobool.not7.i.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %while.body, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %bs.addr.0.val, %while.body ]
  %found.08.i.i = phi ptr [ %found.1.i.i, %for.inc.i.i ], [ null, %while.body ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 3
  %3 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %3, 16
  %tobool1.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %tobool2.not.i.i = icmp eq ptr %found.08.i.i, null
  br i1 %tobool2.not.i.i, label %for.inc.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.155, ptr noundef nonnull @.str.2, i32 noundef 8506, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_primary_child) #31
  unreachable

for.inc.i.i:                                      ; preds = %if.then.i.i, %for.body.i.i
  %found.1.i.i = phi ptr [ %found.08.i.i, %for.body.i.i ], [ %c.09.i.i, %if.then.i.i ]
  %next.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 9
  %c.0.i.i = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_primary_child.exit.i, label %for.body.i.i, !llvm.loop !35

bdrv_primary_child.exit.i:                        ; preds = %for.inc.i.i
  %tobool.not.i1.i = icmp eq ptr %found.1.i.i, null
  br i1 %tobool.not.i1.i, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %bdrv_primary_bs.exit

bdrv_primary_bs.exit:                             ; preds = %bdrv_primary_child.exit.i
  %4 = load ptr, ptr %found.1.i.i, align 8
  %tobool.not = icmp eq ptr %4, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %land.lhs.true, !llvm.loop !76

if.then14:                                        ; preds = %land.rhs
  %call17 = tail call zeroext i1 %1(ptr noundef nonnull %bs.addr.017, ptr noundef %tag) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %while.body, %bdrv_primary_child.exit.i, %bdrv_primary_bs.exit, %land.lhs.true, %do.end, %if.then14
  %retval.0 = phi i1 [ %call17, %if.then14 ], [ false, %do.end ], [ false, %land.lhs.true ], [ false, %bdrv_primary_bs.exit ], [ false, %bdrv_primary_child.exit.i ], [ false, %while.body ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret i1 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_backing_image(ptr noundef %bs, ptr noundef %backing_file) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6824, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_backing_image) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool3 = icmp ne ptr %0, null
  %tobool5 = icmp ne ptr %backing_file, null
  %or.cond = and i1 %tobool5, %tobool3
  br i1 %or.cond, label %if.end7, label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end7:                                          ; preds = %lor.lhs.false
  %call8 = tail call noalias dereferenceable_or_null(4096) ptr @g_malloc(i64 noundef 4096) #30
  %call9 = tail call noalias dereferenceable_or_null(4096) ptr @g_malloc(i64 noundef 4096) #30
  %call.i = tail call i64 @strcspn(ptr noundef nonnull %backing_file, ptr noundef nonnull @.str) #28
  %add.ptr.i = getelementptr i8, ptr %backing_file, i64 %call.i
  %1 = load i8, ptr %add.ptr.i, align 1
  %cmp.i.not = icmp eq i8 %1, 58
  %call.i34 = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef nonnull %bs, i1 noundef zeroext false)
  %tobool.not.i58 = icmp eq ptr %call.i34, null
  br i1 %tobool.not.i58, label %for.end, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end7, %for.inc
  %curr_bs.060 = phi ptr [ %call.i1.i, %for.inc ], [ %call.i34, %if.end7 ]
  %filenames_refreshed.059 = phi i8 [ %filenames_refreshed.2, %for.inc ], [ 0, %if.end7 ]
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %curr_bs.060, i64 0, i32 6
  %2 = load ptr, ptr %drv.i, align 8
  %tobool1.not.i = icmp eq ptr %2, null
  br i1 %tobool1.not.i, label %for.end, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  %is_filter.i = getelementptr inbounds %struct.BlockDriver, ptr %2, i64 0, i32 2
  %3 = load i8, ptr %is_filter.i, align 4
  %4 = and i8 %3, 1
  %tobool3.not.i = icmp eq i8 %4, 0
  br i1 %tobool3.not.i, label %if.end5.i, label %for.end

if.end5.i:                                        ; preds = %if.end.i
  %backing.i = getelementptr inbounds %struct.BlockDriverState, ptr %curr_bs.060, i64 0, i32 30
  %5 = load ptr, ptr %backing.i, align 8
  %tobool6.not.i = icmp eq ptr %5, null
  br i1 %tobool6.not.i, label %for.end, label %if.end8.i

if.end8.i:                                        ; preds = %if.end5.i
  %role.i = getelementptr inbounds %struct.BdrvChild, ptr %5, i64 0, i32 3
  %6 = load i32, ptr %role.i, align 8
  %and.i = and i32 %6, 8
  %tobool10.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool10.not.i, label %if.else.i, label %for.body

if.else.i:                                        ; preds = %if.end8.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

for.body:                                         ; preds = %if.end8.i
  %call.i.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef nonnull %curr_bs.060, i1 noundef zeroext false)
  %tobool.not.i.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i.i, label %bdrv_backing_chain_next.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %for.body
  %drv.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %call.i.i, i64 0, i32 6
  %7 = load ptr, ptr %drv.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq ptr %7, null
  br i1 %tobool1.not.i.i.i, label %bdrv_backing_chain_next.exit, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %lor.lhs.false.i.i.i
  %is_filter.i.i.i = getelementptr inbounds %struct.BlockDriver, ptr %7, i64 0, i32 2
  %8 = load i8, ptr %is_filter.i.i.i, align 4
  %9 = and i8 %8, 1
  %tobool3.not.i.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i.i, label %if.end5.i.i.i, label %bdrv_backing_chain_next.exit

if.end5.i.i.i:                                    ; preds = %if.end.i.i.i
  %backing.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %call.i.i, i64 0, i32 30
  %10 = load ptr, ptr %backing.i.i.i, align 8
  %tobool6.not.i.i.i = icmp eq ptr %10, null
  br i1 %tobool6.not.i.i.i, label %bdrv_backing_chain_next.exit, label %if.end8.i.i.i

if.end8.i.i.i:                                    ; preds = %if.end5.i.i.i
  %role.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %10, i64 0, i32 3
  %11 = load i32, ptr %role.i.i.i, align 8
  %and.i.i.i = and i32 %11, 8
  %tobool10.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool10.not.i.i.i, label %if.else.i.i.i, label %cond.true.i.i.i

if.else.i.i.i:                                    ; preds = %if.end8.i.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 8438, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_cow_child) #31
  unreachable

cond.true.i.i.i:                                  ; preds = %if.end8.i.i.i
  %12 = load ptr, ptr %10, align 8
  br label %bdrv_backing_chain_next.exit

bdrv_backing_chain_next.exit:                     ; preds = %for.body, %lor.lhs.false.i.i.i, %if.end.i.i.i, %if.end5.i.i.i, %cond.true.i.i.i
  %cond.i.i.i = phi ptr [ %12, %cond.true.i.i.i ], [ null, %lor.lhs.false.i.i.i ], [ null, %for.body ], [ null, %if.end.i.i.i ], [ null, %if.end5.i.i.i ]
  %call.i1.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef %cond.i.i.i, i1 noundef zeroext false)
  %call.i35 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i35, label %do.end.i, label %if.else.i36

if.else.i36:                                      ; preds = %bdrv_backing_chain_next.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8142, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_backing_overridden) #31
  unreachable

do.end.i:                                         ; preds = %bdrv_backing_chain_next.exit
  %13 = load ptr, ptr %backing.i, align 8
  %tobool.not.i38 = icmp eq ptr %13, null
  %auto_backing_file8.i = getelementptr inbounds %struct.BlockDriverState, ptr %curr_bs.060, i64 0, i32 13
  br i1 %tobool.not.i38, label %bdrv_backing_overridden.exit, label %if.then1.i

if.then1.i:                                       ; preds = %do.end.i
  %14 = load ptr, ptr %13, align 8
  %filename.i = getelementptr inbounds %struct.BlockDriverState, ptr %14, i64 0, i32 11
  %call5.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %auto_backing_file8.i, ptr noundef nonnull dereferenceable(1) %filename.i) #28
  %tobool6.i.not = icmp eq i32 %call5.i, 0
  br i1 %tobool6.i.not, label %if.else23, label %if.then15

bdrv_backing_overridden.exit:                     ; preds = %do.end.i
  %15 = load i8, ptr %auto_backing_file8.i, align 1
  %cmp.i40.not = icmp eq i8 %15, 0
  br i1 %cmp.i40.not, label %if.else23, label %if.then15

if.then15:                                        ; preds = %if.then1.i, %bdrv_backing_overridden.exit
  %16 = and i8 %filenames_refreshed.059, 1
  %tobool16.not = icmp eq i8 %16, 0
  br i1 %tobool16.not, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then15
  tail call void @bdrv_refresh_filename(ptr noundef %call.i1.i)
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.then15
  %filenames_refreshed.1 = phi i8 [ %filenames_refreshed.059, %if.then15 ], [ 1, %if.then17 ]
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %call.i1.i, i64 0, i32 11
  %call19 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %backing_file, ptr noundef nonnull dereferenceable(1) %filename) #28
  %cmp20 = icmp eq i32 %call19, 0
  br i1 %cmp20, label %for.end, label %for.inc

if.else23:                                        ; preds = %if.then1.i, %bdrv_backing_overridden.exit
  br i1 %cmp.i.not, label %if.then30, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %if.else23
  %backing_file26 = getelementptr inbounds %struct.BlockDriverState, ptr %curr_bs.060, i64 0, i32 12
  %call.i41 = tail call i64 @strcspn(ptr noundef nonnull %backing_file26, ptr noundef nonnull @.str) #28
  %add.ptr.i42 = getelementptr i8, ptr %backing_file26, i64 %call.i41
  %17 = load i8, ptr %add.ptr.i42, align 1
  %cmp.i43.not = icmp eq i8 %17, 58
  br i1 %cmp.i43.not, label %if.then30, label %lor.lhs.false.i46

if.then30:                                        ; preds = %lor.lhs.false25, %if.else23
  %backing_file31 = getelementptr inbounds %struct.BlockDriverState, ptr %curr_bs.060, i64 0, i32 12
  %call33 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %backing_file, ptr noundef nonnull dereferenceable(1) %backing_file31) #28
  %cmp34 = icmp eq i32 %call33, 0
  br i1 %cmp34, label %for.end, label %if.end36

if.end36:                                         ; preds = %if.then30
  %call37 = tail call ptr @bdrv_get_full_backing_filename(ptr noundef nonnull %curr_bs.060, ptr noundef null)
  %tobool38.not = icmp eq ptr %call37, null
  br i1 %tobool38.not, label %for.inc, label %if.then39

if.then39:                                        ; preds = %if.end36
  %call40 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %backing_file, ptr noundef nonnull dereferenceable(1) %call37) #28
  %cmp41 = icmp eq i32 %call40, 0
  tail call void @g_free(ptr noundef nonnull %call37) #29
  br i1 %cmp41, label %for.end, label %for.inc

lor.lhs.false.i46:                                ; preds = %lor.lhs.false25
  %18 = load i8, ptr %backing_file, align 1
  %cmp.i47 = icmp eq i8 %18, 0
  br i1 %cmp.i47, label %for.inc.sink.split, label %if.else.i48

if.else.i48:                                      ; preds = %lor.lhs.false.i46
  %call.i.i49 = tail call i64 @strcspn(ptr noundef nonnull %backing_file, ptr noundef nonnull @.str) #28
  %add.ptr.i.i = getelementptr i8, ptr %backing_file, i64 %call.i.i49
  %19 = load i8, ptr %add.ptr.i.i, align 1
  %cmp.i.not.i = icmp eq i8 %19, 58
  %cmp.i8.not.i = icmp eq i8 %18, 47
  %or.cond.i = or i1 %cmp.i8.not.i, %cmp.i.not.i
  br i1 %or.cond.i, label %if.then6.i, label %if.end8.i50

if.then6.i:                                       ; preds = %if.else.i48
  %call7.i = tail call noalias ptr @g_strdup(ptr noundef nonnull %backing_file) #29
  br label %bdrv_make_absolute_filename.exit

if.end8.i50:                                      ; preds = %if.else.i48
  %call9.i = tail call ptr @bdrv_dirname(ptr noundef nonnull %curr_bs.060, ptr noundef null)
  %tobool10.not.i51 = icmp eq ptr %call9.i, null
  br i1 %tobool10.not.i51, label %for.inc.sink.split, label %if.end12.i

if.end12.i:                                       ; preds = %if.end8.i50
  %call13.i = tail call noalias ptr (ptr, ...) @g_strconcat(ptr noundef nonnull %call9.i, ptr noundef nonnull %backing_file, ptr noundef null) #29
  tail call void @g_free(ptr noundef nonnull %call9.i) #29
  br label %bdrv_make_absolute_filename.exit

bdrv_make_absolute_filename.exit:                 ; preds = %if.then6.i, %if.end12.i
  %retval.0.i52 = phi ptr [ %call7.i, %if.then6.i ], [ %call13.i, %if.end12.i ]
  %tobool48.not = icmp eq ptr %retval.0.i52, null
  br i1 %tobool48.not, label %for.inc.sink.split, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %bdrv_make_absolute_filename.exit
  %call50 = tail call ptr @realpath(ptr noundef nonnull %retval.0.i52, ptr noundef %call8) #29
  %tobool51.not = icmp eq ptr %call50, null
  br i1 %tobool51.not, label %for.inc.sink.split, label %if.end53

if.end53:                                         ; preds = %lor.lhs.false49
  tail call void @g_free(ptr noundef nonnull %retval.0.i52) #29
  %call54 = tail call ptr @bdrv_get_full_backing_filename(ptr noundef nonnull %curr_bs.060, ptr noundef null)
  %tobool55.not = icmp eq ptr %call54, null
  br i1 %tobool55.not, label %for.inc.sink.split, label %lor.lhs.false56

lor.lhs.false56:                                  ; preds = %if.end53
  %call57 = tail call ptr @realpath(ptr noundef nonnull %call54, ptr noundef %call9) #29
  %tobool58.not = icmp eq ptr %call57, null
  br i1 %tobool58.not, label %for.inc.sink.split, label %if.end60

if.end60:                                         ; preds = %lor.lhs.false56
  tail call void @g_free(ptr noundef nonnull %call54) #29
  %call61 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %call9, ptr noundef nonnull dereferenceable(1) %call8) #28
  %cmp62 = icmp eq i32 %call61, 0
  br i1 %cmp62, label %for.end, label %for.inc

for.inc.sink.split:                               ; preds = %if.end53, %lor.lhs.false56, %bdrv_make_absolute_filename.exit, %lor.lhs.false49, %lor.lhs.false.i46, %if.end8.i50
  %call54.sink = phi ptr [ %retval.0.i52, %lor.lhs.false49 ], [ null, %bdrv_make_absolute_filename.exit ], [ null, %lor.lhs.false.i46 ], [ null, %if.end8.i50 ], [ %call54, %lor.lhs.false56 ], [ %call54, %if.end53 ]
  tail call void @g_free(ptr noundef %call54.sink) #29
  br label %for.inc

for.inc:                                          ; preds = %for.inc.sink.split, %if.end18, %if.end60, %if.end36, %if.then39
  %filenames_refreshed.2 = phi i8 [ %filenames_refreshed.1, %if.end18 ], [ %filenames_refreshed.059, %if.then39 ], [ %filenames_refreshed.059, %if.end36 ], [ %filenames_refreshed.059, %if.end60 ], [ %filenames_refreshed.059, %for.inc.sink.split ]
  %tobool.not.i = icmp eq ptr %call.i1.i, null
  br i1 %tobool.not.i, label %for.end, label %lor.lhs.false.i, !llvm.loop !77

for.end:                                          ; preds = %if.end18, %if.then30, %if.then39, %if.end60, %lor.lhs.false.i, %for.inc, %if.end.i, %if.end5.i, %if.end7
  %retval1.0 = phi ptr [ null, %if.end7 ], [ null, %if.end5.i ], [ null, %if.end.i ], [ null, %for.inc ], [ null, %lor.lhs.false.i ], [ %call.i1.i, %if.end60 ], [ %call.i1.i, %if.then39 ], [ %call.i1.i, %if.then30 ], [ %call.i1.i, %if.end18 ]
  tail call void @g_free(ptr noundef %call8) #29
  tail call void @g_free(ptr noundef %call9) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %do.end, %lor.lhs.false, %for.end
  %retval.0 = phi ptr [ %retval1.0, %for.end ], [ null, %lor.lhs.false ], [ null, %do.end ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  ret ptr %retval.0
}

; Function Attrs: nofree nounwind
declare noundef ptr @realpath(ptr nocapture noundef readonly, ptr noundef) local_unnamed_addr #21

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_init() local_unnamed_addr #4 {
entry:
  tail call void @module_call_init(i32 noundef 1) #29
  ret void
}

declare void @module_call_init(i32 noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_init_with_whitelist() local_unnamed_addr #4 {
entry:
  store i1 true, ptr @use_bdrv_whitelist, align 4
  tail call void @module_call_init(i32 noundef 1) #29
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_activate(ptr noundef %bs, ptr noundef %errp) #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6944, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_activate) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %if.end3

if.end3:                                          ; preds = %do.end
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.034 = load ptr, ptr %children, align 8
  %tobool4.not35 = icmp eq ptr %child.034, null
  br i1 %tobool4.not35, label %for.end, label %for.body

for.cond:                                         ; preds = %for.body
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.036, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool4.not = icmp eq ptr %child.0, null
  br i1 %tobool4.not, label %for.end, label %for.body, !llvm.loop !78

for.body:                                         ; preds = %if.end3, %for.cond
  %child.036 = phi ptr [ %child.0, %for.cond ], [ %child.034, %if.end3 ]
  %1 = load ptr, ptr %child.036, align 8
  %call6 = call i32 @bdrv_activate(ptr noundef %1, ptr noundef nonnull %local_err), !range !14
  %2 = load ptr, ptr %local_err, align 8
  %tobool7.not = icmp eq ptr %2, null
  br i1 %tobool7.not, label %for.cond, label %if.then8

if.then8:                                         ; preds = %for.body
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %2) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

for.end:                                          ; preds = %for.cond, %if.end3
  %3 = load i32, ptr %bs, align 8
  %and = and i32 %3, 2048
  %tobool10.not = icmp eq i32 %and, 0
  br i1 %tobool10.not, label %if.end37, label %if.then11

if.then11:                                        ; preds = %for.end
  %and13 = and i32 %3, -2049
  store i32 %and13, ptr %bs, align 8
  %call14 = call fastcc i32 @bdrv_refresh_perms(ptr noundef nonnull %bs, ptr noundef null, ptr noundef %errp), !range !14
  %cmp = icmp slt i32 %call14, 0
  br i1 %cmp, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.then11
  %4 = load i32, ptr %bs, align 8
  %or = or i32 %4, 2048
  store i32 %or, ptr %bs, align 8
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end17:                                         ; preds = %if.then11
  %call18 = call i32 @bdrv_invalidate_cache(ptr noundef nonnull %bs, ptr noundef %errp) #29
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end17
  %5 = load i32, ptr %bs, align 8
  %or22 = or i32 %5, 2048
  store i32 %or22, ptr %bs, align 8
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end23:                                         ; preds = %if.end17
  %call24 = call ptr @bdrv_dirty_bitmap_first(ptr noundef nonnull %bs) #29
  %tobool26.not37 = icmp eq ptr %call24, null
  br i1 %tobool26.not37, label %for.end30, label %for.body27

for.body27:                                       ; preds = %if.end23, %for.body27
  %bm.038 = phi ptr [ %call29, %for.body27 ], [ %call24, %if.end23 ]
  call void @bdrv_dirty_bitmap_skip_store(ptr noundef nonnull %bm.038, i1 noundef zeroext false) #29
  %call29 = call ptr @bdrv_dirty_bitmap_next(ptr noundef nonnull %bm.038) #29
  %tobool26.not = icmp eq ptr %call29, null
  br i1 %tobool26.not, label %for.end30, label %for.body27, !llvm.loop !79

for.end30:                                        ; preds = %for.body27, %if.end23
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 37
  %6 = load i64, ptr %total_sectors, align 8
  %call31 = call i32 @bdrv_refresh_total_sectors(ptr noundef nonnull %bs, i64 noundef %6) #29
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %if.then33, label %if.end37

if.then33:                                        ; preds = %for.end30
  %7 = load i32, ptr %bs, align 8
  %or35 = or i32 %7, 2048
  store i32 %or35, ptr %bs, align 8
  %sub = sub i32 0, %call31
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 6993, ptr noundef nonnull @__func__.bdrv_activate, i32 noundef %sub, ptr noundef nonnull @.str.102) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

if.end37:                                         ; preds = %for.end30, %for.end
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %parent.039 = load ptr, ptr %parents, align 8
  %tobool40.not40 = icmp eq ptr %parent.039, null
  br i1 %tobool40.not40, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body41

for.body41:                                       ; preds = %if.end37, %for.inc52
  %parent.041 = phi ptr [ %parent.0, %for.inc52 ], [ %parent.039, %if.end37 ]
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %parent.041, i64 0, i32 2
  %8 = load ptr, ptr %klass, align 8
  %activate = getelementptr inbounds %struct.BdrvChildClass, ptr %8, i64 0, i32 5
  %9 = load ptr, ptr %activate, align 8
  %tobool42.not = icmp eq ptr %9, null
  br i1 %tobool42.not, label %for.inc52, label %if.then43

if.then43:                                        ; preds = %for.body41
  call void %9(ptr noundef nonnull %parent.041, ptr noundef nonnull %local_err) #29
  %10 = load ptr, ptr %local_err, align 8
  %tobool46.not = icmp eq ptr %10, null
  br i1 %tobool46.not, label %for.inc52, label %if.then47

if.then47:                                        ; preds = %if.then43
  %11 = load i32, ptr %bs, align 8
  %or49 = or i32 %11, 2048
  store i32 %or49, ptr %bs, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %10) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

for.inc52:                                        ; preds = %for.body41, %if.then43
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %parent.041, i64 0, i32 10
  %parent.0 = load ptr, ptr %next_parent, align 8
  %tobool40.not = icmp eq ptr %parent.0, null
  br i1 %tobool40.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body41, !llvm.loop !80

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %for.inc52, %if.end37, %do.end, %if.then47, %if.then33, %if.then20, %if.then15, %if.then8
  %retval.0 = phi i32 [ -22, %if.then8 ], [ %call14, %if.then15 ], [ %call18, %if.then20 ], [ %call31, %if.then33 ], [ -22, %if.then47 ], [ -123, %do.end ], [ 0, %if.end37 ], [ 0, %for.inc52 ]
  call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %retval.0
}

declare i32 @bdrv_invalidate_cache(ptr noundef, ptr noundef) #5

declare ptr @bdrv_dirty_bitmap_first(ptr noundef) local_unnamed_addr #5

declare void @bdrv_dirty_bitmap_skip_store(ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

declare ptr @bdrv_dirty_bitmap_next(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_invalidate_cache(ptr noundef %bs, ptr noundef %errp) #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %0 = load i32, ptr %bs, align 8
  %and = and i32 %0, 2048
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.103, ptr noundef nonnull @.str.2, i32 noundef 7017, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_invalidate_cache) #31
  unreachable

if.end:                                           ; preds = %entry
  tail call void @assert_bdrv_graph_readable() #29
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %bdrv_co_invalidate_cache = getelementptr inbounds %struct.BlockDriver, ptr %1, i64 0, i32 82
  %2 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_invalidate_cache, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 668, ptr null)
  %3 = load ptr, ptr %2, align 8
  %tobool1.not = icmp eq ptr %3, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %4 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_invalidate_cache, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 668, ptr null)
  %5 = load ptr, ptr %4, align 8
  call void %5(ptr noundef nonnull %bs, ptr noundef nonnull %local_err) #29
  %6 = load ptr, ptr %local_err, align 8
  %tobool5.not = icmp eq ptr %6, null
  br i1 %tobool5.not, label %return, label %if.then6

if.then6:                                         ; preds = %if.then2
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %6) #29
  br label %return

return:                                           ; preds = %if.end, %if.then2, %if.then6
  %retval.0 = phi i32 [ -22, %if.then6 ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_activate_all(ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %it = alloca %struct.BdrvNextIterator, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7036, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_activate_all) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2 = call ptr @bdrv_first(ptr noundef nonnull %it) #29
  %tobool.not4 = icmp eq ptr %call2, null
  br i1 %tobool.not4, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %do.end, %for.inc
  %bs.05 = phi ptr [ %call7, %for.inc ], [ %call2, %do.end ]
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.05, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  call void @aio_context_acquire(ptr noundef %0) #29
  %call4 = call i32 @bdrv_activate(ptr noundef nonnull %bs.05, ptr noundef %errp), !range !14
  call void @aio_context_release(ptr noundef %0) #29
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then5, label %for.inc

if.then5:                                         ; preds = %bdrv_get_aio_context.exit
  call void @bdrv_next_cleanup(ptr noundef nonnull %it) #29
  br label %glib_autoptr_cleanup_GraphLockableMainloop.exit

for.inc:                                          ; preds = %bdrv_get_aio_context.exit
  %call7 = call ptr @bdrv_next(ptr noundef nonnull %it) #29
  %tobool.not = icmp eq ptr %call7, null
  br i1 %tobool.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %bdrv_get_aio_context.exit, !llvm.loop !81

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %for.inc, %do.end, %if.then5
  call void @bdrv_graph_rdunlock_main_loop() #29
  ret void
}

declare ptr @bdrv_first(ptr noundef) local_unnamed_addr #5

declare void @bdrv_next_cleanup(ptr noundef) local_unnamed_addr #5

declare ptr @bdrv_next(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_inactivate_all() local_unnamed_addr #4 {
entry:
  %it = alloca %struct.BdrvNextIterator, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7142, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_inactivate_all) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2 = call ptr @bdrv_first(ptr noundef nonnull %it) #29
  %tobool.not15 = icmp eq ptr %call2, null
  br i1 %tobool.not15, label %for.end, label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %do.end, %for.inc
  %bs.017 = phi ptr [ %call9, %for.inc ], [ %call2, %do.end ]
  %aio_ctxs.016 = phi ptr [ %aio_ctxs.1, %for.inc ], [ null, %do.end ]
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.017, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  %call4 = call ptr @g_slist_find(ptr noundef %aio_ctxs.016, ptr noundef %0) #29
  %tobool5.not = icmp eq ptr %call4, null
  br i1 %tobool5.not, label %if.then6, label %for.inc

if.then6:                                         ; preds = %bdrv_get_aio_context.exit
  %call7 = call ptr @g_slist_prepend(ptr noundef %aio_ctxs.016, ptr noundef %0) #29
  call void @aio_context_acquire(ptr noundef %0) #29
  br label %for.inc

for.inc:                                          ; preds = %bdrv_get_aio_context.exit, %if.then6
  %aio_ctxs.1 = phi ptr [ %aio_ctxs.016, %bdrv_get_aio_context.exit ], [ %call7, %if.then6 ]
  %call9 = call ptr @bdrv_next(ptr noundef nonnull %it) #29
  %tobool.not = icmp eq ptr %call9, null
  br i1 %tobool.not, label %for.end, label %bdrv_get_aio_context.exit, !llvm.loop !82

for.end:                                          ; preds = %for.inc, %do.end
  %aio_ctxs.0.lcssa = phi ptr [ null, %do.end ], [ %aio_ctxs.1, %for.inc ]
  %call10 = call ptr @bdrv_first(ptr noundef nonnull %it) #29
  %tobool12.not18 = icmp eq ptr %call10, null
  br i1 %tobool12.not18, label %out, label %for.body13

for.body13:                                       ; preds = %for.end, %for.inc20
  %bs.119 = phi ptr [ %call21, %for.inc20 ], [ %call10, %for.end ]
  %call.i13 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i13, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %for.body13
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7057, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_has_bds_parent) #31
  unreachable

do.end.i:                                         ; preds = %for.body13
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.119, i64 0, i32 32
  %parent.04.i = load ptr, ptr %parents.i, align 8
  %tobool.not5.not.i = icmp eq ptr %parent.04.i, null
  br i1 %tobool.not5.not.i, label %if.end16, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %do.end.i
  %klass12.i = getelementptr inbounds %struct.BdrvChild, ptr %parent.04.i, i64 0, i32 2
  %1 = load ptr, ptr %klass12.i, align 8
  %parent_is_bds13.i = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i64 0, i32 1
  %2 = load i8, ptr %parent_is_bds13.i, align 1
  %3 = and i8 %2, 1
  %tobool1.not14.i = icmp eq i8 %3, 0
  br i1 %tobool1.not14.i, label %for.inc.i, label %for.inc20

for.body.i:                                       ; preds = %for.inc.i
  %klass.i = getelementptr inbounds %struct.BdrvChild, ptr %parent.0.i, i64 0, i32 2
  %4 = load ptr, ptr %klass.i, align 8
  %parent_is_bds.i = getelementptr inbounds %struct.BdrvChildClass, ptr %4, i64 0, i32 1
  %5 = load i8, ptr %parent_is_bds.i, align 1
  %6 = and i8 %5, 1
  %tobool1.not.i = icmp eq i8 %6, 0
  br i1 %tobool1.not.i, label %for.inc.i, label %for.inc20, !llvm.loop !83

for.inc.i:                                        ; preds = %for.body.lr.ph.i, %for.body.i
  %parent.0615.i = phi ptr [ %parent.0.i, %for.body.i ], [ %parent.04.i, %for.body.lr.ph.i ]
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %parent.0615.i, i64 0, i32 10
  %parent.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.not.not.i = icmp eq ptr %parent.0.i, null
  br i1 %tobool.not.not.not.i, label %if.end16, label %for.body.i, !llvm.loop !83

if.end16:                                         ; preds = %for.inc.i, %do.end.i
  %call17 = call fastcc i32 @bdrv_inactivate_recurse(ptr noundef nonnull %bs.119), !range !14
  %cmp = icmp slt i32 %call17, 0
  br i1 %cmp, label %if.then18, label %for.inc20

if.then18:                                        ; preds = %if.end16
  call void @bdrv_next_cleanup(ptr noundef nonnull %it) #29
  br label %out

for.inc20:                                        ; preds = %for.body.i, %for.body.lr.ph.i, %if.end16
  %call21 = call ptr @bdrv_next(ptr noundef nonnull %it) #29
  %tobool12.not = icmp eq ptr %call21, null
  br i1 %tobool12.not, label %out, label %for.body13, !llvm.loop !84

out:                                              ; preds = %for.inc20, %for.end, %if.then18
  %ret.2 = phi i32 [ %call17, %if.then18 ], [ 0, %for.end ], [ 0, %for.inc20 ]
  %cmp24.not20 = icmp eq ptr %aio_ctxs.0.lcssa, null
  br i1 %cmp24.not20, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body25

for.body25:                                       ; preds = %out, %for.body25
  %ctx.021 = phi ptr [ %8, %for.body25 ], [ %aio_ctxs.0.lcssa, %out ]
  %7 = load ptr, ptr %ctx.021, align 8
  call void @aio_context_release(ptr noundef %7) #29
  %next = getelementptr inbounds %struct._GSList, ptr %ctx.021, i64 0, i32 1
  %8 = load ptr, ptr %next, align 8
  %cmp24.not = icmp eq ptr %8, null
  br i1 %cmp24.not, label %glib_autoptr_cleanup_GraphLockableMainloop.exit, label %for.body25, !llvm.loop !85

glib_autoptr_cleanup_GraphLockableMainloop.exit:  ; preds = %for.body25, %out
  call void @g_slist_free(ptr noundef %aio_ctxs.0.lcssa) #29
  call void @bdrv_graph_rdunlock_main_loop() #29
  ret i32 %ret.2
}

declare ptr @g_slist_find(ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_inactivate_recurse(ptr noundef %bs) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7077, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_inactivate_recurse) #31
  unreachable

do.end:                                           ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end2

if.end2:                                          ; preds = %do.end
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %if.end2
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7057, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_has_bds_parent) #31
  unreachable

do.end.i:                                         ; preds = %if.end2
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %parent.04.i = load ptr, ptr %parents.i, align 8
  %tobool.not5.not.i = icmp eq ptr %parent.04.i, null
  br i1 %tobool.not5.not.i, label %if.end5, label %for.body.us.i

for.body.us.i:                                    ; preds = %do.end.i, %for.inc.us.i
  %parent.06.us.i = phi ptr [ %parent.0.us.i, %for.inc.us.i ], [ %parent.04.i, %do.end.i ]
  %klass.us.i = getelementptr inbounds %struct.BdrvChild, ptr %parent.06.us.i, i64 0, i32 2
  %1 = load ptr, ptr %klass.us.i, align 8
  %parent_is_bds.us.i = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i64 0, i32 1
  %2 = load i8, ptr %parent_is_bds.us.i, align 1
  %3 = and i8 %2, 1
  %tobool1.not.us.i = icmp eq i8 %3, 0
  br i1 %tobool1.not.us.i, label %for.inc.us.i, label %if.then2.us.i

if.then2.us.i:                                    ; preds = %for.body.us.i
  %opaque.us.i = getelementptr inbounds %struct.BdrvChild, ptr %parent.06.us.i, i64 0, i32 4
  %4 = load ptr, ptr %opaque.us.i, align 8
  %5 = load i32, ptr %4, align 8
  %and.us.i = and i32 %5, 2048
  %tobool4.not.us.i = icmp eq i32 %and.us.i, 0
  br i1 %tobool4.not.us.i, label %return, label %for.inc.us.i

for.inc.us.i:                                     ; preds = %if.then2.us.i, %for.body.us.i
  %next_parent.us.i = getelementptr inbounds %struct.BdrvChild, ptr %parent.06.us.i, i64 0, i32 10
  %parent.0.us.i = load ptr, ptr %next_parent.us.i, align 8
  %tobool.not.us.not.i = icmp eq ptr %parent.0.us.i, null
  br i1 %tobool.not.us.not.i, label %if.end5, label %for.body.us.i, !llvm.loop !83

if.end5:                                          ; preds = %for.inc.us.i, %do.end.i
  %6 = load i32, ptr %bs, align 8
  %and = and i32 %6, 2048
  %tobool6.not = icmp eq i32 %and, 0
  br i1 %tobool6.not, label %if.end9, label %if.else8

if.else8:                                         ; preds = %if.end5
  tail call void @__assert_fail(ptr noundef nonnull @.str.103, ptr noundef nonnull @.str.2, i32 noundef 7089, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_inactivate_recurse) #31
  unreachable

if.end9:                                          ; preds = %if.end5
  %7 = load ptr, ptr %drv, align 8
  %bdrv_inactivate = getelementptr inbounds %struct.BlockDriver, ptr %7, i64 0, i32 34
  %8 = load ptr, ptr %bdrv_inactivate, align 8
  %tobool11.not = icmp eq ptr %8, null
  br i1 %tobool11.not, label %if.end18, label %if.then12

if.then12:                                        ; preds = %if.end9
  %call15 = tail call i32 %8(ptr noundef nonnull %bs) #29
  %cmp = icmp slt i32 %call15, 0
  br i1 %cmp, label %return, label %if.then12.if.end18_crit_edge

if.then12.if.end18_crit_edge:                     ; preds = %if.then12
  %parent.033.pre = load ptr, ptr %parents.i, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then12.if.end18_crit_edge, %if.end9
  %parent.033 = phi ptr [ %parent.033.pre, %if.then12.if.end18_crit_edge ], [ %parent.04.i, %if.end9 ]
  %tobool19.not34 = icmp eq ptr %parent.033, null
  br i1 %tobool19.not34, label %for.end, label %for.body

for.body:                                         ; preds = %if.end18, %for.inc
  %parent.035 = phi ptr [ %parent.0, %for.inc ], [ %parent.033, %if.end18 ]
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %parent.035, i64 0, i32 2
  %9 = load ptr, ptr %klass, align 8
  %inactivate = getelementptr inbounds %struct.BdrvChildClass, ptr %9, i64 0, i32 6
  %10 = load ptr, ptr %inactivate, align 8
  %tobool20.not = icmp eq ptr %10, null
  br i1 %tobool20.not, label %for.inc, label %if.then21

if.then21:                                        ; preds = %for.body
  %call24 = tail call i32 %10(ptr noundef nonnull %parent.035) #29
  %cmp25 = icmp slt i32 %call24, 0
  br i1 %cmp25, label %return, label %for.inc

for.inc:                                          ; preds = %for.body, %if.then21
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %parent.035, i64 0, i32 10
  %parent.0 = load ptr, ptr %next_parent, align 8
  %tobool19.not = icmp eq ptr %parent.0, null
  br i1 %tobool19.not, label %for.end, label %for.body, !llvm.loop !86

for.end:                                          ; preds = %for.inc, %if.end18
  %call.i23 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i23, label %do.end.i25, label %if.else.i24

if.else.i24:                                      ; preds = %for.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2620, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #31
  unreachable

do.end.i25:                                       ; preds = %for.end
  %c.06.i = load ptr, ptr %parents.i, align 8
  %tobool.not7.i = icmp eq ptr %c.06.i, null
  br i1 %tobool.not7.i, label %if.end32, label %for.body.i

for.body.i:                                       ; preds = %do.end.i25, %for.body.i
  %c.010.i = phi ptr [ %c.0.i, %for.body.i ], [ %c.06.i, %do.end.i25 ]
  %cumulative_perms.08.i = phi i64 [ %or.i, %for.body.i ], [ 0, %do.end.i25 ]
  %perm1.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 5
  %11 = load i64, ptr %perm1.i, align 8
  %or.i = or i64 %11, %cumulative_perms.08.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i, i64 0, i32 10
  %c.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool.not.i, label %bdrv_get_cumulative_perm.exit, label %for.body.i, !llvm.loop !22

bdrv_get_cumulative_perm.exit:                    ; preds = %for.body.i
  %and29 = and i64 %or.i, 6
  %tobool30.not = icmp eq i64 %and29, 0
  br i1 %tobool30.not, label %if.end32, label %return

if.end32:                                         ; preds = %do.end.i25, %bdrv_get_cumulative_perm.exit
  %12 = load i32, ptr %bs, align 8
  %or = or i32 %12, 2048
  store i32 %or, ptr %bs, align 8
  %call34 = tail call fastcc i32 @bdrv_refresh_perms(ptr noundef nonnull %bs, ptr noundef null, ptr noundef null), !range !14
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.036 = load ptr, ptr %children, align 8
  %tobool37.not37 = icmp eq ptr %child.036, null
  br i1 %tobool37.not37, label %return, label %for.body38

for.cond36:                                       ; preds = %for.body38
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.038, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool37.not = icmp eq ptr %child.0, null
  br i1 %tobool37.not, label %return, label %for.body38, !llvm.loop !87

for.body38:                                       ; preds = %if.end32, %for.cond36
  %child.038 = phi ptr [ %child.0, %for.cond36 ], [ %child.036, %if.end32 ]
  %13 = load ptr, ptr %child.038, align 8
  %call40 = tail call fastcc i32 @bdrv_inactivate_recurse(ptr noundef %13), !range !14
  %cmp41 = icmp slt i32 %call40, 0
  br i1 %cmp41, label %return, label %for.cond36

return:                                           ; preds = %if.then2.us.i, %if.then21, %for.body38, %for.cond36, %if.end32, %bdrv_get_cumulative_perm.exit, %if.then12, %do.end
  %retval.0 = phi i32 [ -123, %do.end ], [ %call15, %if.then12 ], [ -1, %bdrv_get_cumulative_perm.exit ], [ 0, %if.end32 ], [ %call40, %for.body38 ], [ 0, %for.cond36 ], [ %call24, %if.then21 ], [ 0, %if.then2.us.i ]
  ret i32 %retval.0
}

declare void @g_slist_free(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_co_is_inserted(ptr noundef %bs) #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %bdrv_co_is_inserted = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 101
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_is_inserted, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 754, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %3 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_is_inserted, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 754, ptr null)
  %4 = load ptr, ptr %3, align 8
  %call = tail call zeroext i1 %4(ptr noundef nonnull %bs) #29
  br label %return

if.end5:                                          ; preds = %if.end
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.07 = load ptr, ptr %children, align 8
  %tobool6.not8 = icmp eq ptr %child.07, null
  br i1 %tobool6.not8, label %return, label %for.body

for.cond:                                         ; preds = %for.body
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.09, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool6.not = icmp eq ptr %child.0, null
  br i1 %tobool6.not, label %return, label %for.body, !llvm.loop !88

for.body:                                         ; preds = %if.end5, %for.cond
  %child.09 = phi ptr [ %child.0, %for.cond ], [ %child.07, %if.end5 ]
  %5 = load ptr, ptr %child.09, align 8
  %call8 = tail call zeroext i1 @bdrv_co_is_inserted(ptr noundef %5)
  br i1 %call8, label %for.cond, label %return

return:                                           ; preds = %for.body, %for.cond, %if.end5, %entry, %if.then3
  %retval.0 = phi i1 [ %call, %if.then3 ], [ false, %entry ], [ true, %if.end5 ], [ %call8, %for.cond ], [ %call8, %for.body ]
  ret i1 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_eject(ptr noundef %bs, i1 noundef zeroext %eject_flag) #4 {
entry:
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %bdrv_co_eject = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 102
  %1 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_eject, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 756, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_eject, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 756, ptr null)
  %4 = load ptr, ptr %3, align 8
  tail call void %4(ptr noundef nonnull %bs, i1 noundef zeroext %eject_flag) #29
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_lock_medium(ptr noundef %bs, i1 noundef zeroext %locked) #4 {
entry:
  %_now.i.i = alloca %struct.timeval, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  tail call void @assert_bdrv_graph_readable() #29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %_now.i.i)
  %1 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool.i.i = icmp ne i32 %1, 0
  %2 = load i16, ptr @_TRACE_BDRV_LOCK_MEDIUM_DSTATE, align 2
  %tobool4.i.i = icmp ne i16 %2, 0
  %or.cond.i.i = select i1 %tobool.i.i, i1 %tobool4.i.i, i1 false
  br i1 %or.cond.i.i, label %land.lhs.true5.i.i, label %trace_bdrv_lock_medium.exit

land.lhs.true5.i.i:                               ; preds = %entry
  %3 = load i32, ptr @qemu_loglevel, align 4
  %and.i.i.i = and i32 %3, 32768
  %cmp.i.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %cmp.i.not.i.i, label %trace_bdrv_lock_medium.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true5.i.i
  %4 = load i8, ptr @message_with_timestamp, align 1
  %5 = and i8 %4, 1
  %tobool7.not.i.i = icmp eq i8 %5, 0
  br i1 %tobool7.not.i.i, label %if.else.i.i, label %if.then8.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  %call9.i.i = call i32 @gettimeofday(ptr noundef nonnull %_now.i.i, ptr noundef null) #29
  %call10.i.i = tail call i32 @qemu_get_thread_id() #29
  %6 = load i64, ptr %_now.i.i, align 8
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %_now.i.i, i64 0, i32 1
  %7 = load i64, ptr %tv_usec.i.i, align 8
  %conv12.i.i = zext i1 %locked to i32
  tail call void (ptr, ...) @qemu_log(ptr noundef nonnull @.str.282, i32 noundef %call10.i.i, i64 noundef %6, i64 noundef %7, ptr noundef nonnull %bs, i32 noundef %conv12.i.i) #29
  br label %trace_bdrv_lock_medium.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %conv14.i.i = zext i1 %locked to i32
  tail call void (ptr, ...) @qemu_log(ptr noundef nonnull @.str.283, ptr noundef nonnull %bs, i32 noundef %conv14.i.i) #29
  br label %trace_bdrv_lock_medium.exit

trace_bdrv_lock_medium.exit:                      ; preds = %entry, %land.lhs.true5.i.i, %if.then8.i.i, %if.else.i.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %_now.i.i)
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %trace_bdrv_lock_medium.exit
  %bdrv_co_lock_medium = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 103
  %8 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_lock_medium, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 758, ptr null)
  %9 = load ptr, ptr %8, align 8
  %tobool3.not = icmp eq ptr %9, null
  br i1 %tobool3.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %10 = tail call ptr @llvm.ptr.annotation.p0.p0(ptr nonnull %bdrv_co_lock_medium, ptr nonnull @.str.13, ptr nonnull @.str.14, i32 758, ptr null)
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr noundef nonnull %bs, i1 noundef zeroext %locked) #29
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %trace_bdrv_lock_medium.exit
  ret void
}

declare void @aio_bh_schedule_oneshot_full(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_schedule_unref_bh(ptr noundef %opaque) #4 {
entry:
  %tobool.not.i = icmp eq ptr %opaque, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %opaque, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  tail call void @bdrv_unref(ptr noundef %opaque)
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_op_is_blocked(ptr noundef %bs, i32 noundef %op, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7291, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_is_blocked) #31
  unreachable

do.end:                                           ; preds = %entry
  %cmp1 = icmp ult i32 %op, 16
  br i1 %cmp1, label %if.end4, label %if.else3

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.106, ptr noundef nonnull @.str.2, i32 noundef 7293, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_is_blocked) #31
  unreachable

if.end4:                                          ; preds = %do.end
  %idxprom = zext nneg i32 %op to i64
  %arrayidx = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %idxprom
  %0 = load ptr, ptr %arrayidx, align 8
  %cmp5 = icmp ne ptr %0, null
  br i1 %cmp5, label %if.then6, label %return

if.then6:                                         ; preds = %if.end4
  %1 = load ptr, ptr %0, align 8
  %call11 = tail call ptr @error_copy(ptr noundef %1) #29
  %parents.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.07.i.i = load ptr, ptr %parents.i.i, align 8
  %tobool.not8.i.i = icmp eq ptr %c.07.i.i, null
  br i1 %tobool.not8.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %if.then6, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %c.07.i.i, %if.then6 ]
  %klass.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 2
  %2 = load ptr, ptr %klass.i.i, align 8
  %get_name.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %2, i64 0, i32 15
  %3 = load ptr, ptr %get_name.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %call.i.i = tail call ptr %3(ptr noundef nonnull %c.09.i.i) #29
  %tobool4.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool4.not.i.i, label %for.inc.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.then.i.i
  %4 = load i8, ptr %call.i.i, align 1
  %tobool5.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool5.not.i.i, label %for.inc.i.i, label %bdrv_get_device_or_node_name.exit

for.inc.i.i:                                      ; preds = %land.lhs.true.i.i, %if.then.i.i, %for.body.i.i
  %next_parent.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 10
  %c.0.i.i = load ptr, ptr %next_parent.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i, !llvm.loop !5

bdrv_get_device_or_node_name.exit:                ; preds = %land.lhs.true.i.i, %for.inc.i.i, %if.then6
  %retval.0.i.i = phi ptr [ null, %if.then6 ], [ null, %for.inc.i.i ], [ %call.i.i, %land.lhs.true.i.i ]
  %tobool.not.i = icmp eq ptr %retval.0.i.i, null
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 22
  %cond.i = select i1 %tobool.not.i, ptr %node_name.i, ptr %retval.0.i.i
  tail call void (ptr, ptr, ptr, ...) @error_propagate_prepend(ptr noundef %errp, ptr noundef %call11, ptr noundef nonnull @.str.107, ptr noundef nonnull %cond.i) #29
  br label %return

return:                                           ; preds = %if.end4, %bdrv_get_device_or_node_name.exit
  ret i1 %cmp5
}

declare void @error_propagate_prepend(ptr noundef, ptr noundef, ptr noundef, ...) local_unnamed_addr #5

declare ptr @error_copy(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_block(ptr noundef %bs, i32 noundef %op, ptr noundef %reason) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7307, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_block) #31
  unreachable

do.end:                                           ; preds = %entry
  %cmp1 = icmp ult i32 %op, 16
  br i1 %cmp1, label %if.end4, label %if.else3

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.106, ptr noundef nonnull @.str.2, i32 noundef 7308, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_block) #31
  unreachable

if.end4:                                          ; preds = %do.end
  %call5 = tail call noalias dereferenceable_or_null(24) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #32
  store ptr %reason, ptr %call5, align 8
  %idxprom = zext nneg i32 %op to i64
  %arrayidx = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %idxprom
  %0 = load ptr, ptr %arrayidx, align 8
  %list = getelementptr inbounds %struct.BdrvOpBlocker, ptr %call5, i64 0, i32 1
  store ptr %0, ptr %list, align 8
  %cmp8.not = icmp eq ptr %0, null
  br i1 %cmp8.not, label %if.end17, label %if.then9

if.then9:                                         ; preds = %if.end4
  %le_prev = getelementptr inbounds %struct.BdrvOpBlocker, ptr %0, i64 0, i32 1, i32 1
  store ptr %list, ptr %le_prev, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then9, %if.end4
  store ptr %call5, ptr %arrayidx, align 8
  %le_prev27 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %call5, i64 0, i32 1, i32 1
  store ptr %arrayidx, ptr %le_prev27, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_unblock(ptr nocapture noundef readonly %bs, i32 noundef %op, ptr noundef readnone %reason) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7318, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

do.end:                                           ; preds = %entry
  %cmp1 = icmp ult i32 %op, 16
  br i1 %cmp1, label %if.end4, label %if.else3

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.106, ptr noundef nonnull @.str.2, i32 noundef 7319, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

if.end4:                                          ; preds = %do.end
  %idxprom = zext nneg i32 %op to i64
  %arrayidx = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %idxprom
  %0 = load ptr, ptr %arrayidx, align 8
  %tobool.not13 = icmp eq ptr %0, null
  br i1 %tobool.not13, label %for.end, label %land.rhs

land.rhs:                                         ; preds = %if.end4, %for.inc
  %blocker.014 = phi ptr [ %1, %for.inc ], [ %0, %if.end4 ]
  %list = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014, i64 0, i32 1
  %1 = load ptr, ptr %list, align 8
  %2 = load ptr, ptr %blocker.014, align 8
  %cmp6 = icmp eq ptr %2, %reason
  br i1 %cmp6, label %do.body8, label %for.inc

do.body8:                                         ; preds = %land.rhs
  %cmp11.not = icmp eq ptr %1, null
  %le_prev22.phi.trans.insert = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014, i64 0, i32 1, i32 1
  %.pre15 = load ptr, ptr %le_prev22.phi.trans.insert, align 8
  br i1 %cmp11.not, label %if.end18, label %if.then12

if.then12:                                        ; preds = %do.body8
  %le_prev17 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %1, i64 0, i32 1, i32 1
  store ptr %.pre15, ptr %le_prev17, align 8
  %.pre = load ptr, ptr %list, align 8
  br label %if.end18

if.end18:                                         ; preds = %do.body8, %if.then12
  %3 = phi ptr [ %.pre, %if.then12 ], [ null, %do.body8 ]
  store ptr %3, ptr %.pre15, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %blocker.014) #29
  br label %for.inc

for.inc:                                          ; preds = %land.rhs, %if.end18
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %for.end, label %land.rhs, !llvm.loop !13

for.end:                                          ; preds = %for.inc, %if.end4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_block_all(ptr noundef %bs, ptr noundef %reason) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.body, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7331, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_block_all) #31
  unreachable

for.body:                                         ; preds = %entry, %bdrv_op_block.exit
  %indvars.iv = phi i64 [ %indvars.iv.next, %bdrv_op_block.exit ], [ 0, %entry ]
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %if.end4.i, label %if.else.i

if.else.i:                                        ; preds = %for.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7307, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_block) #31
  unreachable

if.end4.i:                                        ; preds = %for.body
  %call5.i = tail call noalias dereferenceable_or_null(24) ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #32
  store ptr %reason, ptr %call5.i, align 8
  %arrayidx.i = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %indvars.iv
  %0 = load ptr, ptr %arrayidx.i, align 8
  %list.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %call5.i, i64 0, i32 1
  store ptr %0, ptr %list.i, align 8
  %cmp8.not.i = icmp eq ptr %0, null
  br i1 %cmp8.not.i, label %bdrv_op_block.exit, label %if.then9.i

if.then9.i:                                       ; preds = %if.end4.i
  %le_prev.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %0, i64 0, i32 1, i32 1
  store ptr %list.i, ptr %le_prev.i, align 8
  br label %bdrv_op_block.exit

bdrv_op_block.exit:                               ; preds = %if.end4.i, %if.then9.i
  store ptr %call5.i, ptr %arrayidx.i, align 8
  %le_prev27.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %call5.i, i64 0, i32 1, i32 1
  store ptr %arrayidx.i, ptr %le_prev27.i, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !12

for.end:                                          ; preds = %bdrv_op_block.exit
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_unblock_all(ptr nocapture noundef readonly %bs, ptr noundef readnone %reason) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.body, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7340, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock_all) #31
  unreachable

for.body:                                         ; preds = %entry, %bdrv_op_unblock.exit
  %indvars.iv = phi i64 [ %indvars.iv.next, %bdrv_op_unblock.exit ], [ 0, %entry ]
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %if.end4.i, label %if.else.i

if.else.i:                                        ; preds = %for.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7318, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_unblock) #31
  unreachable

if.end4.i:                                        ; preds = %for.body
  %arrayidx.i = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %indvars.iv
  %0 = load ptr, ptr %arrayidx.i, align 8
  %tobool.not13.i = icmp eq ptr %0, null
  br i1 %tobool.not13.i, label %bdrv_op_unblock.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.end4.i, %for.inc.i
  %blocker.014.i = phi ptr [ %1, %for.inc.i ], [ %0, %if.end4.i ]
  %list.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i, i64 0, i32 1
  %1 = load ptr, ptr %list.i, align 8
  %2 = load ptr, ptr %blocker.014.i, align 8
  %cmp6.i = icmp eq ptr %2, %reason
  br i1 %cmp6.i, label %do.body8.i, label %for.inc.i

do.body8.i:                                       ; preds = %land.rhs.i
  %cmp11.not.i = icmp eq ptr %1, null
  %le_prev22.phi.trans.insert.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %blocker.014.i, i64 0, i32 1, i32 1
  %.pre15.i = load ptr, ptr %le_prev22.phi.trans.insert.i, align 8
  br i1 %cmp11.not.i, label %if.end18.i, label %if.then12.i

if.then12.i:                                      ; preds = %do.body8.i
  %le_prev17.i = getelementptr inbounds %struct.BdrvOpBlocker, ptr %1, i64 0, i32 1, i32 1
  store ptr %.pre15.i, ptr %le_prev17.i, align 8
  %.pre.i = load ptr, ptr %list.i, align 8
  br label %if.end18.i

if.end18.i:                                       ; preds = %if.then12.i, %do.body8.i
  %3 = phi ptr [ %.pre.i, %if.then12.i ], [ null, %do.body8.i ]
  store ptr %3, ptr %.pre15.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %blocker.014.i) #29
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end18.i, %land.rhs.i
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %bdrv_op_unblock.exit, label %land.rhs.i, !llvm.loop !13

bdrv_op_unblock.exit:                             ; preds = %for.inc.i, %if.end4.i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !89

for.end:                                          ; preds = %bdrv_op_unblock.exit
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_op_blocker_is_empty(ptr nocapture noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.body.preheader, label %if.else

for.body.preheader:                               ; preds = %entry
  %arrayidx5 = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 0
  %0 = load ptr, ptr %arrayidx5, align 8
  %cmp16 = icmp eq ptr %0, null
  br i1 %cmp16, label %for.cond, label %return

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7349, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_blocker_is_empty) #31
  unreachable

for.cond:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv7 = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv7, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 16
  br i1 %exitcond, label %return.loopexit, label %for.body, !llvm.loop !19

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr %struct.BlockDriverState, ptr %bs, i64 0, i32 27, i64 %indvars.iv.next
  %1 = load ptr, ptr %arrayidx, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %for.cond, label %return.loopexit, !llvm.loop !19

return.loopexit:                                  ; preds = %for.cond, %for.body
  %cmp.le = icmp ugt i64 %indvars.iv7, 14
  br label %return

return:                                           ; preds = %return.loopexit, %for.body.preheader
  %cmp.lcssa = phi i1 [ false, %for.body.preheader ], [ %cmp.le, %return.loopexit ]
  ret i1 %cmp.lcssa
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_img_create(ptr noundef %filename, ptr noundef %fmt, ptr noundef %base_filename, ptr noundef %base_fmt, ptr noundef %options, i64 noundef %img_size, i32 noundef %flags, i1 noundef zeroext %quiet, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7375, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_img_create) #31
  unreachable

do.end:                                           ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_format) #31
  unreachable

do.end.i:                                         ; preds = %do.end
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %for.cond.preheader.i.i, label %if.else.i.i

for.cond.preheader.i.i:                           ; preds = %do.end.i
  %drv1.04.i.i = load ptr, ptr @bdrv_drivers, align 8
  %tobool.not5.i.i = icmp eq ptr %drv1.04.i.i, null
  br i1 %tobool.not5.i.i, label %if.then2, label %for.body.i.i

if.else.i.i:                                      ; preds = %do.end.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 444, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_find_format) #31
  unreachable

for.body.i.i:                                     ; preds = %for.cond.preheader.i.i, %for.inc.i.i
  %drv1.06.i.i = phi ptr [ %drv1.0.i.i, %for.inc.i.i ], [ %drv1.04.i.i, %for.cond.preheader.i.i ]
  %0 = load ptr, ptr %drv1.06.i.i, align 8
  %call2.i.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull dereferenceable(1) %fmt) #28
  %tobool3.not.i.i = icmp eq i32 %call2.i.i, 0
  br i1 %tobool3.not.i.i, label %if.end3, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %list.i.i = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i, i64 0, i32 61
  %drv1.0.i.i = load ptr, ptr %list.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %drv1.0.i.i, null
  br i1 %tobool.not.i.i, label %if.then2, label %for.body.i.i, !llvm.loop !8

if.then2:                                         ; preds = %for.inc.i.i, %for.cond.preheader.i.i
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7380, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.108, ptr noundef %fmt) #29
  br label %return

if.end3:                                          ; preds = %for.body.i.i
  %call4 = tail call ptr @bdrv_find_protocol(ptr noundef %filename, i1 noundef zeroext true, ptr noundef %errp)
  %tobool5.not = icmp eq ptr %call4, null
  br i1 %tobool5.not, label %return, label %if.end7

if.end7:                                          ; preds = %if.end3
  %create_opts8 = getelementptr inbounds %struct.BlockDriver, ptr %drv1.06.i.i, i64 0, i32 9
  %1 = load ptr, ptr %create_opts8, align 8
  %tobool9.not = icmp eq ptr %1, null
  br i1 %tobool9.not, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %2 = load ptr, ptr %drv1.06.i.i, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7391, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.109, ptr noundef %2) #29
  br label %return

if.end11:                                         ; preds = %if.end7
  %create_opts12 = getelementptr inbounds %struct.BlockDriver, ptr %call4, i64 0, i32 9
  %3 = load ptr, ptr %create_opts12, align 8
  %tobool13.not = icmp eq ptr %3, null
  br i1 %tobool13.not, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %4 = load ptr, ptr %call4, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7397, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.110, ptr noundef %4) #29
  br label %return

if.end16:                                         ; preds = %if.end11
  %call17 = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_context_acquire(ptr noundef %call17) #29
  %5 = load ptr, ptr %create_opts8, align 8
  %call19 = tail call ptr @qemu_opts_append(ptr noundef null, ptr noundef %5) #29
  %6 = load ptr, ptr %create_opts12, align 8
  %call21 = tail call ptr @qemu_opts_append(ptr noundef %call19, ptr noundef %6) #29
  %call22 = tail call ptr @qemu_opts_create(ptr noundef %call21, ptr noundef null, i32 noundef 0, ptr noundef nonnull @error_abort) #29
  %tobool23.not = icmp eq ptr %options, null
  br i1 %tobool23.not, label %if.end28, label %if.then24

if.then24:                                        ; preds = %if.end16
  %call25 = tail call zeroext i1 @qemu_opts_do_parse(ptr noundef %call22, ptr noundef nonnull %options, ptr noundef null, ptr noundef %errp) #29
  br i1 %call25, label %if.end28, label %out

if.end28:                                         ; preds = %if.then24, %if.end16
  %call29 = tail call ptr @qemu_opt_get(ptr noundef %call22, ptr noundef nonnull @.str.17) #29
  %tobool30.not = icmp eq ptr %call29, null
  br i1 %tobool30.not, label %if.then31, label %if.else33

if.then31:                                        ; preds = %if.end28
  %call32 = tail call zeroext i1 @qemu_opt_set_number(ptr noundef %call22, ptr noundef nonnull @.str.17, i64 noundef %img_size, ptr noundef nonnull @error_abort) #29
  br label %if.end36

if.else33:                                        ; preds = %if.end28
  %cmp.not = icmp eq i64 %img_size, -1
  br i1 %cmp.not, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.else33
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7419, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.111) #29
  br label %out

if.end36:                                         ; preds = %if.else33, %if.then31
  %tobool37.not = icmp eq ptr %base_filename, null
  br i1 %tobool37.not, label %if.end42, label %if.then38

if.then38:                                        ; preds = %if.end36
  %call39 = tail call zeroext i1 @qemu_opt_set(ptr noundef %call22, ptr noundef nonnull @.str.112, ptr noundef nonnull %base_filename, ptr noundef null) #29
  br i1 %call39, label %if.end42, label %if.then40

if.then40:                                        ; preds = %if.then38
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7427, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.113, ptr noundef %fmt) #29
  br label %out

if.end42:                                         ; preds = %if.then38, %if.end36
  %tobool43.not = icmp eq ptr %base_fmt, null
  br i1 %tobool43.not, label %if.end48, label %if.then44

if.then44:                                        ; preds = %if.end42
  %call45 = tail call zeroext i1 @qemu_opt_set(ptr noundef %call22, ptr noundef nonnull @.str.114, ptr noundef nonnull %base_fmt, ptr noundef null) #29
  br i1 %call45, label %if.end48, label %if.then46

if.then46:                                        ; preds = %if.then44
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7435, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.115, ptr noundef %fmt) #29
  br label %out

if.end48:                                         ; preds = %if.then44, %if.end42
  %call49 = tail call ptr @qemu_opt_get(ptr noundef %call22, ptr noundef nonnull @.str.112) #29
  %tobool50.not = icmp eq ptr %call49, null
  br i1 %tobool50.not, label %if.end60, label %if.then51

if.then51:                                        ; preds = %if.end48
  %call52 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %filename, ptr noundef nonnull dereferenceable(1) %call49) #28
  %tobool53.not = icmp eq i32 %call52, 0
  br i1 %tobool53.not, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.then51
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7444, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.116) #29
  br label %out

if.end55:                                         ; preds = %if.then51
  %7 = load i8, ptr %call49, align 1
  %cmp56 = icmp eq i8 %7, 0
  br i1 %cmp56, label %if.then58, label %if.end60

if.then58:                                        ; preds = %if.end55
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7448, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.117) #29
  br label %out

if.end60:                                         ; preds = %if.end55, %if.end48
  %call61 = tail call ptr @qemu_opt_get(ptr noundef %call22, ptr noundef nonnull @.str.114) #29
  %call62 = tail call i64 @qemu_opt_get_size(ptr noundef %call22, ptr noundef nonnull @.str.17, i64 noundef %img_size) #29
  %and = and i32 %flags, 256
  %tobool64.not = icmp ne i32 %and, 0
  %or.cond74.not = or i1 %tobool64.not, %tobool50.not
  br i1 %or.cond74.not, label %if.else100, label %if.then65

if.then65:                                        ; preds = %if.end60
  %call66 = call ptr @bdrv_get_full_backing_filename_from_filename(ptr noundef %filename, ptr noundef nonnull %call49, ptr noundef nonnull %local_err)
  %8 = load ptr, ptr %local_err, align 8
  %tobool67.not = icmp eq ptr %8, null
  br i1 %tobool67.not, label %if.end69, label %out

if.end69:                                         ; preds = %if.then65
  %tobool70.not = icmp eq ptr %call66, null
  br i1 %tobool70.not, label %if.else72, label %if.end73

if.else72:                                        ; preds = %if.end69
  call void @__assert_fail(ptr noundef nonnull @.str.118, ptr noundef nonnull @.str.2, i32 noundef 7470, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_img_create) #31
  unreachable

if.end73:                                         ; preds = %if.end69
  %and74 = and i32 %flags, -65803
  %or = or disjoint i32 %and74, 65536
  %call75 = call ptr @qdict_new() #29
  %tobool76.not = icmp eq ptr %call61, null
  br i1 %tobool76.not, label %if.end78, label %if.then77

if.then77:                                        ; preds = %if.end73
  call void @qdict_put_str(ptr noundef %call75, ptr noundef nonnull @.str.20, ptr noundef nonnull %call61) #29
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end73
  call void @qdict_put_bool(ptr noundef %call75, ptr noundef nonnull @.str.59, i1 noundef zeroext true) #29
  %call79 = call ptr @bdrv_open(ptr noundef nonnull %call66, ptr noundef null, ptr noundef %call75, i32 noundef %or, ptr noundef nonnull %local_err)
  call void @g_free(ptr noundef nonnull %call66) #29
  %tobool80.not = icmp eq ptr %call79, null
  br i1 %tobool80.not, label %if.then81, label %if.else82

if.then81:                                        ; preds = %if.end78
  call void (ptr, ptr, ...) @error_append_hint(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.119) #29
  br label %out

if.else82:                                        ; preds = %if.end78
  br i1 %tobool76.not, label %if.then84, label %if.end87

if.then84:                                        ; preds = %if.else82
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 7495, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.120) #29
  %drv85 = getelementptr inbounds %struct.BlockDriverState, ptr %call79, i64 0, i32 6
  %9 = load ptr, ptr %drv85, align 8
  %10 = load ptr, ptr %9, align 8
  call void (ptr, ptr, ...) @error_append_hint(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.121, ptr noundef %10) #29
  br label %out

if.end87:                                         ; preds = %if.else82
  %cmp88 = icmp eq i64 %call62, -1
  br i1 %cmp88, label %if.then90, label %if.end106.thread

if.then90:                                        ; preds = %if.end87
  %call91 = call i64 @bdrv_getlength(ptr noundef nonnull %call79) #29
  %cmp92 = icmp slt i64 %call91, 0
  br i1 %cmp92, label %if.then94, label %if.end96

if.then94:                                        ; preds = %if.then90
  %11 = trunc i64 %call91 to i32
  %conv95 = sub i32 0, %11
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7505, ptr noundef nonnull @__func__.bdrv_img_create, i32 noundef %conv95, ptr noundef nonnull @.str.122, ptr noundef nonnull %call49) #29
  call void @bdrv_unref(ptr noundef nonnull %call79)
  br label %out

if.end96:                                         ; preds = %if.then90
  %call97 = call zeroext i1 @qemu_opt_set_number(ptr noundef %call22, ptr noundef nonnull @.str.17, i64 noundef %call91, ptr noundef nonnull @error_abort) #29
  br label %if.end106.thread

if.end106.thread:                                 ; preds = %if.end87, %if.end96
  call void @bdrv_unref(ptr noundef nonnull %call79)
  br label %if.end110

if.else100:                                       ; preds = %if.end60
  %tobool103 = icmp ne ptr %call61, null
  %or.cond = select i1 %tobool50.not, i1 true, i1 %tobool103
  br i1 %or.cond, label %if.end106, label %if.then104

if.then104:                                       ; preds = %if.else100
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef nonnull %local_err, ptr noundef nonnull @.str.2, i32 noundef 7516, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.120) #29
  br label %out

if.end106:                                        ; preds = %if.else100
  %cmp107 = icmp eq i64 %call62, -1
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.end106
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7521, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.123) #29
  br label %out

if.end110:                                        ; preds = %if.end106.thread, %if.end106
  br i1 %quiet, label %if.end116, label %if.then112

if.then112:                                       ; preds = %if.end110
  %call113 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.124, ptr noundef %filename, ptr noundef %fmt)
  call void @qemu_opts_print(ptr noundef %call22, ptr noundef nonnull @.str.125) #29
  %putchar = call i32 @putchar(i32 10)
  %12 = load ptr, ptr @stdout, align 8
  %call115 = call i32 @fflush(ptr noundef %12)
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.end110
  %call117 = call i32 @bdrv_create(ptr noundef nonnull %drv1.06.i.i, ptr noundef %filename, ptr noundef %call22, ptr noundef nonnull %local_err) #29
  %cmp118 = icmp eq i32 %call117, -27
  br i1 %cmp118, label %if.then120, label %out

if.then120:                                       ; preds = %if.end116
  %call121 = call i64 @qemu_opt_get_size(ptr noundef %call22, ptr noundef nonnull @.str.126, i64 noundef 0) #29
  %tobool122.not = icmp eq i64 %call121, 0
  %spec.select = select i1 %tobool122.not, ptr @.str.95, ptr @.str.127
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7543, ptr noundef nonnull @__func__.bdrv_img_create, ptr noundef nonnull @.str.128, ptr noundef %fmt, ptr noundef nonnull %spec.select) #29
  %13 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %13) #29
  store ptr null, ptr %local_err, align 8
  br label %out

out:                                              ; preds = %if.end116, %if.then120, %if.then65, %if.then24, %if.then109, %if.then104, %if.then94, %if.then84, %if.then81, %if.then58, %if.then54, %if.then46, %if.then40, %if.then34
  call void @qemu_opts_del(ptr noundef %call22) #29
  call void @qemu_opts_free(ptr noundef %call21) #29
  %14 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %errp, ptr noundef %14) #29
  %call126 = call ptr @qemu_get_aio_context() #29
  call void @aio_context_release(ptr noundef %call126) #29
  br label %return

return:                                           ; preds = %if.end3, %out, %if.then14, %if.then10, %if.then2
  ret void
}

declare ptr @qemu_opts_append(ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qemu_opts_create(ptr noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #5

declare zeroext i1 @qemu_opts_do_parse(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qemu_opt_get(ptr noundef, ptr noundef) local_unnamed_addr #5

declare zeroext i1 @qemu_opt_set_number(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #5

declare zeroext i1 @qemu_opt_set(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare i64 @qemu_opt_get_size(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #5

declare void @error_append_hint(ptr noundef, ptr noundef, ...) local_unnamed_addr #5

declare i64 @bdrv_getlength(ptr noundef) #5

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #21

declare void @qemu_opts_print(ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nofree nounwind
declare noundef i32 @fflush(ptr nocapture noundef) local_unnamed_addr #21

declare i32 @bdrv_create(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #5

declare void @qemu_opts_free(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_co_enter(ptr noundef %bs) #4 {
entry:
  %call = tail call ptr @qemu_coroutine_self() #29
  %call1 = tail call ptr @qemu_coroutine_get_aio_context(ptr noundef %call) #29
  tail call void @bdrv_inc_in_flight(ptr noundef %bs) #29
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  tail call void @aio_co_reschedule_self(ptr noundef %cond.i) #29
  ret ptr %call1
}

declare ptr @qemu_coroutine_self() local_unnamed_addr #5

declare ptr @qemu_coroutine_get_aio_context(ptr noundef) local_unnamed_addr #5

declare void @bdrv_inc_in_flight(ptr noundef) local_unnamed_addr #5

declare void @aio_co_reschedule_self(ptr noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_leave(ptr noundef %bs, ptr noundef %old_ctx) #4 {
entry:
  tail call void @aio_co_reschedule_self(ptr noundef %old_ctx) #29
  tail call void @bdrv_dec_in_flight(ptr noundef %bs) #29
  ret void
}

declare void @bdrv_dec_in_flight(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_lock(ptr noundef readonly %bs) #4 {
entry:
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call1 = tail call ptr @qemu_get_current_aio_context() #29
  %call2 = tail call ptr @qemu_get_aio_context() #29
  %cmp = icmp eq ptr %call1, %call2
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.82, ptr noundef nonnull @.str.2, i32 noundef 7591, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_lock) #31
  unreachable

if.end:                                           ; preds = %bdrv_get_aio_context.exit
  %call3 = tail call zeroext i1 @qemu_in_coroutine() #29
  br i1 %call3, label %if.end6, label %if.else5

if.else5:                                         ; preds = %if.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.129, ptr noundef nonnull @.str.2, i32 noundef 7597, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_lock) #31
  unreachable

if.end6:                                          ; preds = %if.end
  %call7 = tail call ptr @qemu_get_aio_context() #29
  %cmp8.not = icmp eq ptr %cond.i, %call7
  br i1 %cmp8.not, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end6
  ret void
}

declare zeroext i1 @qemu_in_coroutine() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_unlock(ptr noundef readonly %bs) #4 {
entry:
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call1 = tail call zeroext i1 @qemu_in_coroutine() #29
  br i1 %call1, label %if.end, label %if.else

if.else:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.129, ptr noundef nonnull @.str.2, i32 noundef 7607, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_co_unlock) #31
  unreachable

if.end:                                           ; preds = %bdrv_get_aio_context.exit
  %call2 = tail call ptr @qemu_get_aio_context() #29
  %cmp.not = icmp eq ptr %cond.i, %call2
  br i1 %cmp.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_child_change_aio_context(ptr noundef %c, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7707, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_change_aio_context) #31
  unreachable

do.end:                                           ; preds = %entry
  %call1 = tail call i32 @g_hash_table_contains(ptr noundef %visited, ptr noundef %c) #29
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.end3, label %return

if.end3:                                          ; preds = %do.end
  %call4 = tail call i32 @g_hash_table_add(ptr noundef %visited, ptr noundef %c) #29
  %0 = load ptr, ptr %c, align 8
  %call5 = tail call fastcc zeroext i1 @bdrv_change_aio_context(ptr noundef %0, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp)
  br label %return

return:                                           ; preds = %do.end, %if.end3
  %retval.0 = phi i1 [ %call5, %if.end3 ], [ true, %do.end ]
  ret i1 %retval.0
}

declare i32 @g_hash_table_contains(ptr noundef, ptr noundef) local_unnamed_addr #5

declare i32 @g_hash_table_add(ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i1 @bdrv_change_aio_context(ptr noundef %bs, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7774, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_change_aio_context) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %do.end
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %do.end
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %cmp = icmp eq ptr %cond.i, %ctx
  br i1 %cmp, label %return, label %if.end3

if.end3:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.034 = load ptr, ptr %parents, align 8
  %tobool.not35 = icmp eq ptr %c.034, null
  br i1 %tobool.not35, label %for.end, label %for.body

for.body:                                         ; preds = %if.end3, %for.inc
  %c.036 = phi ptr [ %c.0, %for.inc ], [ %c.034, %if.end3 ]
  %call.i18 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i18, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %for.body
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7680, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parent_change_aio_context) #31
  unreachable

do.end.i:                                         ; preds = %for.body
  %call1.i = tail call i32 @g_hash_table_contains(ptr noundef %visited, ptr noundef nonnull %c.036) #29
  %tobool.not.i19 = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i19, label %if.end3.i, label %for.inc

if.end3.i:                                        ; preds = %do.end.i
  %call4.i = tail call i32 @g_hash_table_add(ptr noundef %visited, ptr noundef nonnull %c.036) #29
  %klass.i = getelementptr inbounds %struct.BdrvChild, ptr %c.036, i64 0, i32 2
  %1 = load ptr, ptr %klass.i, align 8
  %change_aio_ctx.i = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i64 0, i32 13
  %2 = load ptr, ptr %change_aio_ctx.i, align 8
  %tobool5.not.i = icmp eq ptr %2, null
  br i1 %tobool5.not.i, label %if.then6.i, label %if.end8.i

if.then6.i:                                       ; preds = %if.end3.i
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %bdrv_child_user_desc.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then6.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2186, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_user_desc) #31
  unreachable

bdrv_child_user_desc.exit.i:                      ; preds = %if.then6.i
  %klass.i.le = getelementptr inbounds %struct.BdrvChild, ptr %c.036, i64 0, i32 2
  %3 = load ptr, ptr %klass.i.le, align 8
  %get_parent_desc.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %3, i64 0, i32 4
  %4 = load ptr, ptr %get_parent_desc.i.i, align 8
  %call1.i.i = tail call ptr %4(ptr noundef nonnull %c.036) #29
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7692, ptr noundef nonnull @__func__.bdrv_parent_change_aio_context, ptr noundef nonnull @.str.287, ptr noundef %call1.i.i) #29
  tail call void @g_free(ptr noundef %call1.i.i) #29
  br label %if.then5

if.end8.i:                                        ; preds = %if.end3.i
  %call11.i = tail call zeroext i1 %2(ptr noundef nonnull %c.036, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) #29
  br i1 %call11.i, label %for.inc, label %if.then12.i

if.then12.i:                                      ; preds = %if.end8.i
  %tobool13.not.i = icmp eq ptr %errp, null
  br i1 %tobool13.not.i, label %if.then5, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.then12.i
  %5 = load ptr, ptr %errp, align 8
  %tobool14.not.i = icmp eq ptr %5, null
  br i1 %tobool14.not.i, label %if.else16.i, label %if.then5

if.else16.i:                                      ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.288, ptr noundef nonnull @.str.2, i32 noundef 7697, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parent_change_aio_context) #31
  unreachable

if.then5:                                         ; preds = %bdrv_child_user_desc.exit.i, %if.then12.i, %lor.lhs.false.i
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  br label %return

for.inc:                                          ; preds = %if.end8.i, %do.end.i
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %c.036, i64 0, i32 10
  %c.0 = load ptr, ptr %next_parent, align 8
  %tobool.not = icmp eq ptr %c.0, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !90

for.end:                                          ; preds = %for.inc, %if.end3
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %c.137 = load ptr, ptr %children, align 8
  %tobool9.not38 = icmp eq ptr %c.137, null
  br i1 %tobool9.not38, label %for.end16, label %for.body10

for.body10:                                       ; preds = %for.end, %for.inc14
  %c.139 = phi ptr [ %c.1, %for.inc14 ], [ %c.137, %for.end ]
  %call.i20 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i20, label %do.end.i22, label %if.else.i21

if.else.i21:                                      ; preds = %for.body10
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7707, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_change_aio_context) #31
  unreachable

do.end.i22:                                       ; preds = %for.body10
  %call1.i23 = tail call i32 @g_hash_table_contains(ptr noundef %visited, ptr noundef nonnull %c.139) #29
  %tobool.not.i24 = icmp eq i32 %call1.i23, 0
  br i1 %tobool.not.i24, label %bdrv_child_change_aio_context.exit, label %for.inc14

bdrv_child_change_aio_context.exit:               ; preds = %do.end.i22
  %call4.i27 = tail call i32 @g_hash_table_add(ptr noundef %visited, ptr noundef nonnull %c.139) #29
  %6 = load ptr, ptr %c.139, align 8
  %call5.i = tail call fastcc zeroext i1 @bdrv_change_aio_context(ptr noundef %6, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp)
  br i1 %call5.i, label %for.inc14, label %if.then12

if.then12:                                        ; preds = %bdrv_child_change_aio_context.exit
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  br label %return

for.inc14:                                        ; preds = %do.end.i22, %bdrv_child_change_aio_context.exit
  %next = getelementptr inbounds %struct.BdrvChild, ptr %c.139, i64 0, i32 9
  %c.1 = load ptr, ptr %next, align 8
  %tobool9.not = icmp eq ptr %c.1, null
  br i1 %tobool9.not, label %for.end16, label %for.body10, !llvm.loop !91

for.end16:                                        ; preds = %for.inc14, %for.end
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  %call17 = tail call noalias dereferenceable_or_null(16) ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #32
  store ptr %ctx, ptr %call17, align 8
  %.compoundliteral.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call17, i64 8
  store ptr %bs, ptr %.compoundliteral.sroa.2.0..sroa_idx, align 8
  tail call void @bdrv_drained_begin(ptr noundef %bs) #29
  tail call void @tran_add(ptr noundef %tran, ptr noundef nonnull @set_aio_context, ptr noundef nonnull %call17) #29
  br label %return

return:                                           ; preds = %bdrv_get_aio_context.exit, %for.end16, %if.then12, %if.then5
  %retval.0 = phi i1 [ false, %if.then5 ], [ false, %if.then12 ], [ true, %for.end16 ], [ true, %bdrv_get_aio_context.exit ]
  ret i1 %retval.0
}

declare ptr @g_hash_table_new(ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @g_hash_table_destroy(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_add_aio_context_notifier(ptr noundef %bs, ptr noundef %attached_aio_context, ptr noundef %detach_aio_context, ptr noundef %opaque) local_unnamed_addr #4 {
entry:
  %call = tail call noalias dereferenceable_or_null(48) ptr @g_malloc_n(i64 noundef 1, i64 noundef 48) #32
  store ptr %attached_aio_context, ptr %call, align 8
  %.compoundliteral.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 8
  store ptr %detach_aio_context, ptr %.compoundliteral.sroa.2.0..sroa_idx, align 8
  %.compoundliteral.sroa.3.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 16
  store ptr %opaque, ptr %.compoundliteral.sroa.3.0..sroa_idx, align 8
  %.compoundliteral.sroa.4.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 24
  store i8 0, ptr %.compoundliteral.sroa.4.0..sroa_idx, align 8
  %call4 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call4, label %do.body5, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7901, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_add_aio_context_notifier) #31
  unreachable

do.body5:                                         ; preds = %entry
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 9
  %0 = load ptr, ptr %aio_notifiers, align 8
  %list6 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %call, i64 0, i32 4
  store ptr %0, ptr %list6, align 8
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %if.end13, label %if.then7

if.then7:                                         ; preds = %do.body5
  %le_prev = getelementptr inbounds %struct.BdrvAioNotifier, ptr %0, i64 0, i32 4, i32 1
  store ptr %list6, ptr %le_prev, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then7, %do.body5
  store ptr %call, ptr %aio_notifiers, align 8
  %le_prev19 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %call, i64 0, i32 4, i32 1
  store ptr %aio_notifiers, ptr %le_prev19, align 8
  ret void
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc_n(i64 noundef, i64 noundef) local_unnamed_addr #10

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_remove_aio_context_notifier(ptr nocapture noundef readonly %bs, ptr noundef readnone %attached_aio_context, ptr noundef readnone %detach_aio_context, ptr noundef readnone %opaque) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7913, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_remove_aio_context_notifier) #31
  unreachable

do.end:                                           ; preds = %entry
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 9
  %0 = load ptr, ptr %aio_notifiers, align 8
  %tobool.not11 = icmp eq ptr %0, null
  br i1 %tobool.not11, label %for.end, label %land.rhs

land.rhs:                                         ; preds = %do.end, %for.inc
  %ban.012 = phi ptr [ %1, %for.inc ], [ %0, %do.end ]
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 4
  %1 = load ptr, ptr %list, align 8
  %2 = load ptr, ptr %ban.012, align 8
  %cmp = icmp eq ptr %2, %attached_aio_context
  br i1 %cmp, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %land.rhs
  %detach_aio_context2 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 1
  %3 = load ptr, ptr %detach_aio_context2, align 8
  %cmp3 = icmp eq ptr %3, %detach_aio_context
  br i1 %cmp3, label %land.lhs.true4, label %for.inc

land.lhs.true4:                                   ; preds = %land.lhs.true
  %opaque5 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 2
  %4 = load ptr, ptr %opaque5, align 8
  %cmp6 = icmp eq ptr %4, %opaque
  br i1 %cmp6, label %land.lhs.true7, label %for.inc

land.lhs.true7:                                   ; preds = %land.lhs.true4
  %deleted = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 3
  %5 = load i8, ptr %deleted, align 8
  %6 = and i8 %5, 1
  %cmp9 = icmp eq i8 %6, 0
  br i1 %cmp9, label %if.then11, label %for.inc

if.then11:                                        ; preds = %land.lhs.true7
  %list.le = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 4
  %walking_aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 10
  %7 = load i8, ptr %walking_aio_notifiers, align 8
  %8 = and i8 %7, 1
  %tobool12.not = icmp eq i8 %8, 0
  br i1 %tobool12.not, label %if.else15, label %if.then13

if.then13:                                        ; preds = %if.then11
  %deleted.le = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 3
  store i8 1, ptr %deleted.le, align 8
  br label %if.end16

if.else15:                                        ; preds = %if.then11
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.body1.i, label %if.else.i

if.else.i:                                        ; preds = %if.else15
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7615, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_remove_aio_context_notifier) #31
  unreachable

do.body1.i:                                       ; preds = %if.else15
  %9 = load ptr, ptr %list.le, align 8
  %cmp.not.i = icmp eq ptr %9, null
  %le_prev12.phi.trans.insert.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.012, i64 0, i32 4, i32 1
  %.pre8.i = load ptr, ptr %le_prev12.phi.trans.insert.i, align 8
  br i1 %cmp.not.i, label %bdrv_do_remove_aio_context_notifier.exit, label %if.then2.i

if.then2.i:                                       ; preds = %do.body1.i
  %le_prev7.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %9, i64 0, i32 4, i32 1
  store ptr %.pre8.i, ptr %le_prev7.i, align 8
  %.pre.i = load ptr, ptr %list.le, align 8
  br label %bdrv_do_remove_aio_context_notifier.exit

bdrv_do_remove_aio_context_notifier.exit:         ; preds = %do.body1.i, %if.then2.i
  %10 = phi ptr [ %.pre.i, %if.then2.i ], [ null, %do.body1.i ]
  store ptr %10, ptr %.pre8.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.le, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %ban.012) #29
  br label %if.end16

if.end16:                                         ; preds = %bdrv_do_remove_aio_context_notifier.exit, %if.then13
  ret void

for.inc:                                          ; preds = %land.rhs, %land.lhs.true, %land.lhs.true4, %land.lhs.true7
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %for.end, label %land.rhs, !llvm.loop !92

for.end:                                          ; preds = %for.inc, %do.end
  tail call void @abort() #31
  unreachable
}

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #9

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_amend_options(ptr noundef %bs, ptr noundef %opts, ptr noundef %status_cb, ptr noundef %cb_opaque, i1 noundef zeroext %force, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7938, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_amend_options) #31
  unreachable

do.end:                                           ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then1, label %if.end2

if.then1:                                         ; preds = %do.end
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7940, ptr noundef nonnull @__func__.bdrv_amend_options, ptr noundef nonnull @.str.130) #29
  br label %return

if.end2:                                          ; preds = %do.end
  %bdrv_amend_options = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 28
  %1 = load ptr, ptr %bdrv_amend_options, align 8
  %tobool4.not = icmp eq ptr %1, null
  br i1 %tobool4.not, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end2
  %2 = load ptr, ptr %0, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 7945, ptr noundef nonnull @__func__.bdrv_amend_options, ptr noundef nonnull @.str.131, ptr noundef %2) #29
  br label %return

if.end7:                                          ; preds = %if.end2
  %call11 = tail call i32 %1(ptr noundef nonnull %bs, ptr noundef %opts, ptr noundef %status_cb, ptr noundef %cb_opaque, i1 noundef zeroext %force, ptr noundef %errp) #29
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then1
  %retval.0 = phi i32 [ %call11, %if.end7 ], [ -95, %if.then5 ], [ -123, %if.then1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_recurse_can_replace(ptr noundef %bs, ptr noundef %to_replace) local_unnamed_addr #4 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %bdrv_filter_bs.exit, %entry
  %bs.tr = phi ptr [ %bs, %entry ], [ %7, %bdrv_filter_bs.exit ]
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %tailrecurse
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7969, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_recurse_can_replace) #31
  unreachable

do.end:                                           ; preds = %tailrecurse
  %tobool.not = icmp eq ptr %bs.tr, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %if.end3

if.end3:                                          ; preds = %lor.lhs.false
  %cmp = icmp eq ptr %bs.tr, %to_replace
  br i1 %cmp, label %return, label %if.end5

if.end5:                                          ; preds = %if.end3
  %bdrv_recurse_can_replace = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 15
  %1 = load ptr, ptr %bdrv_recurse_can_replace, align 8
  %tobool7.not = icmp eq ptr %1, null
  br i1 %tobool7.not, label %if.end.i.i, label %if.then8

if.then8:                                         ; preds = %if.end5
  %call11 = tail call zeroext i1 %1(ptr noundef nonnull %bs.tr, ptr noundef %to_replace) #29
  br label %return

if.end.i.i:                                       ; preds = %if.end5
  %is_filter.i.i = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %2 = load i8, ptr %is_filter.i.i, align 4
  %3 = and i8 %2, 1
  %tobool3.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool3.not.i.i, label %return, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.end.i.i
  %backing.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 30
  %4 = load ptr, ptr %backing.i.i, align 8
  %tobool6.not.i.i = icmp eq ptr %4, null
  %file12.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 31
  %5 = load ptr, ptr %file12.i.i, align 8
  %tobool13.not.i.i = icmp eq ptr %5, null
  br i1 %tobool6.not.i.i, label %cond.end.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %if.end15.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %land.lhs.true.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i.i:                                     ; preds = %if.end5.i.i
  br i1 %tobool13.not.i.i, label %return, label %if.end15.i.i

if.end15.i.i:                                     ; preds = %cond.end.i.i, %land.lhs.true.i.i
  %cond12.i.i = phi ptr [ %5, %cond.end.i.i ], [ %4, %land.lhs.true.i.i ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.i, i64 0, i32 3
  %6 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %6, 4
  %tobool16.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool16.not.i.i, label %if.else18.i.i, label %bdrv_filter_bs.exit

if.else18.i.i:                                    ; preds = %if.end15.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

bdrv_filter_bs.exit:                              ; preds = %if.end15.i.i
  %7 = load ptr, ptr %cond12.i.i, align 8
  %tobool14.not = icmp eq ptr %7, null
  br i1 %tobool14.not, label %return, label %tailrecurse

return:                                           ; preds = %cond.end.i.i, %if.end.i.i, %bdrv_filter_bs.exit, %if.end3, %do.end, %lor.lhs.false, %if.then8
  %retval.0 = phi i1 [ %call11, %if.then8 ], [ false, %cond.end.i.i ], [ false, %if.end.i.i ], [ false, %bdrv_filter_bs.exit ], [ true, %if.end3 ], [ false, %do.end ], [ false, %lor.lhs.false ]
  ret i1 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @check_to_replace_node(ptr noundef %parent_bs, ptr noundef %node_name, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %tobool.not.i = icmp eq ptr %node_name, null
  br i1 %tobool.not.i, label %if.else.i, label %do.body.i

if.else.i:                                        ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.99, ptr noundef nonnull @.str.2, i32 noundef 6328, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

do.body.i:                                        ; preds = %entry
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %for.cond.preheader.i, label %if.else2.i

for.cond.preheader.i:                             ; preds = %do.body.i
  %bs.05.i = load ptr, ptr @graph_bdrv_states, align 8
  %tobool4.not6.i = icmp eq ptr %bs.05.i, null
  br i1 %tobool4.not6.i, label %bdrv_find_node.exit, label %for.body.i

if.else2.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 6329, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_find_node) #31
  unreachable

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %bs.07.i = phi ptr [ %bs.0.i, %for.inc.i ], [ %bs.05.i, %for.cond.preheader.i ]
  %node_name5.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07.i, i64 0, i32 22
  %call6.i = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %node_name, ptr noundef nonnull dereferenceable(1) %node_name5.i) #28
  %tobool7.not.i = icmp eq i32 %call6.i, 0
  br i1 %tobool7.not.i, label %bdrv_find_node.exit, label %for.inc.i

for.inc.i:                                        ; preds = %for.body.i
  %node_list.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.07.i, i64 0, i32 23
  %bs.0.i = load ptr, ptr %node_list.i, align 8
  %tobool4.not.i = icmp eq ptr %bs.0.i, null
  br i1 %tobool4.not.i, label %bdrv_find_node.exit, label %for.body.i, !llvm.loop !15

bdrv_find_node.exit:                              ; preds = %for.body.i, %for.inc.i, %for.cond.preheader.i
  %bs.0.lcssa.i = phi ptr [ null, %for.cond.preheader.i ], [ %bs.07.i, %for.body.i ], [ null, %for.inc.i ]
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %bdrv_find_node.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8011, ptr noundef nonnull @__PRETTY_FUNCTION__.check_to_replace_node) #31
  unreachable

do.end:                                           ; preds = %bdrv_find_node.exit
  %tobool.not = icmp eq ptr %bs.0.lcssa.i, null
  br i1 %tobool.not, label %if.then2, label %bdrv_get_aio_context.exit

if.then2:                                         ; preds = %do.end
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8014, ptr noundef nonnull @__func__.check_to_replace_node, ptr noundef nonnull @.str.132, ptr noundef nonnull %node_name) #29
  br label %return

bdrv_get_aio_context.exit:                        ; preds = %do.end
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.0.lcssa.i, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  tail call void @aio_context_acquire(ptr noundef %0) #29
  %call.i13 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i13, label %do.end.i, label %if.else.i14

if.else.i14:                                      ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7291, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_op_is_blocked) #31
  unreachable

do.end.i:                                         ; preds = %bdrv_get_aio_context.exit
  %arrayidx.i = getelementptr %struct.BlockDriverState, ptr %bs.0.lcssa.i, i64 0, i32 27, i64 15
  %1 = load ptr, ptr %arrayidx.i, align 8
  %cmp5.i.not = icmp eq ptr %1, null
  br i1 %cmp5.i.not, label %if.end7, label %if.then6.i

if.then6.i:                                       ; preds = %do.end.i
  %2 = load ptr, ptr %1, align 8
  %call11.i = tail call ptr @error_copy(ptr noundef %2) #29
  %parents.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.0.lcssa.i, i64 0, i32 32
  %c.07.i.i.i = load ptr, ptr %parents.i.i.i, align 8
  %tobool.not8.i.i.i = icmp eq ptr %c.07.i.i.i, null
  br i1 %tobool.not8.i.i.i, label %bdrv_op_is_blocked.exit.thread15, label %for.body.i.i.i

bdrv_op_is_blocked.exit.thread15:                 ; preds = %if.then6.i
  %node_name.i.i18 = getelementptr inbounds %struct.BlockDriverState, ptr %bs.0.lcssa.i, i64 0, i32 22
  tail call void (ptr, ptr, ptr, ...) @error_propagate_prepend(ptr noundef %errp, ptr noundef %call11.i, ptr noundef nonnull @.str.107, ptr noundef nonnull %node_name.i.i18) #29
  br label %out

for.body.i.i.i:                                   ; preds = %if.then6.i, %for.inc.i.i.i
  %c.09.i.i.i = phi ptr [ %c.0.i.i.i, %for.inc.i.i.i ], [ %c.07.i.i.i, %if.then6.i ]
  %klass.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i, i64 0, i32 2
  %3 = load ptr, ptr %klass.i.i.i, align 8
  %get_name.i.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %3, i64 0, i32 15
  %4 = load ptr, ptr %get_name.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq ptr %4, null
  br i1 %tobool1.not.i.i.i, label %for.inc.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %for.body.i.i.i
  %call.i.i.i = tail call ptr %4(ptr noundef nonnull %c.09.i.i.i) #29
  %tobool4.not.i.i.i = icmp eq ptr %call.i.i.i, null
  br i1 %tobool4.not.i.i.i, label %for.inc.i.i.i, label %land.lhs.true.i.i.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i.i.i
  %5 = load i8, ptr %call.i.i.i, align 1
  %tobool5.not.i.i.i = icmp eq i8 %5, 0
  br i1 %tobool5.not.i.i.i, label %for.inc.i.i.i, label %bdrv_op_is_blocked.exit

for.inc.i.i.i:                                    ; preds = %land.lhs.true.i.i.i, %if.then.i.i.i, %for.body.i.i.i
  %next_parent.i.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i.i, i64 0, i32 10
  %c.0.i.i.i = load ptr, ptr %next_parent.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %c.0.i.i.i, null
  br i1 %tobool.not.i.i.i, label %bdrv_op_is_blocked.exit, label %for.body.i.i.i, !llvm.loop !5

bdrv_op_is_blocked.exit:                          ; preds = %land.lhs.true.i.i.i, %for.inc.i.i.i
  %retval.0.i.i.i = phi ptr [ null, %for.inc.i.i.i ], [ %call.i.i.i, %land.lhs.true.i.i.i ]
  %tobool.not.i.i = icmp eq ptr %retval.0.i.i.i, null
  %node_name.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.0.lcssa.i, i64 0, i32 22
  %cond.i.i = select i1 %tobool.not.i.i, ptr %node_name.i.i, ptr %retval.0.i.i.i
  tail call void (ptr, ptr, ptr, ...) @error_propagate_prepend(ptr noundef %errp, ptr noundef %call11.i, ptr noundef nonnull @.str.107, ptr noundef nonnull %cond.i.i) #29
  br label %out

if.end7:                                          ; preds = %do.end.i
  %call8 = tail call zeroext i1 @bdrv_recurse_can_replace(ptr noundef %parent_bs, ptr noundef nonnull %bs.0.lcssa.i)
  br i1 %call8, label %out, label %if.then9

if.then9:                                         ; preds = %if.end7
  %node_name10 = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8035, ptr noundef nonnull @__func__.check_to_replace_node, ptr noundef nonnull @.str.133, ptr noundef nonnull %node_name, ptr noundef nonnull %node_name10) #29
  br label %out

out:                                              ; preds = %bdrv_op_is_blocked.exit, %bdrv_op_is_blocked.exit.thread15, %if.end7, %if.then9
  %to_replace_bs.0 = phi ptr [ %bs.0.lcssa.i, %if.end7 ], [ null, %if.then9 ], [ null, %bdrv_op_is_blocked.exit ], [ null, %bdrv_op_is_blocked.exit.thread15 ]
  tail call void @aio_context_release(ptr noundef %0) #29
  br label %return

return:                                           ; preds = %out, %if.then2
  %retval.0 = phi ptr [ %to_replace_bs.0, %out ], [ null, %if.then2 ]
  ret ptr %retval.0
}

declare void @qdict_put_null(ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qobject_to_json(ptr noundef) local_unnamed_addr #5

; Function Attrs: nofree nounwind
declare noundef i32 @snprintf(ptr noalias nocapture noundef writeonly, i64 noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #21

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_dirname(ptr noundef %bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %bdrv_primary_bs.exit, %entry
  %bs.tr = phi ptr [ %bs, %entry ], [ %4, %bdrv_primary_bs.exit ]
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 6
  %0 = load ptr, ptr %drv1, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %tailrecurse
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8299, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_dirname) #31
  unreachable

do.end:                                           ; preds = %tailrecurse
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8302, ptr noundef nonnull @__func__.bdrv_dirname, ptr noundef nonnull @.str.137, ptr noundef nonnull %node_name) #29
  br label %return

if.end3:                                          ; preds = %do.end
  %bdrv_dirname = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 32
  %1 = load ptr, ptr %bdrv_dirname, align 8
  %tobool4.not = icmp eq ptr %1, null
  br i1 %tobool4.not, label %if.end8, label %if.then5

if.then5:                                         ; preds = %if.end3
  %call7 = tail call ptr %1(ptr noundef nonnull %bs.tr, ptr noundef %errp) #29
  br label %return

if.end8:                                          ; preds = %if.end3
  %2 = getelementptr i8, ptr %bs.tr, i64 16824
  %bs.val = load ptr, ptr %2, align 8
  %tobool.not7.i.i = icmp eq ptr %bs.val, null
  br i1 %tobool.not7.i.i, label %if.end13, label %for.body.i.i

for.body.i.i:                                     ; preds = %if.end8, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %bs.val, %if.end8 ]
  %found.08.i.i = phi ptr [ %found.1.i.i, %for.inc.i.i ], [ null, %if.end8 ]
  %role.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 3
  %3 = load i32, ptr %role.i.i, align 8
  %and.i.i = and i32 %3, 16
  %tobool1.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %tobool2.not.i.i = icmp eq ptr %found.08.i.i, null
  br i1 %tobool2.not.i.i, label %for.inc.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.155, ptr noundef nonnull @.str.2, i32 noundef 8506, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_primary_child) #31
  unreachable

for.inc.i.i:                                      ; preds = %if.then.i.i, %for.body.i.i
  %found.1.i.i = phi ptr [ %found.08.i.i, %for.body.i.i ], [ %c.09.i.i, %if.then.i.i ]
  %next.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 9
  %c.0.i.i = load ptr, ptr %next.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_primary_child.exit.i, label %for.body.i.i, !llvm.loop !35

bdrv_primary_child.exit.i:                        ; preds = %for.inc.i.i
  %tobool.not.i1.i = icmp eq ptr %found.1.i.i, null
  br i1 %tobool.not.i1.i, label %if.end13, label %bdrv_primary_bs.exit

bdrv_primary_bs.exit:                             ; preds = %bdrv_primary_child.exit.i
  %4 = load ptr, ptr %found.1.i.i, align 8
  %tobool10.not = icmp eq ptr %4, null
  br i1 %tobool10.not, label %if.end13, label %tailrecurse

if.end13:                                         ; preds = %if.end8, %bdrv_primary_child.exit.i, %bdrv_primary_bs.exit
  tail call void @bdrv_refresh_filename(ptr noundef %bs.tr)
  %exact_filename = getelementptr inbounds %struct.BlockDriverState, ptr %bs.tr, i64 0, i32 16
  %5 = load i8, ptr %exact_filename, align 8
  %cmp.not = icmp eq i8 %5, 0
  br i1 %cmp.not, label %if.end19, label %if.then15

if.then15:                                        ; preds = %if.end13
  %call18 = tail call ptr @path_combine(ptr noundef nonnull %exact_filename, ptr noundef nonnull @.str.95)
  br label %return

if.end19:                                         ; preds = %if.end13
  %6 = load ptr, ptr %0, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8321, ptr noundef nonnull @__func__.bdrv_dirname, ptr noundef nonnull @.str.138, ptr noundef %6) #29
  br label %return

return:                                           ; preds = %if.end19, %if.then15, %if.then5, %if.then2
  %retval.0 = phi ptr [ %call7, %if.then5 ], [ %call18, %if.then15 ], [ null, %if.end19 ], [ null, %if.then2 ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_add_child(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8332, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_add_child) #31
  unreachable

do.end:                                           ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %bdrv_add_child = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 53
  %1 = load ptr, ptr %bdrv_add_child, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %if.then3, label %if.end5

if.then3:                                         ; preds = %lor.lhs.false, %do.end
  %parents.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 32
  %c.07.i.i = load ptr, ptr %parents.i.i, align 8
  %tobool.not8.i.i = icmp eq ptr %c.07.i.i, null
  br i1 %tobool.not8.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %if.then3, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %c.07.i.i, %if.then3 ]
  %klass.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 2
  %2 = load ptr, ptr %klass.i.i, align 8
  %get_name.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %2, i64 0, i32 15
  %3 = load ptr, ptr %get_name.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %call.i.i = tail call ptr %3(ptr noundef nonnull %c.09.i.i) #29
  %tobool4.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool4.not.i.i, label %for.inc.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.then.i.i
  %4 = load i8, ptr %call.i.i, align 1
  %tobool5.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool5.not.i.i, label %for.inc.i.i, label %bdrv_get_device_or_node_name.exit

for.inc.i.i:                                      ; preds = %land.lhs.true.i.i, %if.then.i.i, %for.body.i.i
  %next_parent.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 10
  %c.0.i.i = load ptr, ptr %next_parent.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i, !llvm.loop !5

bdrv_get_device_or_node_name.exit:                ; preds = %land.lhs.true.i.i, %for.inc.i.i, %if.then3
  %retval.0.i.i = phi ptr [ null, %if.then3 ], [ null, %for.inc.i.i ], [ %call.i.i, %land.lhs.true.i.i ]
  %tobool.not.i = icmp eq ptr %retval.0.i.i, null
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  %cond.i = select i1 %tobool.not.i, ptr %node_name.i, ptr %retval.0.i.i
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8335, ptr noundef nonnull @__func__.bdrv_add_child, ptr noundef nonnull @.str.139, ptr noundef nonnull %cond.i) #29
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %supports_zoned_children = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 5
  %5 = load i8, ptr %supports_zoned_children, align 1
  %6 = and i8 %5, 1
  %tobool7.not = icmp eq i8 %6, 0
  br i1 %tobool7.not, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end5
  %zoned = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 17, i32 13
  %7 = load i32, ptr %zoned, align 8
  %cmp = icmp eq i32 %7, 1
  br i1 %cmp, label %if.then8, label %if.end16

if.then8:                                         ; preds = %land.lhs.true
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8354, ptr noundef nonnull @__func__.bdrv_add_child, ptr noundef nonnull @.str.140, ptr noundef nonnull @.str.141, ptr noundef nonnull @.str.144) #29
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %if.end5
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 32
  %8 = load ptr, ptr %parents, align 8
  %cmp17 = icmp eq ptr %8, null
  br i1 %cmp17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end16
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %child_bs, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8360, ptr noundef nonnull @__func__.bdrv_add_child, ptr noundef nonnull @.str.145, ptr noundef nonnull %node_name) #29
  br label %return

if.end19:                                         ; preds = %if.end16
  tail call void %1(ptr noundef nonnull %parent_bs, ptr noundef nonnull %child_bs, ptr noundef %errp) #29
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then8, %bdrv_get_device_or_node_name.exit
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_del_child(ptr noundef %parent_bs, ptr noundef %child, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8371, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_del_child) #31
  unreachable

do.end:                                           ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %bdrv_del_child = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 54
  %1 = load ptr, ptr %bdrv_del_child, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %if.then3, label %if.end5

if.then3:                                         ; preds = %lor.lhs.false, %do.end
  %parents.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 32
  %c.07.i.i = load ptr, ptr %parents.i.i, align 8
  %tobool.not8.i.i = icmp eq ptr %c.07.i.i, null
  br i1 %tobool.not8.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %if.then3, %for.inc.i.i
  %c.09.i.i = phi ptr [ %c.0.i.i, %for.inc.i.i ], [ %c.07.i.i, %if.then3 ]
  %klass.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 2
  %2 = load ptr, ptr %klass.i.i, align 8
  %get_name.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %2, i64 0, i32 15
  %3 = load ptr, ptr %get_name.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %call.i.i = tail call ptr %3(ptr noundef nonnull %c.09.i.i) #29
  %tobool4.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool4.not.i.i, label %for.inc.i.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.then.i.i
  %4 = load i8, ptr %call.i.i, align 1
  %tobool5.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool5.not.i.i, label %for.inc.i.i, label %bdrv_get_device_or_node_name.exit

for.inc.i.i:                                      ; preds = %land.lhs.true.i.i, %if.then.i.i, %for.body.i.i
  %next_parent.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i, i64 0, i32 10
  %c.0.i.i = load ptr, ptr %next_parent.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i, label %bdrv_get_device_or_node_name.exit, label %for.body.i.i, !llvm.loop !5

bdrv_get_device_or_node_name.exit:                ; preds = %land.lhs.true.i.i, %for.inc.i.i, %if.then3
  %retval.0.i.i = phi ptr [ null, %if.then3 ], [ null, %for.inc.i.i ], [ %call.i.i, %land.lhs.true.i.i ]
  %tobool.not.i = icmp eq ptr %retval.0.i.i, null
  %node_name.i = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  %cond.i = select i1 %tobool.not.i, ptr %node_name.i, ptr %retval.0.i.i
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8374, ptr noundef nonnull @__func__.bdrv_del_child, ptr noundef nonnull @.str.146, ptr noundef nonnull %cond.i) #29
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 29
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %if.end5
  %tmp.0.in = phi ptr [ %children, %if.end5 ], [ %next, %for.cond ]
  %tmp.0 = load ptr, ptr %tmp.0.in, align 8
  %tobool6.not = icmp eq ptr %tmp.0, null
  %cmp = icmp eq ptr %tmp.0, %child
  %or.cond = or i1 %tobool6.not, %cmp
  %next = getelementptr inbounds %struct.BdrvChild, ptr %tmp.0, i64 0, i32 9
  br i1 %or.cond, label %for.end, label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  br i1 %tobool6.not, label %if.then10, label %if.end13

if.then10:                                        ; preds = %for.end
  %parents.i.i14 = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 32
  %c.07.i.i15 = load ptr, ptr %parents.i.i14, align 8
  %tobool.not8.i.i16 = icmp eq ptr %c.07.i.i15, null
  br i1 %tobool.not8.i.i16, label %bdrv_get_device_or_node_name.exit35, label %for.body.i.i17

for.body.i.i17:                                   ; preds = %if.then10, %for.inc.i.i31
  %c.09.i.i18 = phi ptr [ %c.0.i.i33, %for.inc.i.i31 ], [ %c.07.i.i15, %if.then10 ]
  %klass.i.i19 = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i18, i64 0, i32 2
  %5 = load ptr, ptr %klass.i.i19, align 8
  %get_name.i.i20 = getelementptr inbounds %struct.BdrvChildClass, ptr %5, i64 0, i32 15
  %6 = load ptr, ptr %get_name.i.i20, align 8
  %tobool1.not.i.i21 = icmp eq ptr %6, null
  br i1 %tobool1.not.i.i21, label %for.inc.i.i31, label %if.then.i.i22

if.then.i.i22:                                    ; preds = %for.body.i.i17
  %call.i.i23 = tail call ptr %6(ptr noundef nonnull %c.09.i.i18) #29
  %tobool4.not.i.i24 = icmp eq ptr %call.i.i23, null
  br i1 %tobool4.not.i.i24, label %for.inc.i.i31, label %land.lhs.true.i.i25

land.lhs.true.i.i25:                              ; preds = %if.then.i.i22
  %7 = load i8, ptr %call.i.i23, align 1
  %tobool5.not.i.i26 = icmp eq i8 %7, 0
  br i1 %tobool5.not.i.i26, label %for.inc.i.i31, label %bdrv_get_device_or_node_name.exit35

for.inc.i.i31:                                    ; preds = %land.lhs.true.i.i25, %if.then.i.i22, %for.body.i.i17
  %next_parent.i.i32 = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i18, i64 0, i32 10
  %c.0.i.i33 = load ptr, ptr %next_parent.i.i32, align 8
  %tobool.not.i.i34 = icmp eq ptr %c.0.i.i33, null
  br i1 %tobool.not.i.i34, label %bdrv_get_device_or_node_name.exit35, label %for.body.i.i17, !llvm.loop !5

bdrv_get_device_or_node_name.exit35:              ; preds = %land.lhs.true.i.i25, %for.inc.i.i31, %if.then10
  %retval.0.i.i27 = phi ptr [ null, %if.then10 ], [ null, %for.inc.i.i31 ], [ %call.i.i23, %land.lhs.true.i.i25 ]
  %tobool.not.i28 = icmp eq ptr %retval.0.i.i27, null
  %node_name.i29 = getelementptr inbounds %struct.BlockDriverState, ptr %parent_bs, i64 0, i32 22
  %cond.i30 = select i1 %tobool.not.i28, ptr %node_name.i29, ptr %retval.0.i.i27
  %8 = load ptr, ptr %child, align 8
  %parents.i.i36 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i64 0, i32 32
  %c.07.i.i37 = load ptr, ptr %parents.i.i36, align 8
  %tobool.not8.i.i38 = icmp eq ptr %c.07.i.i37, null
  br i1 %tobool.not8.i.i38, label %bdrv_get_device_or_node_name.exit57, label %for.body.i.i39

for.body.i.i39:                                   ; preds = %bdrv_get_device_or_node_name.exit35, %for.inc.i.i53
  %c.09.i.i40 = phi ptr [ %c.0.i.i55, %for.inc.i.i53 ], [ %c.07.i.i37, %bdrv_get_device_or_node_name.exit35 ]
  %klass.i.i41 = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i40, i64 0, i32 2
  %9 = load ptr, ptr %klass.i.i41, align 8
  %get_name.i.i42 = getelementptr inbounds %struct.BdrvChildClass, ptr %9, i64 0, i32 15
  %10 = load ptr, ptr %get_name.i.i42, align 8
  %tobool1.not.i.i43 = icmp eq ptr %10, null
  br i1 %tobool1.not.i.i43, label %for.inc.i.i53, label %if.then.i.i44

if.then.i.i44:                                    ; preds = %for.body.i.i39
  %call.i.i45 = tail call ptr %10(ptr noundef nonnull %c.09.i.i40) #29
  %tobool4.not.i.i46 = icmp eq ptr %call.i.i45, null
  br i1 %tobool4.not.i.i46, label %for.inc.i.i53, label %land.lhs.true.i.i47

land.lhs.true.i.i47:                              ; preds = %if.then.i.i44
  %11 = load i8, ptr %call.i.i45, align 1
  %tobool5.not.i.i48 = icmp eq i8 %11, 0
  br i1 %tobool5.not.i.i48, label %for.inc.i.i53, label %bdrv_get_device_or_node_name.exit57

for.inc.i.i53:                                    ; preds = %land.lhs.true.i.i47, %if.then.i.i44, %for.body.i.i39
  %next_parent.i.i54 = getelementptr inbounds %struct.BdrvChild, ptr %c.09.i.i40, i64 0, i32 10
  %c.0.i.i55 = load ptr, ptr %next_parent.i.i54, align 8
  %tobool.not.i.i56 = icmp eq ptr %c.0.i.i55, null
  br i1 %tobool.not.i.i56, label %bdrv_get_device_or_node_name.exit57, label %for.body.i.i39, !llvm.loop !5

bdrv_get_device_or_node_name.exit57:              ; preds = %land.lhs.true.i.i47, %for.inc.i.i53, %bdrv_get_device_or_node_name.exit35
  %retval.0.i.i49 = phi ptr [ null, %bdrv_get_device_or_node_name.exit35 ], [ null, %for.inc.i.i53 ], [ %call.i.i45, %land.lhs.true.i.i47 ]
  %tobool.not.i50 = icmp eq ptr %retval.0.i.i49, null
  %node_name.i51 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i64 0, i32 22
  %cond.i52 = select i1 %tobool.not.i50, ptr %node_name.i51, ptr %retval.0.i.i49
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8387, ptr noundef nonnull @__func__.bdrv_del_child, ptr noundef nonnull @.str.147, ptr noundef nonnull %cond.i30, ptr noundef nonnull %cond.i52) #29
  br label %return

if.end13:                                         ; preds = %for.end
  tail call void %1(ptr noundef %parent_bs, ptr noundef %child, ptr noundef %errp) #29
  br label %return

return:                                           ; preds = %if.end13, %bdrv_get_device_or_node_name.exit57, %bdrv_get_device_or_node_name.exit
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_make_empty(ptr nocapture noundef readonly %c, ptr noundef %errp) local_unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %c, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8399, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_make_empty) #31
  unreachable

do.end:                                           ; preds = %entry
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %c, i64 0, i32 5
  %2 = load i64, ptr %perm, align 8
  %and = and i64 %2, 6
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.else3, label %if.end4

if.else3:                                         ; preds = %do.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.148, ptr noundef nonnull @.str.2, i32 noundef 8400, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_make_empty) #31
  unreachable

if.end4:                                          ; preds = %do.end
  %bdrv_make_empty = getelementptr inbounds %struct.BlockDriver, ptr %1, i64 0, i32 29
  %3 = load ptr, ptr %bdrv_make_empty, align 8
  %tobool5.not = icmp eq ptr %3, null
  br i1 %tobool5.not, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %4 = load ptr, ptr %1, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8404, ptr noundef nonnull @__func__.bdrv_make_empty, ptr noundef nonnull @.str.149, ptr noundef %4) #29
  br label %return

if.end7:                                          ; preds = %if.end4
  %5 = load ptr, ptr %c, align 8
  %call10 = tail call i32 %3(ptr noundef %5) #29
  %cmp = icmp slt i32 %call10, 0
  br i1 %cmp, label %if.then11, label %return

if.then11:                                        ; preds = %if.end7
  %sub = sub i32 0, %call10
  %6 = load ptr, ptr %c, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %6, i64 0, i32 11
  tail call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 8411, ptr noundef nonnull @__func__.bdrv_make_empty, i32 noundef %sub, ptr noundef nonnull @.str.150, ptr noundef nonnull %filename) #29
  br label %return

return:                                           ; preds = %if.end7, %if.then11, %if.then6
  %retval.0 = phi i32 [ %call10, %if.then11 ], [ -95, %if.then6 ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_filter_child(ptr noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 6
  %0 = load ptr, ptr %drv, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %0, i64 0, i32 2
  %1 = load i8, ptr %is_filter, align 4
  %2 = and i8 %1, 1
  %tobool3.not = icmp eq i8 %2, 0
  br i1 %tobool3.not, label %return, label %if.end5

if.end5:                                          ; preds = %if.end
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 30
  %3 = load ptr, ptr %backing, align 8
  %tobool6.not = icmp eq ptr %3, null
  %file12 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 31
  %4 = load ptr, ptr %file12, align 8
  %tobool13.not = icmp eq ptr %4, null
  br i1 %tobool6.not, label %cond.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end5
  br i1 %tobool13.not, label %if.end15, label %if.else

if.else:                                          ; preds = %land.lhs.true
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end:                                         ; preds = %if.end5
  br i1 %tobool13.not, label %return, label %if.end15

if.end15:                                         ; preds = %land.lhs.true, %cond.end
  %cond12 = phi ptr [ %4, %cond.end ], [ %3, %land.lhs.true ]
  %role = getelementptr inbounds %struct.BdrvChild, ptr %cond12, i64 0, i32 3
  %5 = load i32, ptr %role, align 8
  %and = and i32 %5, 4
  %tobool16.not = icmp eq i32 %and, 0
  br i1 %tobool16.not, label %if.else18, label %return

if.else18:                                        ; preds = %if.end15
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

return:                                           ; preds = %if.end15, %cond.end, %if.end, %entry, %lor.lhs.false
  %retval.0 = phi ptr [ null, %lor.lhs.false ], [ null, %entry ], [ null, %if.end ], [ null, %cond.end ], [ %cond12, %if.end15 ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_primary_child(ptr nocapture noundef readonly %bs) local_unnamed_addr #4 {
entry:
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %c.06 = load ptr, ptr %children, align 8
  %tobool.not7 = icmp eq ptr %c.06, null
  br i1 %tobool.not7, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %c.09 = phi ptr [ %c.0, %for.inc ], [ %c.06, %entry ]
  %found.08 = phi ptr [ %found.1, %for.inc ], [ null, %entry ]
  %role = getelementptr inbounds %struct.BdrvChild, ptr %c.09, i64 0, i32 3
  %0 = load i32, ptr %role, align 8
  %and = and i32 %0, 16
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %tobool2.not = icmp eq ptr %found.08, null
  br i1 %tobool2.not, label %for.inc, label %if.else

if.else:                                          ; preds = %if.then
  tail call void @__assert_fail(ptr noundef nonnull @.str.155, ptr noundef nonnull @.str.2, i32 noundef 8506, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_primary_child) #31
  unreachable

for.inc:                                          ; preds = %if.then, %for.body
  %found.1 = phi ptr [ %found.08, %for.body ], [ %c.09, %if.then ]
  %next = getelementptr inbounds %struct.BdrvChild, ptr %c.09, i64 0, i32 9
  %c.0 = load ptr, ptr %next, align 8
  %tobool.not = icmp eq ptr %c.0, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !35

for.end:                                          ; preds = %for.inc, %entry
  %found.0.lcssa = phi ptr [ null, %entry ], [ %found.1, %for.inc ]
  ret ptr %found.0.lcssa
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_do_skip_filters(ptr noundef readonly %bs, i1 noundef zeroext %stop_on_explicit_filter) unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %bs, null
  br i1 %tobool.not, label %return, label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry
  br i1 %stop_on_explicit_filter, label %while.cond.preheader.split.us, label %lor.lhs.false.i

while.cond.preheader.split.us:                    ; preds = %while.cond.preheader
  %implicit.us15 = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 5
  %0 = load i8, ptr %implicit.us15, align 8
  %1 = and i8 %0, 1
  %tobool2.not.us16 = icmp eq i8 %1, 0
  br i1 %tobool2.not.us16, label %return, label %lor.lhs.false.i.us

lor.lhs.false.i.us:                               ; preds = %while.cond.preheader.split.us, %if.end11.us
  %bs.addr.0.us17 = phi ptr [ %8, %if.end11.us ], [ %bs, %while.cond.preheader.split.us ]
  %drv.i.us = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.0.us17, i64 0, i32 6
  %2 = load ptr, ptr %drv.i.us, align 8
  %tobool1.not.i.us = icmp eq ptr %2, null
  br i1 %tobool1.not.i.us, label %return, label %if.end.i.us

if.end.i.us:                                      ; preds = %lor.lhs.false.i.us
  %is_filter.i.us = getelementptr inbounds %struct.BlockDriver, ptr %2, i64 0, i32 2
  %3 = load i8, ptr %is_filter.i.us, align 4
  %4 = and i8 %3, 1
  %tobool3.not.i.us = icmp eq i8 %4, 0
  br i1 %tobool3.not.i.us, label %lor.lhs.false, label %if.end5.i.us

if.end5.i.us:                                     ; preds = %if.end.i.us
  %backing.i.us = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.0.us17, i64 0, i32 30
  %5 = load ptr, ptr %backing.i.us, align 8
  %tobool6.not.i.us = icmp eq ptr %5, null
  %file12.i.us = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.0.us17, i64 0, i32 31
  %6 = load ptr, ptr %file12.i.us, align 8
  %tobool13.not.i.us = icmp eq ptr %6, null
  br i1 %tobool6.not.i.us, label %cond.end.i.us, label %land.lhs.true.i.us

land.lhs.true.i.us:                               ; preds = %if.end5.i.us
  br i1 %tobool13.not.i.us, label %if.end15.i.us, label %if.else.i

cond.end.i.us:                                    ; preds = %if.end5.i.us
  br i1 %tobool13.not.i.us, label %lor.lhs.false, label %if.end15.i.us

if.end15.i.us:                                    ; preds = %cond.end.i.us, %land.lhs.true.i.us
  %cond12.i.us = phi ptr [ %6, %cond.end.i.us ], [ %5, %land.lhs.true.i.us ]
  %role.i.us = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i.us, i64 0, i32 3
  %7 = load i32, ptr %role.i.us, align 8
  %and.i.us = and i32 %7, 4
  %tobool16.not.i.us = icmp eq i32 %and.i.us, 0
  br i1 %tobool16.not.i.us, label %if.else18.i, label %if.end11.us

if.end11.us:                                      ; preds = %if.end15.i.us
  %8 = load ptr, ptr %cond12.i.us, align 8
  %implicit.us = getelementptr inbounds %struct.BlockDriverState, ptr %8, i64 0, i32 5
  %9 = load i8, ptr %implicit.us, align 8
  %10 = and i8 %9, 1
  %tobool2.not.us = icmp eq i8 %10, 0
  br i1 %tobool2.not.us, label %return, label %lor.lhs.false.i.us, !llvm.loop !94

lor.lhs.false.i:                                  ; preds = %while.cond.preheader, %if.end11
  %bs.addr.014 = phi ptr [ %20, %if.end11 ], [ %bs, %while.cond.preheader ]
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.014, i64 0, i32 6
  %11 = load ptr, ptr %drv.i, align 8
  %tobool1.not.i = icmp eq ptr %11, null
  br i1 %tobool1.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  %is_filter.i = getelementptr inbounds %struct.BlockDriver, ptr %11, i64 0, i32 2
  %12 = load i8, ptr %is_filter.i, align 4
  %13 = and i8 %12, 1
  %tobool3.not.i = icmp eq i8 %13, 0
  br i1 %tobool3.not.i, label %lor.lhs.false, label %if.end5.i

if.end5.i:                                        ; preds = %if.end.i
  %backing.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.014, i64 0, i32 30
  %14 = load ptr, ptr %backing.i, align 8
  %tobool6.not.i = icmp eq ptr %14, null
  %file12.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs.addr.014, i64 0, i32 31
  %15 = load ptr, ptr %file12.i, align 8
  %tobool13.not.i = icmp eq ptr %15, null
  br i1 %tobool6.not.i, label %cond.end.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end5.i
  br i1 %tobool13.not.i, label %if.end15.i, label %if.else.i

if.else.i:                                        ; preds = %land.lhs.true.i, %land.lhs.true.i.us
  tail call void @__assert_fail(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 8460, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

cond.end.i:                                       ; preds = %if.end5.i
  br i1 %tobool13.not.i, label %lor.lhs.false, label %if.end15.i

if.end15.i:                                       ; preds = %cond.end.i, %land.lhs.true.i
  %cond12.i = phi ptr [ %15, %cond.end.i ], [ %14, %land.lhs.true.i ]
  %role.i = getelementptr inbounds %struct.BdrvChild, ptr %cond12.i, i64 0, i32 3
  %16 = load i32, ptr %role.i, align 8
  %and.i = and i32 %16, 4
  %tobool16.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool16.not.i, label %if.else18.i, label %if.end11

if.else18.i:                                      ; preds = %if.end15.i, %if.end15.i.us
  tail call void @__assert_fail(ptr noundef nonnull @.str.153, ptr noundef nonnull @.str.2, i32 noundef 8467, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_filter_child) #31
  unreachable

if.then5:                                         ; preds = %if.end11
  %.pre.pre = load ptr, ptr inttoptr (i64 16 to ptr), align 16
  %tobool6.not = icmp eq ptr %.pre.pre, null
  br i1 %tobool6.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.i, %cond.end.i, %if.end.i.us, %cond.end.i.us, %if.then5
  %.us-phi27 = phi ptr [ null, %if.then5 ], [ %bs.addr.0.us17, %cond.end.i.us ], [ %bs.addr.0.us17, %if.end.i.us ], [ %bs.addr.014, %cond.end.i ], [ %bs.addr.014, %if.end.i ]
  %17 = phi ptr [ %.pre.pre, %if.then5 ], [ %2, %cond.end.i.us ], [ %2, %if.end.i.us ], [ %11, %cond.end.i ], [ %11, %if.end.i ]
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %17, i64 0, i32 2
  %18 = load i8, ptr %is_filter, align 4
  %19 = and i8 %18, 1
  %tobool8.not = icmp eq i8 %19, 0
  br i1 %tobool8.not, label %return, label %if.else

if.else:                                          ; preds = %lor.lhs.false
  tail call void @__assert_fail(ptr noundef nonnull @.str.291, ptr noundef nonnull @.str.2, i32 noundef 8532, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_skip_filters) #31
  unreachable

if.end11:                                         ; preds = %if.end15.i
  %20 = load ptr, ptr %cond12.i, align 8
  %tobool.not.i = icmp eq ptr %20, null
  br i1 %tobool.not.i, label %if.then5, label %lor.lhs.false.i, !llvm.loop !94

return:                                           ; preds = %lor.lhs.false.i, %lor.lhs.false.i.us, %if.end11.us, %while.cond.preheader.split.us, %if.then5, %lor.lhs.false, %entry
  %retval.0 = phi ptr [ null, %entry ], [ %.us-phi27, %lor.lhs.false ], [ null, %if.then5 ], [ %bs, %while.cond.preheader.split.us ], [ %bs.addr.0.us17, %lor.lhs.false.i.us ], [ %8, %if.end11.us ], [ %bs.addr.014, %lor.lhs.false.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_bsc_is_data(ptr nocapture noundef readonly %bs, i64 noundef %offset, ptr noundef writeonly %pnum) local_unnamed_addr #4 {
entry:
  %call.i.i = tail call ptr @get_ptr_rcu_reader() #29
  %depth.i.i = getelementptr inbounds %struct.rcu_reader_data, ptr %call.i.i, i64 0, i32 2
  %0 = load i32, ptr %depth.i.i, align 4
  %inc.i.i = add i32 %0, 1
  store i32 %inc.i.i, ptr %depth.i.i, align 4
  %cmp.not.i.i = icmp eq i32 %0, 0
  br i1 %cmp.not.i.i, label %while.end.i.i, label %rcu_read_auto_lock.exit

while.end.i.i:                                    ; preds = %entry
  %1 = load atomic i64, ptr @rcu_gp_ctr monotonic, align 8
  %conv8.i.i = and i64 %1, 4294967295
  store atomic i64 %conv8.i.i, ptr %call.i.i monotonic, align 8
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !95
  fence seq_cst
  br label %rcu_read_auto_lock.exit

rcu_read_auto_lock.exit:                          ; preds = %entry, %while.end.i.i
  %block_status_cache.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 55
  %2 = load atomic i64, ptr %block_status_cache.i monotonic, align 8
  %3 = inttoptr i64 %2 to ptr
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !96
  %valid.i = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %3, i64 0, i32 1
  %4 = load atomic i8, ptr %valid.i monotonic, align 8
  %5 = and i8 %4, 1
  %tobool.not.i = icmp eq i8 %5, 0
  br i1 %tobool.not.i, label %if.then.i.i, label %land.end.i

land.end.i:                                       ; preds = %rcu_read_auto_lock.exit
  %data_start.i = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %3, i64 0, i32 2
  %6 = load i64, ptr %data_start.i, align 8
  %data_end.i = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %3, i64 0, i32 3
  %7 = load i64, ptr %data_end.i, align 8
  %sub.i4.i.i = add i64 %7, -1
  %cmp.i.i = icmp uge i64 %sub.i4.i.i, %offset
  %cmp2.i.i = icmp ule i64 %6, %offset
  %.not.i.i = and i1 %cmp2.i.i, %cmp.i.i
  %tobool12.i = icmp ne ptr %pnum, null
  %or.cond.i = and i1 %tobool12.i, %.not.i.i
  br i1 %or.cond.i, label %if.then.i, label %if.then.i.i

if.then.i:                                        ; preds = %land.end.i
  %sub14.i = sub i64 %7, %offset
  store i64 %sub14.i, ptr %pnum, align 8
  br label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then.i, %land.end.i, %rcu_read_auto_lock.exit
  %8 = phi i1 [ true, %if.then.i ], [ %.not.i.i, %land.end.i ], [ false, %rcu_read_auto_lock.exit ]
  %call.i.i.i.i = tail call ptr @get_ptr_rcu_reader() #29
  %depth.i.i.i.i = getelementptr inbounds %struct.rcu_reader_data, ptr %call.i.i.i.i, i64 0, i32 2
  %9 = load i32, ptr %depth.i.i.i.i, align 4
  %cmp.not.i.i.i.i = icmp eq i32 %9, 0
  br i1 %cmp.not.i.i.i.i, label %if.else.i.i.i.i, label %if.end.i.i.i.i

if.else.i.i.i.i:                                  ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.293, ptr noundef nonnull @.str.292, i32 noundef 101, ptr noundef nonnull @__PRETTY_FUNCTION__.rcu_read_unlock) #31
  unreachable

if.end.i.i.i.i:                                   ; preds = %if.then.i.i
  %dec.i.i.i.i = add i32 %9, -1
  store i32 %dec.i.i.i.i, ptr %depth.i.i.i.i, align 4
  %cmp2.not.i.i.i.i = icmp eq i32 %dec.i.i.i.i, 0
  br i1 %cmp2.not.i.i.i.i, label %while.end.i.i.i.i, label %glib_autoptr_cleanup_RCUReadAuto.exit

while.end.i.i.i.i:                                ; preds = %if.end.i.i.i.i
  store atomic i64 0, ptr %call.i.i.i.i release, align 8
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !97
  fence seq_cst
  %waiting.i.i.i.i = getelementptr inbounds %struct.rcu_reader_data, ptr %call.i.i.i.i, i64 0, i32 1
  %10 = load atomic i8, ptr %waiting.i.i.i.i monotonic, align 8
  %11 = and i8 %10, 1
  %tobool.not.i.i.i.i = icmp eq i8 %11, 0
  br i1 %tobool.not.i.i.i.i, label %glib_autoptr_cleanup_RCUReadAuto.exit, label %while.end21.i.i.i.i

while.end21.i.i.i.i:                              ; preds = %while.end.i.i.i.i
  store atomic i8 0, ptr %waiting.i.i.i.i monotonic, align 8
  tail call void @qemu_event_set(ptr noundef nonnull @rcu_gp_event) #29
  br label %glib_autoptr_cleanup_RCUReadAuto.exit

glib_autoptr_cleanup_RCUReadAuto.exit:            ; preds = %if.end.i.i.i.i, %while.end.i.i.i.i, %while.end21.i.i.i.i
  ret i1 %8
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_bsc_invalidate_range(ptr nocapture noundef readonly %bs, i64 noundef %offset, i64 noundef %bytes) local_unnamed_addr #4 {
entry:
  %call.i.i = tail call ptr @get_ptr_rcu_reader() #29
  %depth.i.i = getelementptr inbounds %struct.rcu_reader_data, ptr %call.i.i, i64 0, i32 2
  %0 = load i32, ptr %depth.i.i, align 4
  %inc.i.i = add i32 %0, 1
  store i32 %inc.i.i, ptr %depth.i.i, align 4
  %cmp.not.i.i = icmp eq i32 %0, 0
  br i1 %cmp.not.i.i, label %while.end.i.i, label %rcu_read_auto_lock.exit

while.end.i.i:                                    ; preds = %entry
  %1 = load atomic i64, ptr @rcu_gp_ctr monotonic, align 8
  %conv8.i.i = and i64 %1, 4294967295
  store atomic i64 %conv8.i.i, ptr %call.i.i monotonic, align 8
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !95
  fence seq_cst
  br label %rcu_read_auto_lock.exit

rcu_read_auto_lock.exit:                          ; preds = %entry, %while.end.i.i
  %block_status_cache.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 55
  %2 = load atomic i64, ptr %block_status_cache.i monotonic, align 8
  %3 = inttoptr i64 %2 to ptr
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !96
  %valid.i = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %3, i64 0, i32 1
  %4 = load atomic i8, ptr %valid.i monotonic, align 8
  %5 = and i8 %4, 1
  %tobool.not.i = icmp eq i8 %5, 0
  br i1 %tobool.not.i, label %if.then.i.i, label %bdrv_bsc_range_overlaps_locked.exit

bdrv_bsc_range_overlaps_locked.exit:              ; preds = %rcu_read_auto_lock.exit
  %data_start.i = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %3, i64 0, i32 2
  %6 = load i64, ptr %data_start.i, align 8
  %data_end.i = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %3, i64 0, i32 3
  %7 = load i64, ptr %data_end.i, align 8
  %add.i.i.i = add i64 %offset, -1
  %sub.i.i.i = add i64 %add.i.i.i, %bytes
  %sub.i4.i.i = add i64 %7, -1
  %cmp.i.i = icmp uge i64 %sub.i4.i.i, %offset
  %cmp2.i.i = icmp uge i64 %sub.i.i.i, %6
  %.not.i.i = and i1 %cmp2.i.i, %cmp.i.i
  br i1 %.not.i.i, label %while.end, label %if.then.i.i

while.end:                                        ; preds = %bdrv_bsc_range_overlaps_locked.exit
  %8 = load ptr, ptr %block_status_cache.i, align 8
  %valid = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %8, i64 0, i32 1
  store atomic i8 0, ptr %valid monotonic, align 8
  br label %if.then.i.i

if.then.i.i:                                      ; preds = %rcu_read_auto_lock.exit, %bdrv_bsc_range_overlaps_locked.exit, %while.end
  %call.i.i.i.i = tail call ptr @get_ptr_rcu_reader() #29
  %depth.i.i.i.i = getelementptr inbounds %struct.rcu_reader_data, ptr %call.i.i.i.i, i64 0, i32 2
  %9 = load i32, ptr %depth.i.i.i.i, align 4
  %cmp.not.i.i.i.i = icmp eq i32 %9, 0
  br i1 %cmp.not.i.i.i.i, label %if.else.i.i.i.i, label %if.end.i.i.i.i

if.else.i.i.i.i:                                  ; preds = %if.then.i.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.293, ptr noundef nonnull @.str.292, i32 noundef 101, ptr noundef nonnull @__PRETTY_FUNCTION__.rcu_read_unlock) #31
  unreachable

if.end.i.i.i.i:                                   ; preds = %if.then.i.i
  %dec.i.i.i.i = add i32 %9, -1
  store i32 %dec.i.i.i.i, ptr %depth.i.i.i.i, align 4
  %cmp2.not.i.i.i.i = icmp eq i32 %dec.i.i.i.i, 0
  br i1 %cmp2.not.i.i.i.i, label %while.end.i.i.i.i, label %glib_autoptr_cleanup_RCUReadAuto.exit

while.end.i.i.i.i:                                ; preds = %if.end.i.i.i.i
  store atomic i64 0, ptr %call.i.i.i.i release, align 8
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !97
  fence seq_cst
  %waiting.i.i.i.i = getelementptr inbounds %struct.rcu_reader_data, ptr %call.i.i.i.i, i64 0, i32 1
  %10 = load atomic i8, ptr %waiting.i.i.i.i monotonic, align 8
  %11 = and i8 %10, 1
  %tobool.not.i.i.i.i = icmp eq i8 %11, 0
  br i1 %tobool.not.i.i.i.i, label %glib_autoptr_cleanup_RCUReadAuto.exit, label %while.end21.i.i.i.i

while.end21.i.i.i.i:                              ; preds = %while.end.i.i.i.i
  store atomic i8 0, ptr %waiting.i.i.i.i monotonic, align 8
  tail call void @qemu_event_set(ptr noundef nonnull @rcu_gp_event) #29
  br label %glib_autoptr_cleanup_RCUReadAuto.exit

glib_autoptr_cleanup_RCUReadAuto.exit:            ; preds = %if.end.i.i.i.i, %while.end.i.i.i.i, %while.end21.i.i.i.i
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_bsc_fill(ptr noundef %bs, i64 noundef %offset, i64 noundef %bytes) local_unnamed_addr #4 {
entry:
  %call = tail call noalias dereferenceable_or_null(40) ptr @g_malloc_n(i64 noundef 1, i64 noundef 40) #32
  %add = add i64 %bytes, %offset
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %call, i8 0, i64 16, i1 false)
  %.compoundliteral.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 16
  store i8 1, ptr %.compoundliteral.sroa.2.0..sroa_idx, align 8
  %.compoundliteral.sroa.31.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 24
  store i64 %offset, ptr %.compoundliteral.sroa.31.0..sroa_idx, align 8
  %.compoundliteral.sroa.4.0..sroa_idx = getelementptr inbounds i8, ptr %call, i64 32
  store i64 %add, ptr %.compoundliteral.sroa.4.0..sroa_idx, align 8
  %bsc_modify_lock = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 54
  tail call void @qemu_co_mutex_lock(ptr noundef nonnull %bsc_modify_lock) #29
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 55
  %0 = load atomic i64, ptr %block_status_cache monotonic, align 8
  tail call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #29, !srcloc !98
  %1 = ptrtoint ptr %call to i64
  store atomic i64 %1, ptr %block_status_cache release, align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %glib_autoptr_cleanup_QemuLockable.exit, label %if.then

if.then:                                          ; preds = %entry
  %2 = inttoptr i64 %0 to ptr
  tail call void @call_rcu1(ptr noundef nonnull %2, ptr noundef nonnull @g_free) #29
  br label %glib_autoptr_cleanup_QemuLockable.exit

glib_autoptr_cleanup_QemuLockable.exit:           ; preds = %if.then, %entry
  tail call void @qemu_co_mutex_unlock(ptr noundef nonnull %bsc_modify_lock) #29
  ret void
}

declare void @qemu_co_mutex_lock(ptr noundef) #5

declare void @qemu_co_mutex_unlock(ptr noundef) #5

declare void @call_rcu1(ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare i32 @getpagesize() local_unnamed_addr #13

declare noalias ptr @g_strconcat(ptr noundef, ...) local_unnamed_addr #5

declare i32 @blk_co_truncate(ptr noundef, i64 noundef, i1 noundef zeroext, i32 noundef, i32 noundef, ptr noundef) #5

declare i64 @blk_co_getlength(ptr noundef) #5

declare i32 @blk_co_pwrite_zeroes(ptr noundef, i64 noundef, i64 noundef, i32 noundef) #5

declare void @qobject_destroy(ptr noundef) local_unnamed_addr #5

declare void @qdict_copy_default(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @assert_bdrv_graph_writable() local_unnamed_addr #5

declare void @bdrv_do_drained_begin_quiesce(ptr noundef, ptr noundef) local_unnamed_addr #5

declare zeroext i1 @bdrv_drain_poll(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

declare i32 @bdrv_change_backing_file(ptr noundef, ptr noundef, ptr noundef, i1 noundef zeroext) #5

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc0(i64 noundef) local_unnamed_addr #6

declare ptr @id_generate(i32 noundef) local_unnamed_addr #5

declare zeroext i1 @id_wellformed(ptr noundef) local_unnamed_addr #5

declare void @tran_add(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_set_perm_abort(ptr nocapture noundef readonly %opaque) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2314, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_set_perm_abort) #31
  unreachable

do.end:                                           ; preds = %entry
  %old_perm = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %opaque, i64 0, i32 1
  %0 = load i64, ptr %old_perm, align 8
  %1 = load ptr, ptr %opaque, align 8
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %1, i64 0, i32 5
  store i64 %0, ptr %perm, align 8
  %old_shared_perm = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %opaque, i64 0, i32 2
  %2 = load i64, ptr %old_shared_perm, align 8
  %3 = load ptr, ptr %opaque, align 8
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %3, i64 0, i32 6
  store i64 %2, ptr %shared_perm, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_topological_dfs(ptr noundef %list, ptr noundef %found, ptr noundef %bs) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2285, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_topological_dfs) #31
  unreachable

do.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %found, null
  br i1 %tobool.not, label %if.then1, label %if.end7

if.then1:                                         ; preds = %do.end
  %tobool2.not = icmp eq ptr %list, null
  br i1 %tobool2.not, label %if.end5, label %if.else4

if.else4:                                         ; preds = %if.then1
  tail call void @__assert_fail(ptr noundef nonnull @.str.188, ptr noundef nonnull @.str.2, i32 noundef 2288, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_topological_dfs) #31
  unreachable

if.end5:                                          ; preds = %if.then1
  %call6 = tail call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  br label %if.end7

if.end7:                                          ; preds = %if.end5, %do.end
  %local_found.0 = phi ptr [ %call6, %if.end5 ], [ null, %do.end ]
  %found.addr.0 = phi ptr [ %call6, %if.end5 ], [ %found, %do.end ]
  %call8 = tail call i32 @g_hash_table_contains(ptr noundef %found.addr.0, ptr noundef %bs) #29
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %if.end11, label %cleanup

if.end11:                                         ; preds = %if.end7
  %call12 = tail call i32 @g_hash_table_add(ptr noundef %found.addr.0, ptr noundef %bs) #29
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %child.012 = load ptr, ptr %children, align 8
  %tobool13.not13 = icmp eq ptr %child.012, null
  br i1 %tobool13.not13, label %for.end, label %for.body

for.body:                                         ; preds = %if.end11, %for.body
  %child.015 = phi ptr [ %child.0, %for.body ], [ %child.012, %if.end11 ]
  %list.addr.014 = phi ptr [ %call15, %for.body ], [ %list, %if.end11 ]
  %0 = load ptr, ptr %child.015, align 8
  %call15 = tail call fastcc ptr @bdrv_topological_dfs(ptr noundef %list.addr.014, ptr noundef %found.addr.0, ptr noundef %0)
  %next = getelementptr inbounds %struct.BdrvChild, ptr %child.015, i64 0, i32 9
  %child.0 = load ptr, ptr %next, align 8
  %tobool13.not = icmp eq ptr %child.0, null
  br i1 %tobool13.not, label %for.end, label %for.body, !llvm.loop !99

for.end:                                          ; preds = %for.body, %if.end11
  %list.addr.0.lcssa = phi ptr [ %list, %if.end11 ], [ %call15, %for.body ]
  %call16 = tail call ptr @g_slist_prepend(ptr noundef %list.addr.0.lcssa, ptr noundef %bs) #29
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %for.end
  %retval.0 = phi ptr [ %call16, %for.end ], [ %list, %if.end7 ]
  %tobool.not.i.i = icmp eq ptr %local_found.0, null
  br i1 %tobool.not.i.i, label %glib_autoptr_cleanup_GHashTable.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %cleanup
  tail call void @g_hash_table_unref(ptr noundef nonnull %local_found.0) #29
  br label %glib_autoptr_cleanup_GHashTable.exit

glib_autoptr_cleanup_GHashTable.exit:             ; preds = %cleanup, %if.then.i.i
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_do_refresh_perms(ptr noundef readonly %list, ptr noundef %q, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %cur_perm.i = alloca i64, align 8
  %cur_shared.i = alloca i64, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %for.cond.preheader, label %if.else

for.cond.preheader:                               ; preds = %entry
  %tobool.not51 = icmp eq ptr %list, null
  br i1 %tobool.not51, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %cmp.not.i.i.i14 = icmp eq ptr %q, null
  %tobool12.not.i.i = icmp eq ptr %tran, null
  br label %for.body

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2573, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_refresh_perms) #31
  unreachable

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %list.addr.052 = phi ptr [ %list, %for.body.lr.ph ], [ %39, %for.inc ]
  %0 = load ptr, ptr %list.addr.052, align 8
  %call.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %do.end.i, label %if.else.i

if.else.i:                                        ; preds = %for.body
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2228, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parent_perms_conflict) #31
  unreachable

do.end.i:                                         ; preds = %for.body
  %parents.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 32
  %a.019.i = load ptr, ptr %parents.i, align 8
  %tobool.not20.not.i = icmp eq ptr %a.019.i, null
  br i1 %tobool.not20.not.i, label %if.end3, label %for.cond3.preheader.i

for.cond3.preheaderthread-pre-split.i:            ; preds = %for.inc11.i
  %b.016.pr.i = load ptr, ptr %parents.i, align 8
  br label %for.cond3.preheader.i

for.cond3.preheader.i:                            ; preds = %do.end.i, %for.cond3.preheaderthread-pre-split.i
  %b.016.i = phi ptr [ %b.016.pr.i, %for.cond3.preheaderthread-pre-split.i ], [ %a.019.i, %do.end.i ]
  %a.021.i = phi ptr [ %a.0.i, %for.cond3.preheaderthread-pre-split.i ], [ %a.019.i, %do.end.i ]
  %tobool4.not17.i = icmp eq ptr %b.016.i, null
  br i1 %tobool4.not17.i, label %for.inc11.i, label %for.body5.lr.ph.i

for.body5.lr.ph.i:                                ; preds = %for.cond3.preheader.i
  %shared_perm.i.i = getelementptr inbounds %struct.BdrvChild, ptr %a.021.i, i64 0, i32 6
  br label %for.body5.i

for.body5.i:                                      ; preds = %for.inc.i, %for.body5.lr.ph.i
  %b.018.i = phi ptr [ %b.016.i, %for.body5.lr.ph.i ], [ %b.0.i, %for.inc.i ]
  %cmp.i = icmp eq ptr %a.021.i, %b.018.i
  br i1 %cmp.i, label %for.inc.i, label %if.end7.i

if.end7.i:                                        ; preds = %for.body5.i
  %1 = load ptr, ptr %a.021.i, align 8
  %tobool.not.i.i = icmp eq ptr %1, null
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.end.i.i

if.else.i.i:                                      ; preds = %if.end7.i
  call void @__assert_fail(ptr noundef nonnull @.str.189, ptr noundef nonnull @.str.2, i32 noundef 2201, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_a_allow_b) #31
  unreachable

if.end.i.i:                                       ; preds = %if.end7.i
  %2 = load ptr, ptr %b.018.i, align 8
  %cmp.i.i = icmp eq ptr %1, %2
  br i1 %cmp.i.i, label %do.body.i.i, label %if.else4.i.i

if.else4.i.i:                                     ; preds = %if.end.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.190, ptr noundef nonnull @.str.2, i32 noundef 2202, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_a_allow_b) #31
  unreachable

do.body.i.i:                                      ; preds = %if.end.i.i
  %call.i.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %do.end.i.i, label %if.else7.i.i

if.else7.i.i:                                     ; preds = %do.body.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2203, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_a_allow_b) #31
  unreachable

do.end.i.i:                                       ; preds = %do.body.i.i
  %perm.i.i = getelementptr inbounds %struct.BdrvChild, ptr %b.018.i, i64 0, i32 5
  %3 = load i64, ptr %perm.i.i, align 8
  %4 = load i64, ptr %shared_perm.i.i, align 8
  %and.i.i = and i64 %4, %3
  %cmp10.i.i = icmp eq i64 %and.i.i, %3
  br i1 %cmp10.i.i, label %for.inc.critedge.i, label %if.end12.i.i

if.end12.i.i:                                     ; preds = %do.end.i.i
  %perm.i.i.le = getelementptr inbounds %struct.BdrvChild, ptr %b.018.i, i64 0, i32 5
  %name21.i.le.i = getelementptr inbounds %struct.BdrvChild, ptr %a.021.i, i64 0, i32 1
  %5 = load ptr, ptr %b.018.i, align 8
  %node_name.i.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %5, i64 0, i32 22
  %call.i.i.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i.i, label %bdrv_child_user_desc.exit.i.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %if.end12.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2186, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_user_desc) #31
  unreachable

bdrv_child_user_desc.exit.i.i:                    ; preds = %if.end12.i.i
  %klass.i.i.le.i = getelementptr inbounds %struct.BdrvChild, ptr %a.021.i, i64 0, i32 2
  %6 = load ptr, ptr %klass.i.i.le.i, align 8
  %get_parent_desc.i.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %6, i64 0, i32 4
  %7 = load ptr, ptr %get_parent_desc.i.i.i, align 8
  %call1.i.i.i = call ptr %7(ptr noundef nonnull %a.021.i) #29
  %call.i14.i.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i14.i.i, label %bdrv_child_user_desc.exit19.i.i, label %if.else.i15.i.i

if.else.i15.i.i:                                  ; preds = %bdrv_child_user_desc.exit.i.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2186, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_user_desc) #31
  unreachable

bdrv_child_user_desc.exit19.i.i:                  ; preds = %bdrv_child_user_desc.exit.i.i
  %klass.i16.i.i = getelementptr inbounds %struct.BdrvChild, ptr %b.018.i, i64 0, i32 2
  %8 = load ptr, ptr %klass.i16.i.i, align 8
  %get_parent_desc.i17.i.i = getelementptr inbounds %struct.BdrvChildClass, ptr %8, i64 0, i32 4
  %9 = load ptr, ptr %get_parent_desc.i17.i.i, align 8
  %call1.i18.i.i = call ptr %9(ptr noundef nonnull %b.018.i) #29
  %10 = load i64, ptr %perm.i.i.le, align 8
  %11 = load i64, ptr %shared_perm.i.i, align 8
  %not.i.i = xor i64 %11, -1
  %and19.i.i = and i64 %10, %not.i.i
  %call.i20.i.i = call ptr @g_string_sized_new(i64 noundef 30) #29
  %len.i.i.i = getelementptr inbounds %struct._GString, ptr %call.i20.i.i, i64 0, i32 1
  br label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %for.inc.i.i.i, %bdrv_child_user_desc.exit19.i.i
  %12 = phi ptr [ @.str.66, %bdrv_child_user_desc.exit19.i.i ], [ %15, %for.inc.i.i.i ]
  %p.07.i.i.i = phi ptr [ @__const.bdrv_perm_names.permissions, %bdrv_child_user_desc.exit19.i.i ], [ %incdec.ptr.i.i.i, %for.inc.i.i.i ]
  %13 = load i64, ptr %p.07.i.i.i, align 8
  %and.i.i.i = and i64 %and19.i.i, %13
  %tobool2.not.i.i.i = icmp eq i64 %and.i.i.i, 0
  br i1 %tobool2.not.i.i.i, label %for.inc.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %for.body.i.i.i
  %14 = load i64, ptr %len.i.i.i, align 8
  %cmp.not.i.i.i = icmp eq i64 %14, 0
  br i1 %cmp.not.i.i.i, label %if.end.i.i.i, label %if.then3.i.i.i

if.then3.i.i.i:                                   ; preds = %if.then.i.i.i
  %call4.i.i.i = call ptr @g_string_append(ptr noundef nonnull %call.i20.i.i, ptr noundef nonnull @.str.70) #29
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then3.i.i.i, %if.then.i.i.i
  %call6.i.i.i = call ptr @g_string_append(ptr noundef nonnull %call.i20.i.i, ptr noundef nonnull %12) #29
  br label %for.inc.i.i.i

for.inc.i.i.i:                                    ; preds = %if.end.i.i.i, %for.body.i.i.i
  %incdec.ptr.i.i.i = getelementptr %struct.perm_name, ptr %p.07.i.i.i, i64 1
  %name.i.i.i = getelementptr %struct.perm_name, ptr %p.07.i.i.i, i64 1, i32 1
  %15 = load ptr, ptr %name.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %15, null
  br i1 %tobool.not.i.i.i, label %bdrv_parent_perms_conflict.exit, label %for.body.i.i.i, !llvm.loop !23

for.inc.critedge.i:                               ; preds = %do.end.i.i
  call void @g_free(ptr noundef null) #29
  call void @g_free(ptr noundef null) #29
  call void @g_free(ptr noundef null) #29
  br label %for.inc.i

for.inc.i:                                        ; preds = %for.inc.critedge.i, %for.body5.i
  %next_parent.i = getelementptr inbounds %struct.BdrvChild, ptr %b.018.i, i64 0, i32 10
  %b.0.i = load ptr, ptr %next_parent.i, align 8
  %tobool4.not.i = icmp eq ptr %b.0.i, null
  br i1 %tobool4.not.i, label %for.inc11.i, label %for.body5.i, !llvm.loop !100

for.inc11.i:                                      ; preds = %for.inc.i, %for.cond3.preheader.i
  %next_parent12.i = getelementptr inbounds %struct.BdrvChild, ptr %a.021.i, i64 0, i32 10
  %a.0.i = load ptr, ptr %next_parent12.i, align 8
  %tobool.not.not.i = icmp eq ptr %a.0.i, null
  br i1 %tobool.not.not.i, label %if.end3, label %for.cond3.preheaderthread-pre-split.i, !llvm.loop !101

bdrv_parent_perms_conflict.exit:                  ; preds = %for.inc.i.i.i
  %call8.i.i.i = call ptr @g_string_free(ptr noundef %call.i20.i.i, i32 noundef 0) #29
  %name.i.i = getelementptr inbounds %struct.BdrvChild, ptr %b.018.i, i64 0, i32 1
  %16 = load ptr, ptr %name.i.i, align 8
  %17 = load ptr, ptr %name21.i.le.i, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 2219, ptr noundef nonnull @__func__.bdrv_a_allow_b, ptr noundef nonnull @.str.191, ptr noundef nonnull %node_name.i.i.i, ptr noundef %call8.i.i.i, ptr noundef %call1.i18.i.i, ptr noundef nonnull %node_name.i.i.i, ptr noundef %16, ptr noundef %call1.i.i.i, ptr noundef nonnull %node_name.i.i.i, ptr noundef %17) #29
  call void @g_free(ptr noundef %call8.i.i.i) #29
  call void @g_free(ptr noundef %call1.i18.i.i) #29
  call void @g_free(ptr noundef %call1.i.i.i) #29
  br label %return

if.end3:                                          ; preds = %for.inc11.i, %do.end.i
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %cur_perm.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %cur_shared.i)
  %drv1.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 6
  %18 = load ptr, ptr %drv1.i, align 8
  %call.i6 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i6, label %do.end.i8, label %if.else.i7

if.else.i7:                                       ; preds = %if.end3
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2496, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_node_refresh_perm) #31
  unreachable

do.end.i8:                                        ; preds = %if.end3
  %call.i.i9 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i9, label %do.end.i.i11, label %if.else.i.i10

if.else.i.i10:                                    ; preds = %do.end.i8
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2620, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #31
  unreachable

do.end.i.i11:                                     ; preds = %do.end.i8
  %c.06.i.i = load ptr, ptr %parents.i, align 8
  %tobool.not7.i.i = icmp eq ptr %c.06.i.i, null
  br i1 %tobool.not7.i.i, label %if.end19.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %do.end.i.i11, %for.body.i.i
  %c.010.i.i = phi ptr [ %c.0.i.i, %for.body.i.i ], [ %c.06.i.i, %do.end.i.i11 ]
  %cumulative_shared_perms.09.i.i = phi i64 [ %and.i.i12, %for.body.i.i ], [ 15, %do.end.i.i11 ]
  %cumulative_perms.08.i.i = phi i64 [ %or.i.i, %for.body.i.i ], [ 0, %do.end.i.i11 ]
  %perm1.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i.i, i64 0, i32 5
  %19 = load i64, ptr %perm1.i.i, align 8
  %or.i.i = or i64 %19, %cumulative_perms.08.i.i
  %shared_perm2.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i.i, i64 0, i32 6
  %20 = load i64, ptr %shared_perm2.i.i, align 8
  %and.i.i12 = and i64 %20, %cumulative_shared_perms.09.i.i
  %next_parent.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.010.i.i, i64 0, i32 10
  %c.0.i.i = load ptr, ptr %next_parent.i.i, align 8
  %tobool.not.i.i13 = icmp eq ptr %c.0.i.i, null
  br i1 %tobool.not.i.i13, label %bdrv_get_cumulative_perm.exit.i, label %for.body.i.i, !llvm.loop !22

bdrv_get_cumulative_perm.exit.i:                  ; preds = %for.body.i.i
  %and.i = and i64 %or.i.i, 6
  %tobool.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool.not.i, label %if.end19.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %bdrv_get_cumulative_perm.exit.i
  br i1 %cmp.not.i.i.i14, label %bdrv_is_writable_after_reopen.exit.i, label %for.cond.preheader.i.i.i

for.cond.preheader.i.i.i:                         ; preds = %land.lhs.true.i
  %entry1.07.i.i.i = load ptr, ptr %q, align 8
  %tobool.not8.i.i.i = icmp eq ptr %entry1.07.i.i.i, null
  br i1 %tobool.not8.i.i.i, label %bdrv_is_writable_after_reopen.exit.i, label %for.body.i.i.i15

for.body.i.i.i15:                                 ; preds = %for.cond.preheader.i.i.i, %for.inc.i.i.i16
  %entry1.09.i.i.i = phi ptr [ %entry1.0.i.i.i, %for.inc.i.i.i16 ], [ %entry1.07.i.i.i, %for.cond.preheader.i.i.i ]
  %state.i.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i.i, i64 0, i32 1
  %21 = load ptr, ptr %state.i.i.i, align 8
  %cmp3.i.i.i = icmp eq ptr %21, %0
  br i1 %cmp3.i.i.i, label %if.then4.i.i.i, label %for.inc.i.i.i16

if.then4.i.i.i:                                   ; preds = %for.body.i.i.i15
  %flags.i.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i.i, i64 0, i32 1, i32 1
  br label %bdrv_is_writable_after_reopen.exit.i

for.inc.i.i.i16:                                  ; preds = %for.body.i.i.i15
  %entry6.i.i.i = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %entry1.09.i.i.i, i64 0, i32 2
  %entry1.0.i.i.i = load ptr, ptr %entry6.i.i.i, align 8
  %tobool.not.i.i.i17 = icmp eq ptr %entry1.0.i.i.i, null
  br i1 %tobool.not.i.i.i17, label %bdrv_is_writable_after_reopen.exit.i, label %for.body.i.i.i15, !llvm.loop !24

bdrv_is_writable_after_reopen.exit.i:             ; preds = %for.inc.i.i.i16, %if.then4.i.i.i, %for.cond.preheader.i.i.i, %land.lhs.true.i
  %retval.0.in.i.i.i = phi ptr [ %flags.i.i.i, %if.then4.i.i.i ], [ %0, %land.lhs.true.i ], [ %0, %for.cond.preheader.i.i.i ], [ %0, %for.inc.i.i.i16 ]
  %retval.0.i.i.i = load i32, ptr %retval.0.in.i.i.i, align 8
  %and.i23.i = and i32 %retval.0.i.i.i, 2050
  %cmp.i.i18 = icmp eq i32 %and.i23.i, 2
  br i1 %cmp.i.i18, label %if.end9.i, label %if.then3.i

if.then3.i:                                       ; preds = %bdrv_is_writable_after_reopen.exit.i
  %retval.0.i.i25.i = load i32, ptr %0, align 8
  %and.i26.i = and i32 %retval.0.i.i25.i, 2050
  %cmp.i27.i = icmp eq i32 %and.i26.i, 2
  br i1 %cmp.i27.i, label %if.else6.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.then3.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 2505, ptr noundef nonnull @__func__.bdrv_node_refresh_perm, ptr noundef nonnull @.str.192) #29
  br label %bdrv_node_refresh_perm.exit.thread

if.else6.i:                                       ; preds = %if.then3.i
  %node_name.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 22
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 2508, ptr noundef nonnull @__func__.bdrv_node_refresh_perm, ptr noundef nonnull @.str.193, ptr noundef nonnull %node_name.i.i) #29
  br label %bdrv_node_refresh_perm.exit.thread

if.end9.i:                                        ; preds = %bdrv_is_writable_after_reopen.exit.i
  %and13.i = and i64 %or.i.i, 8
  %tobool14.not.i = icmp eq i64 %and13.i, 0
  br i1 %tobool14.not.i, label %if.then15.i, label %if.end19.i

if.then15.i:                                      ; preds = %if.end9.i
  %total_sectors.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 37
  %22 = load i64, ptr %total_sectors.i, align 8
  %mul.i = shl i64 %22, 9
  %bl.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 17
  %23 = load i32, ptr %bl.i, align 8
  %conv.i = zext i32 %23 to i64
  %rem.i = urem i64 %mul.i, %conv.i
  %tobool16.not.i = icmp eq i64 %rem.i, 0
  br i1 %tobool16.not.i, label %if.end19.i, label %if.then17.i

if.then17.i:                                      ; preds = %if.then15.i
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 2525, ptr noundef nonnull @__func__.bdrv_node_refresh_perm, ptr noundef nonnull @.str.194) #29
  br label %bdrv_node_refresh_perm.exit.thread

if.end19.i:                                       ; preds = %if.then15.i, %if.end9.i, %bdrv_get_cumulative_perm.exit.i, %do.end.i.i11
  %cumulative_perms.0.lcssa.i4960.i = phi i64 [ %or.i.i, %if.then15.i ], [ %or.i.i, %if.end9.i ], [ %or.i.i, %bdrv_get_cumulative_perm.exit.i ], [ 0, %do.end.i.i11 ]
  %cumulative_shared_perms.0.lcssa.i5059.i = phi i64 [ %and.i.i12, %if.then15.i ], [ %and.i.i12, %if.end9.i ], [ %and.i.i12, %bdrv_get_cumulative_perm.exit.i ], [ 15, %do.end.i.i11 ]
  %tobool20.not.i = icmp eq ptr %18, null
  br i1 %tobool20.not.i, label %for.inc, label %if.end22.i

if.end22.i:                                       ; preds = %if.end19.i
  %call.i28.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i28.i, label %do.end.i30.i, label %if.else.i29.i

if.else.i29.i:                                    ; preds = %if.end22.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2379, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_drv_set_perm) #31
  unreachable

do.end.i30.i:                                     ; preds = %if.end22.i
  %24 = load ptr, ptr %drv1.i, align 8
  %tobool.not.i31.i = icmp eq ptr %24, null
  br i1 %tobool.not.i31.i, label %if.end26.i, label %if.end2.i.i

if.end2.i.i:                                      ; preds = %do.end.i30.i
  %bdrv_check_perm.i.i = getelementptr inbounds %struct.BlockDriver, ptr %24, i64 0, i32 55
  %25 = load ptr, ptr %bdrv_check_perm.i.i, align 8
  %tobool4.not.i.i = icmp eq ptr %25, null
  br i1 %tobool4.not.i.i, label %if.end11.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.end2.i.i
  %call8.i.i = call i32 %25(ptr noundef nonnull %0, i64 noundef %cumulative_perms.0.lcssa.i4960.i, i64 noundef %cumulative_shared_perms.0.lcssa.i5059.i, ptr noundef %errp) #29
  %cmp.i32.i = icmp slt i32 %call8.i.i, 0
  br i1 %cmp.i32.i, label %bdrv_node_refresh_perm.exit.thread, label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then5.i.i, %if.end2.i.i
  br i1 %tobool12.not.i.i, label %if.end26.i, label %if.then13.i.i

if.then13.i.i:                                    ; preds = %if.end11.i.i
  call void @tran_add(ptr noundef nonnull %tran, ptr noundef nonnull @bdrv_drv_set_perm_drv, ptr noundef nonnull %0) #29
  br label %if.end26.i

if.end26.i:                                       ; preds = %if.then13.i.i, %if.end11.i.i, %do.end.i30.i
  %bdrv_child_perm.i = getelementptr inbounds %struct.BlockDriver, ptr %18, i64 0, i32 58
  %26 = load ptr, ptr %bdrv_child_perm.i, align 8
  %tobool27.not.i = icmp eq ptr %26, null
  %children.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 29
  %27 = load ptr, ptr %children.i, align 8
  %cmp29.i = icmp eq ptr %27, null
  br i1 %tobool27.not.i, label %if.then28.i, label %if.end34.i

if.then28.i:                                      ; preds = %if.end26.i
  br i1 %cmp29.i, label %for.inc, label %if.else32.i

if.else32.i:                                      ; preds = %if.then28.i
  call void @__assert_fail(ptr noundef nonnull @.str.195, ptr noundef nonnull @.str.2, i32 noundef 2543, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_node_refresh_perm) #31
  unreachable

if.end34.i:                                       ; preds = %if.end26.i
  br i1 %cmp29.i, label %for.inc, label %for.body.i

for.body.i:                                       ; preds = %if.end34.i, %bdrv_child_set_perm.exit.i
  %c.066.i = phi ptr [ %c.0.i, %bdrv_child_set_perm.exit.i ], [ %27, %if.end34.i ]
  %28 = load ptr, ptr %c.066.i, align 8
  %role.i = getelementptr inbounds %struct.BdrvChild, ptr %c.066.i, i64 0, i32 3
  %29 = load i32, ptr %role.i, align 8
  %30 = load ptr, ptr %drv1.i, align 8
  %tobool.not.i34.i = icmp eq ptr %30, null
  br i1 %tobool.not.i34.i, label %if.else.i37.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %for.body.i
  %bdrv_child_perm.i.i = getelementptr inbounds %struct.BlockDriver, ptr %30, i64 0, i32 58
  %31 = load ptr, ptr %bdrv_child_perm.i.i, align 8
  %tobool2.not.i.i = icmp eq ptr %31, null
  br i1 %tobool2.not.i.i, label %if.else.i37.i, label %do.body.i.i19

if.else.i37.i:                                    ; preds = %land.lhs.true.i.i, %for.body.i
  call void @__assert_fail(ptr noundef nonnull @.str.196, ptr noundef nonnull @.str.2, i32 noundef 2257, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_perm) #31
  unreachable

do.body.i.i19:                                    ; preds = %land.lhs.true.i.i
  %call.i35.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i35.i, label %do.end.i36.i, label %if.else4.i.i20

if.else4.i.i20:                                   ; preds = %do.body.i.i19
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2258, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_perm) #31
  unreachable

do.end.i36.i:                                     ; preds = %do.body.i.i19
  %32 = load ptr, ptr %drv1.i, align 8
  %bdrv_child_perm7.i.i = getelementptr inbounds %struct.BlockDriver, ptr %32, i64 0, i32 58
  %33 = load ptr, ptr %bdrv_child_perm7.i.i, align 8
  call void %33(ptr noundef nonnull %0, ptr noundef nonnull %c.066.i, i32 noundef %29, ptr noundef %q, i64 noundef %cumulative_perms.0.lcssa.i4960.i, i64 noundef %cumulative_shared_perms.0.lcssa.i5059.i, ptr noundef nonnull %cur_perm.i, ptr noundef nonnull %cur_shared.i) #29
  %tobool8.not.i.i = icmp eq ptr %28, null
  br i1 %tobool8.not.i.i, label %bdrv_child_perm.exit.i, label %land.lhs.true9.i.i

land.lhs.true9.i.i:                               ; preds = %do.end.i36.i
  %force_share.i.i = getelementptr inbounds %struct.BlockDriverState, ptr %28, i64 0, i32 4
  %34 = load i8, ptr %force_share.i.i, align 1
  %35 = and i8 %34, 1
  %tobool10.not.i.i = icmp eq i8 %35, 0
  br i1 %tobool10.not.i.i, label %bdrv_child_perm.exit.i, label %if.then11.i.i

if.then11.i.i:                                    ; preds = %land.lhs.true9.i.i
  store i64 15, ptr %cur_shared.i, align 8
  br label %bdrv_child_perm.exit.i

bdrv_child_perm.exit.i:                           ; preds = %if.then11.i.i, %land.lhs.true9.i.i, %do.end.i36.i
  %36 = load i64, ptr %cur_perm.i, align 8
  %37 = load i64, ptr %cur_shared.i, align 8
  %call.i38.i = call noalias dereferenceable_or_null(24) ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #32
  %call1.i.i = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1.i.i, label %bdrv_child_set_perm.exit.i, label %if.else.i39.i

if.else.i39.i:                                    ; preds = %bdrv_child_perm.exit.i
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2329, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_child_set_perm) #31
  unreachable

bdrv_child_set_perm.exit.i:                       ; preds = %bdrv_child_perm.exit.i
  %perm2.i.i = getelementptr inbounds %struct.BdrvChild, ptr %c.066.i, i64 0, i32 5
  %shared_perm.i.i21 = getelementptr inbounds %struct.BdrvChild, ptr %c.066.i, i64 0, i32 6
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %call.i38.i, i64 8
  %38 = load <2 x i64>, ptr %perm2.i.i, align 8
  store ptr %c.066.i, ptr %call.i38.i, align 8
  store <2 x i64> %38, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 8
  store i64 %36, ptr %perm2.i.i, align 8
  store i64 %37, ptr %shared_perm.i.i21, align 8
  call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_child_set_pem_drv, ptr noundef nonnull %call.i38.i) #29
  %next.i = getelementptr inbounds %struct.BdrvChild, ptr %c.066.i, i64 0, i32 9
  %c.0.i = load ptr, ptr %next.i, align 8
  %tobool37.not.i = icmp eq ptr %c.0.i, null
  br i1 %tobool37.not.i, label %for.inc, label %for.body.i, !llvm.loop !102

bdrv_node_refresh_perm.exit.thread:               ; preds = %if.then5.i.i, %if.then17.i, %if.else6.i, %if.then5.i
  %retval.0.i.ph = phi i32 [ -1, %if.then5.i ], [ -1, %if.else6.i ], [ -1, %if.then17.i ], [ %call8.i.i, %if.then5.i.i ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %cur_perm.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %cur_shared.i)
  br label %return

for.inc:                                          ; preds = %bdrv_child_set_perm.exit.i, %if.end34.i, %if.then28.i, %if.end19.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %cur_perm.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %cur_shared.i)
  %next = getelementptr inbounds %struct._GSList, ptr %list.addr.052, i64 0, i32 1
  %39 = load ptr, ptr %next, align 8
  %tobool.not = icmp eq ptr %39, null
  br i1 %tobool.not, label %return, label %for.body, !llvm.loop !103

return:                                           ; preds = %for.inc, %for.cond.preheader, %bdrv_node_refresh_perm.exit.thread, %bdrv_parent_perms_conflict.exit
  %retval.0 = phi i32 [ -22, %bdrv_parent_perms_conflict.exit ], [ %retval.0.i.ph, %bdrv_node_refresh_perm.exit.thread ], [ 0, %for.cond.preheader ], [ 0, %for.inc ]
  ret i32 %retval.0
}

declare void @g_hash_table_unref(ptr noundef) local_unnamed_addr #5

declare void @bdrv_parent_drained_begin_single(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_attach_child_common_abort(ptr nocapture noundef readonly %opaque) #4 {
entry:
  %0 = load ptr, ptr %opaque, align 8
  %1 = load ptr, ptr %0, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3005, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child_common_abort) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @assert_bdrv_graph_writable() #29
  %2 = load ptr, ptr %opaque, align 8
  tail call fastcc void @bdrv_replace_child_noperm(ptr noundef %2, ptr noundef null)
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %do.end
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %1, i64 0, i32 8
  %3 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %do.end
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %3, %cond.true.i ], [ %call.i, %cond.false.i ]
  %old_child_ctx = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %opaque, i64 0, i32 2
  %4 = load ptr, ptr %old_child_ctx, align 8
  %cmp.not = icmp eq ptr %cond.i, %4
  br i1 %cmp.not, label %if.end7, label %if.then4

if.then4:                                         ; preds = %bdrv_get_aio_context.exit
  %call6 = tail call i32 @bdrv_try_change_aio_context(ptr noundef %1, ptr noundef %4, ptr noundef null, ptr noundef nonnull @error_abort), !range !25
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %bdrv_get_aio_context.exit
  %5 = load ptr, ptr %opaque, align 8
  %klass.i = getelementptr inbounds %struct.BdrvChild, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %klass.i, align 8
  %get_parent_aio_context.i = getelementptr inbounds %struct.BdrvChildClass, ptr %6, i64 0, i32 16
  %7 = load ptr, ptr %get_parent_aio_context.i, align 8
  %call.i14 = tail call ptr %7(ptr noundef %5) #29
  %old_parent_ctx = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %opaque, i64 0, i32 1
  %8 = load ptr, ptr %old_parent_ctx, align 8
  %cmp10.not = icmp eq ptr %call.i14, %8
  br i1 %cmp10.not, label %if.end23, label %if.then11

if.then11:                                        ; preds = %if.end7
  %call12 = tail call ptr @tran_new() #29
  %call13 = tail call ptr @g_hash_table_new(ptr noundef null, ptr noundef null) #29
  %9 = load ptr, ptr %opaque, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %klass, align 8
  %change_aio_ctx = getelementptr inbounds %struct.BdrvChildClass, ptr %10, i64 0, i32 13
  %11 = load ptr, ptr %change_aio_ctx, align 8
  %12 = load ptr, ptr %old_parent_ctx, align 8
  %call17 = tail call zeroext i1 %11(ptr noundef %9, ptr noundef %12, ptr noundef %call13, ptr noundef %call12, ptr noundef nonnull @error_abort) #29
  tail call void @g_hash_table_destroy(ptr noundef %call13) #29
  br i1 %call17, label %if.end22, label %if.else21

if.else21:                                        ; preds = %if.then11
  tail call void @__assert_fail(ptr noundef nonnull @.str.200, ptr noundef nonnull @.str.2, i32 noundef 3028, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_child_common_abort) #31
  unreachable

if.end22:                                         ; preds = %if.then11
  tail call void @tran_commit(ptr noundef %call12) #29
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end7
  br i1 %tobool.not.i, label %bdrv_schedule_unref.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end23
  %call.i16 = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_bh_schedule_oneshot_full(ptr noundef %call.i16, ptr noundef nonnull @bdrv_schedule_unref_bh, ptr noundef nonnull %1, ptr noundef nonnull @.str.105) #29
  br label %bdrv_schedule_unref.exit

bdrv_schedule_unref.exit:                         ; preds = %if.end23, %if.end.i
  %13 = load ptr, ptr %opaque, align 8
  tail call fastcc void @bdrv_child_free(ptr noundef %13)
  ret void
}

; Function Attrs: nofree nosync nounwind sspstrong memory(read, inaccessiblemem: none) uwtable
define internal fastcc zeroext i1 @bdrv_recurse_has_child(ptr noundef readonly %bs, ptr noundef %child) unnamed_addr #22 {
entry:
  %cmp = icmp eq ptr %bs, %child
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 29
  %c.05 = load ptr, ptr %children, align 8
  %tobool.not6 = icmp eq ptr %c.05, null
  br i1 %tobool.not6, label %return, label %for.body

for.cond:                                         ; preds = %for.body
  %next = getelementptr inbounds %struct.BdrvChild, ptr %c.07, i64 0, i32 9
  %c.0 = load ptr, ptr %next, align 8
  %tobool.not = icmp eq ptr %c.0, null
  br i1 %tobool.not, label %return, label %for.body, !llvm.loop !104

for.body:                                         ; preds = %if.end, %for.cond
  %c.07 = phi ptr [ %c.0, %for.cond ], [ %c.05, %if.end ]
  %0 = load ptr, ptr %c.07, align 8
  %call = tail call fastcc zeroext i1 @bdrv_recurse_has_child(ptr noundef %0, ptr noundef %child)
  br i1 %call, label %return, label %for.cond

return:                                           ; preds = %for.body, %for.cond, %if.end, %entry
  %retval.0 = phi i1 [ true, %entry ], [ false, %if.end ], [ %call, %for.cond ], [ %call, %for.body ]
  ret i1 %retval.0
}

declare void @bdrv_parent_drained_end_single(ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @bdrv_set_inherits_from_abort(ptr nocapture noundef readonly %opaque) #23 {
entry:
  %old_inherits_from = getelementptr inbounds %struct.BdrvSetInheritsFrom, ptr %opaque, i64 0, i32 1
  %0 = load ptr, ptr %old_inherits_from, align 8
  %1 = load ptr, ptr %opaque, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %1, i64 0, i32 28
  store ptr %0, ptr %inherits_from, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @bdrv_remove_child(ptr noundef %child, ptr noundef %tran) unnamed_addr #4 {
entry:
  %tobool.not = icmp eq ptr %child, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr %child, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.end
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %child, i64 0, i32 8
  %1 = load i8, ptr %quiesced_parent, align 1
  %2 = and i8 %1, 1
  %tobool3.not = icmp eq i8 %2, 0
  br i1 %tobool3.not, label %if.else, label %if.end5

if.else:                                          ; preds = %if.then2
  tail call void @__assert_fail(ptr noundef nonnull @.str.215, ptr noundef nonnull @.str.2, i32 noundef 5376, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_remove_child) #31
  unreachable

if.end5:                                          ; preds = %if.then2
  %call.i = tail call noalias dereferenceable_or_null(16) ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #32
  %3 = load i8, ptr %quiesced_parent, align 1
  %4 = and i8 %3, 1
  %tobool.not.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i, label %if.else.i, label %bdrv_replace_child_tran.exit

if.else.i:                                        ; preds = %if.end5
  tail call void @__assert_fail(ptr noundef nonnull @.str.215, ptr noundef nonnull @.str.2, i32 noundef 2464, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_tran) #31
  unreachable

bdrv_replace_child_tran.exit:                     ; preds = %if.end5
  %5 = load ptr, ptr %child, align 8
  store ptr %child, ptr %call.i, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.c.i = getelementptr inbounds i8, ptr %call.i, i64 8
  store ptr %5, ptr %.compoundliteral.sroa.2.0..sroa_idx.c.i, align 8
  tail call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_replace_child_drv, ptr noundef nonnull %call.i) #29
  tail call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %child, ptr noundef null)
  br label %if.end6

if.end6:                                          ; preds = %bdrv_replace_child_tran.exit, %if.end
  tail call void @tran_add(ptr noundef %tran, ptr noundef nonnull @bdrv_remove_child_drv, ptr noundef nonnull %child) #29
  br label %return

return:                                           ; preds = %entry, %if.end6
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_remove_child_commit(ptr noundef %opaque) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 5353, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_remove_child_commit) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call fastcc void @bdrv_child_free(ptr noundef %opaque)
  ret void
}

declare zeroext i1 @qdict_get_try_bool(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

declare ptr @qdict_get(ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @warn_report(ptr noundef, ...) local_unnamed_addr #5

declare ptr @blk_new(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #5

declare i32 @blk_insert_bs(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @blk_unref(ptr noundef) #5

declare ptr @qdict_first(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @bdrv_parent_cb_change_media(ptr nocapture noundef readonly %bs) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3396, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parent_cb_change_media) #31
  unreachable

do.end:                                           ; preds = %entry
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 32
  %c.05 = load ptr, ptr %parents, align 8
  %tobool.not6 = icmp eq ptr %c.05, null
  br i1 %tobool.not6, label %for.end, label %for.body

for.body:                                         ; preds = %do.end, %for.inc
  %c.07 = phi ptr [ %c.0, %for.inc ], [ %c.05, %do.end ]
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %c.07, i64 0, i32 2
  %0 = load ptr, ptr %klass, align 8
  %change_media = getelementptr inbounds %struct.BdrvChildClass, ptr %0, i64 0, i32 3
  %1 = load ptr, ptr %change_media, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %for.inc, label %if.then2

if.then2:                                         ; preds = %for.body
  tail call void %1(ptr noundef nonnull %c.07, i1 noundef zeroext true) #29
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then2
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %c.07, i64 0, i32 10
  %c.0 = load ptr, ptr %next_parent, align 8
  %tobool.not = icmp eq ptr %c.0, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !105

for.end:                                          ; preds = %for.inc, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @bdrv_append_temp_snapshot(ptr noundef %bs, i32 noundef %flags, ptr noundef %snapshot_options, ptr noundef %errp) unnamed_addr #4 {
entry:
  %tobool.not.i = icmp eq ptr %bs, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %bs, i64 0, i32 8
  %0 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %0, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call1 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call1, label %do.end, label %if.else

if.else:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 3887, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_append_temp_snapshot) #31
  unreachable

do.end:                                           ; preds = %bdrv_get_aio_context.exit
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  %call2 = tail call i64 @bdrv_getlength(ptr noundef %bs) #29
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  %cmp = icmp slt i64 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.end
  %1 = trunc i64 %call2 to i32
  %conv = sub i32 0, %1
  tail call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 3898, ptr noundef nonnull @__func__.bdrv_append_temp_snapshot, i32 noundef %conv, ptr noundef nonnull @.str.252) #29
  br label %out

if.end4:                                          ; preds = %do.end
  %call5 = tail call ptr @create_tmp_file(ptr noundef %errp)
  %tobool.not = icmp eq ptr %call5, null
  br i1 %tobool.not, label %out, label %if.end7

if.end7:                                          ; preds = %if.end4
  %2 = load ptr, ptr getelementptr inbounds (%struct.BlockDriver, ptr @bdrv_qcow2, i64 0, i32 9), align 8
  %call8 = tail call ptr @qemu_opts_create(ptr noundef %2, ptr noundef null, i32 noundef 0, ptr noundef nonnull @error_abort) #29
  %call9 = tail call zeroext i1 @qemu_opt_set_number(ptr noundef %call8, ptr noundef nonnull @.str.17, i64 noundef %call2, ptr noundef nonnull @error_abort) #29
  %call10 = tail call i32 @bdrv_create(ptr noundef nonnull @bdrv_qcow2, ptr noundef nonnull %call5, ptr noundef %call8, ptr noundef %errp) #29
  tail call void @qemu_opts_del(ptr noundef %call8) #29
  %cmp11 = icmp slt i32 %call10, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end7
  tail call void (ptr, ptr, ...) @error_prepend(ptr noundef %errp, ptr noundef nonnull @.str.253, ptr noundef nonnull %call5) #29
  br label %out

if.end14:                                         ; preds = %if.end7
  tail call void @qdict_put_str(ptr noundef %snapshot_options, ptr noundef nonnull @.str.254, ptr noundef nonnull @.str.214) #29
  tail call void @qdict_put_str(ptr noundef %snapshot_options, ptr noundef nonnull @.str.77, ptr noundef nonnull %call5) #29
  tail call void @qdict_put_str(ptr noundef %snapshot_options, ptr noundef nonnull @.str.20, ptr noundef nonnull @.str.255) #29
  %call.i24 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i24, label %bdrv_open.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end14
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4270, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_open) #31
  unreachable

bdrv_open.exit:                                   ; preds = %if.end14
  %call1.i = tail call ptr @bdrv_open_inherit(ptr noundef null, ptr noundef null, ptr noundef %snapshot_options, i32 noundef %flags, ptr noundef null, ptr noundef null, i32 noundef 0, ptr noundef %errp)
  %tobool16.not = icmp eq ptr %call1.i, null
  br i1 %tobool16.not, label %qobject_unref_impl.exit, label %if.end18

if.end18:                                         ; preds = %bdrv_open.exit
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  %call19 = tail call i32 @bdrv_append(ptr noundef nonnull %call1.i, ptr noundef %bs, ptr noundef %errp), !range !14
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  %cmp20 = icmp slt i32 %call19, 0
  %spec.select = select i1 %cmp20, ptr null, ptr %call1.i
  br label %qobject_unref_impl.exit

out:                                              ; preds = %if.end4, %if.then13, %if.then3
  %tmp_filename.0 = phi ptr [ null, %if.then3 ], [ null, %if.end4 ], [ %call5, %if.then13 ]
  %tobool24.not = icmp eq ptr %snapshot_options, null
  br i1 %tobool24.not, label %qobject_unref_impl.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %out
  %refcnt.i = getelementptr inbounds %struct.QObjectBase_, ptr %snapshot_options, i64 0, i32 1
  %3 = load i64, ptr %refcnt.i, align 8
  %tobool1.not.i = icmp eq i64 %3, 0
  br i1 %tobool1.not.i, label %if.else.i25, label %land.lhs.true.i

if.else.i25:                                      ; preds = %lor.lhs.false.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.161, i32 noundef 97, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_unref_impl) #31
  unreachable

land.lhs.true.i:                                  ; preds = %lor.lhs.false.i
  %dec.i = add i64 %3, -1
  store i64 %dec.i, ptr %refcnt.i, align 8
  %cmp.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.i, label %if.then5.i, label %qobject_unref_impl.exit

if.then5.i:                                       ; preds = %land.lhs.true.i
  tail call void @qobject_destroy(ptr noundef nonnull %snapshot_options) #29
  br label %qobject_unref_impl.exit

qobject_unref_impl.exit:                          ; preds = %if.end18, %bdrv_open.exit, %out, %land.lhs.true.i, %if.then5.i
  %bs_snapshot.033 = phi ptr [ null, %out ], [ null, %land.lhs.true.i ], [ null, %if.then5.i ], [ %spec.select, %if.end18 ], [ null, %bdrv_open.exit ]
  %tmp_filename.032 = phi ptr [ %tmp_filename.0, %out ], [ %tmp_filename.0, %land.lhs.true.i ], [ %tmp_filename.0, %if.then5.i ], [ %call5, %if.end18 ], [ %call5, %bdrv_open.exit ]
  tail call void @g_free(ptr noundef %tmp_filename.032) #29
  ret ptr %bs_snapshot.033
}

declare i32 @g_str_has_prefix(ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @qdict_join(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

declare ptr @qobject_from_json(ptr noundef, ptr noundef) local_unnamed_addr #5

declare zeroext i1 @blk_is_sg(ptr noundef) local_unnamed_addr #5

declare zeroext i1 @blk_is_inserted(ptr noundef) #5

declare i64 @blk_getlength(ptr noundef) #5

declare i32 @blk_pread(ptr noundef, i64 noundef, i64 noundef, ptr noundef, i32 noundef) #5

declare zeroext i1 @qemu_opts_absorb_qdict(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @update_flags_from_options(ptr nocapture noundef %flags, ptr noundef %opts) unnamed_addr #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1535, ptr noundef nonnull @__PRETTY_FUNCTION__.update_flags_from_options) #31
  unreachable

do.end:                                           ; preds = %entry
  %0 = load i32, ptr %flags, align 4
  %and = and i32 %0, -131619
  store i32 %and, ptr %flags, align 4
  %call1 = tail call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %opts, ptr noundef nonnull @.str.49, i1 noundef zeroext false) #29
  br i1 %call1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  %1 = load i32, ptr %flags, align 4
  %or = or i32 %1, 512
  store i32 %or, ptr %flags, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %do.end
  %call4 = tail call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %opts, ptr noundef nonnull @.str.47, i1 noundef zeroext false) #29
  br i1 %call4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %2 = load i32, ptr %flags, align 4
  %or6 = or i32 %2, 32
  store i32 %or6, ptr %flags, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %call8 = tail call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %opts, ptr noundef nonnull @.str.51, i1 noundef zeroext false) #29
  br i1 %call8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end7
  %3 = load i32, ptr %flags, align 4
  %or10 = or i32 %3, 2
  store i32 %or10, ptr %flags, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %call12 = tail call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %opts, ptr noundef nonnull @.str.53, i1 noundef zeroext false) #29
  br i1 %call12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %4 = load i32, ptr %flags, align 4
  %or14 = or i32 %4, 131072
  store i32 %or14, ptr %flags, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  ret void
}

declare zeroext i1 @qemu_opt_get_bool(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

declare void @bdrv_enable_copy_on_read(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_parse_detect_zeroes(ptr noundef %opts, i32 noundef %open_flags, ptr noundef %errp) unnamed_addr #4 {
entry:
  %local_err = alloca ptr, align 8
  store ptr null, ptr %local_err, align 8
  %call = tail call ptr @qemu_opt_get_del(ptr noundef %opts, ptr noundef nonnull @.str.55) #29
  %call1 = call i32 @qapi_enum_parse(ptr noundef nonnull @BlockdevDetectZeroesOptions_lookup, ptr noundef %call, i32 noundef 0, ptr noundef nonnull %local_err) #29
  %call2 = call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call2, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 1108, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_parse_detect_zeroes) #31
  unreachable

do.end:                                           ; preds = %entry
  call void @g_free(ptr noundef %call) #29
  %0 = load ptr, ptr %local_err, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %do.end
  call void @error_propagate(ptr noundef %errp, ptr noundef nonnull %0) #29
  br label %return

if.end4:                                          ; preds = %do.end
  %cmp = icmp eq i32 %call1, 2
  %and = and i32 %open_flags, 16384
  %tobool5.not = icmp eq i32 %and, 0
  %or.cond = and i1 %tobool5.not, %cmp
  br i1 %or.cond, label %if.then6, label %return

if.then6:                                         ; preds = %if.end4
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 1119, ptr noundef nonnull @__func__.bdrv_parse_detect_zeroes, ptr noundef nonnull @.str.251) #29
  br label %return

return:                                           ; preds = %if.end4, %if.then6, %if.then3
  ret i32 %call1
}

declare zeroext i1 @qemu_opt_get_bool_del(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #5

; Function Attrs: nofree nounwind
declare noundef i32 @gettimeofday(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #21

declare void @qemu_log(ptr noundef, ...) local_unnamed_addr #5

declare i32 @qemu_get_thread_id() local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bdrv_reopen_parse_file_or_backing(ptr nocapture noundef %reopen_state, i1 noundef zeroext %is_backing, ptr noundef %tran, ptr noundef %errp) unnamed_addr #4 {
entry:
  %0 = load ptr, ptr %reopen_state, align 8
  %cond = select i1 %is_backing, ptr @.str.89, ptr @.str.214
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 4767, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_parse_file_or_backing) #31
  unreachable

do.end:                                           ; preds = %entry
  %options = getelementptr inbounds %struct.BDRVReopenState, ptr %reopen_state, i64 0, i32 6
  %1 = load ptr, ptr %options, align 8
  %call2 = tail call ptr @qdict_get(ptr noundef %1, ptr noundef nonnull %cond) #29
  %cmp = icmp eq ptr %call2, null
  br i1 %cmp, label %return, label %if.end4

if.end4:                                          ; preds = %do.end
  tail call void @bdrv_graph_rdlock_main_loop() #29
  %call2.val = load i32, ptr %call2, align 8
  %2 = add i32 %call2.val, -1
  %or.cond.i = icmp ult i32 %2, 6
  br i1 %or.cond.i, label %qobject_type.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end4
  tail call void @__assert_fail(ptr noundef nonnull @.str.218, ptr noundef nonnull @.str.161, i32 noundef 126, ptr noundef nonnull @__PRETTY_FUNCTION__.qobject_type) #31
  unreachable

qobject_type.exit:                                ; preds = %if.end4
  switch i32 %call2.val, label %do.body22 [
    i32 1, label %sw.bb
    i32 3, label %qobject_check_type.exit
  ]

sw.bb:                                            ; preds = %qobject_type.exit
  br i1 %is_backing, label %cond.true.thread, label %if.else8

if.else8:                                         ; preds = %sw.bb
  tail call void @__assert_fail(ptr noundef nonnull @.str.265, ptr noundef nonnull @.str.2, i32 noundef 4778, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_reopen_parse_file_or_backing) #31
  unreachable

qobject_check_type.exit:                          ; preds = %qobject_type.exit
  %call12 = tail call ptr @qstring_get_str(ptr noundef nonnull %call2) #29
  %call13 = tail call ptr @bdrv_lookup_bs(ptr noundef null, ptr noundef %call12, ptr noundef %errp)
  %cmp14 = icmp eq ptr %call13, null
  br i1 %cmp14, label %out_rdlock, label %if.end16

if.end16:                                         ; preds = %qobject_check_type.exit
  %call17 = tail call fastcc zeroext i1 @bdrv_recurse_has_child(ptr noundef nonnull %call13, ptr noundef %0)
  br i1 %call17, label %if.then20, label %sw.epilog

if.then20:                                        ; preds = %if.end16
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4792, ptr noundef nonnull @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef nonnull @.str.202, ptr noundef %call12, ptr noundef nonnull %cond, ptr noundef nonnull %node_name) #29
  br label %out_rdlock

do.body22:                                        ; preds = %qobject_type.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 4802, ptr noundef nonnull @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef null) #31
  unreachable

sw.epilog:                                        ; preds = %if.end16
  br i1 %is_backing, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 30
  %3 = load ptr, ptr %backing, align 8
  %tobool.not.i55 = icmp eq ptr %3, null
  br i1 %tobool.not.i55, label %if.end42, label %cond.end

cond.true.thread:                                 ; preds = %sw.bb
  %backing107 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 30
  %4 = load ptr, ptr %backing107, align 8
  %tobool.not.i55108 = icmp eq ptr %4, null
  br i1 %tobool.not.i55108, label %out_rdlock, label %cond.end

cond.false:                                       ; preds = %sw.epilog
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 31
  %5 = load ptr, ptr %file, align 8
  %tobool.not.i56 = icmp eq ptr %5, null
  br i1 %tobool.not.i56, label %if.end42, label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true, %cond.true.thread
  %.sink = phi ptr [ %4, %cond.true.thread ], [ %3, %cond.true ], [ %5, %cond.false ]
  %new_child_bs.075 = phi ptr [ null, %cond.true.thread ], [ %call13, %cond.true ], [ %call13, %cond.false ]
  %6 = load ptr, ptr %.sink, align 8
  %cmp28 = icmp eq ptr %6, %new_child_bs.075
  br i1 %cmp28, label %out_rdlock, label %if.end30

if.end30:                                         ; preds = %cond.end
  %tobool31.not = icmp eq ptr %6, null
  br i1 %tobool31.not, label %if.end42, label %if.then32

if.then32:                                        ; preds = %if.end30
  %call.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i, label %bdrv_skip_implicit_filters.exit, label %if.else.i60

if.else.i60:                                      ; preds = %if.then32
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 8555, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_skip_implicit_filters) #31
  unreachable

bdrv_skip_implicit_filters.exit:                  ; preds = %if.then32
  %call1.i = tail call fastcc ptr @bdrv_do_skip_filters(ptr noundef nonnull %6, i1 noundef zeroext true)
  %cmp34 = icmp eq ptr %call1.i, %new_child_bs.075
  br i1 %cmp34, label %out_rdlock, label %if.end36

if.end36:                                         ; preds = %bdrv_skip_implicit_filters.exit
  %implicit = getelementptr inbounds %struct.BlockDriverState, ptr %6, i64 0, i32 5
  %7 = load i8, ptr %implicit, align 8
  %8 = and i8 %7, 1
  %tobool37.not = icmp eq i8 %8, 0
  br i1 %tobool37.not, label %if.end49, label %if.then38

if.then38:                                        ; preds = %if.end36
  %node_name39 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 22
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4819, ptr noundef nonnull @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef nonnull @.str.266, ptr noundef nonnull %cond, ptr noundef nonnull %node_name39) #29
  br label %out_rdlock

if.end42:                                         ; preds = %cond.true, %cond.false, %if.end30
  %new_child_bs.0758086 = phi ptr [ %new_child_bs.075, %if.end30 ], [ %call13, %cond.false ], [ %call13, %cond.true ]
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 6
  %9 = load ptr, ptr %drv, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %9, i64 0, i32 2
  %10 = load i8, ptr %is_filter, align 4
  %11 = and i8 %10, 1
  %tobool43.not53 = icmp eq i8 %11, 0
  br i1 %tobool43.not53, label %if.end49, label %if.then45

if.then45:                                        ; preds = %if.end42
  %node_name46 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 22
  %12 = load ptr, ptr %9, align 8
  tail call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %errp, ptr noundef nonnull @.str.2, i32 noundef 4831, ptr noundef nonnull @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef nonnull @.str.267, ptr noundef nonnull %node_name46, ptr noundef %12, ptr noundef nonnull %cond) #29
  br label %out_rdlock

if.end49:                                         ; preds = %if.end36, %if.end42
  %cond27818597 = phi ptr [ null, %if.end42 ], [ %6, %if.end36 ]
  %new_child_bs.075808696 = phi ptr [ %new_child_bs.0758086, %if.end42 ], [ %new_child_bs.075, %if.end36 ]
  %tobool318795 = phi i1 [ false, %if.end42 ], [ true, %if.end36 ]
  %old_file_bs = getelementptr inbounds %struct.BDRVReopenState, ptr %reopen_state, i64 0, i32 5
  %old_backing_bs = getelementptr inbounds %struct.BDRVReopenState, ptr %reopen_state, i64 0, i32 4
  %old_file_bs.sink = select i1 %is_backing, ptr %old_backing_bs, ptr %old_file_bs
  store ptr %cond27818597, ptr %old_file_bs.sink, align 8
  br i1 %tobool318795, label %if.then55, label %bdrv_get_aio_context.exit

if.then55:                                        ; preds = %if.end49
  %call.i61 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i61, label %bdrv_ref.exit, label %if.else.i62

if.else.i62:                                      ; preds = %if.then55
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7238, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_ref) #31
  unreachable

bdrv_ref.exit:                                    ; preds = %if.then55
  %refcnt.i = getelementptr inbounds %struct.BlockDriverState, ptr %cond27818597, i64 0, i32 26
  %13 = load i32, ptr %refcnt.i, align 8
  %inc.i = add i32 %13, 1
  store i32 %inc.i, ptr %refcnt.i, align 8
  tail call void @bdrv_drained_begin(ptr noundef nonnull %cond27818597) #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %bdrv_ref.exit, %if.end49
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 8
  %14 = load ptr, ptr %aio_context.i, align 8
  %tobool.not.i67 = icmp eq ptr %new_child_bs.075808696, null
  br i1 %tobool.not.i67, label %cond.false.i71, label %cond.true.i68

cond.true.i68:                                    ; preds = %bdrv_get_aio_context.exit
  %aio_context.i69 = getelementptr inbounds %struct.BlockDriverState, ptr %new_child_bs.075808696, i64 0, i32 8
  %15 = load ptr, ptr %aio_context.i69, align 8
  br label %bdrv_get_aio_context.exit73

cond.false.i71:                                   ; preds = %bdrv_get_aio_context.exit
  %call.i72 = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit73

bdrv_get_aio_context.exit73:                      ; preds = %cond.true.i68, %cond.false.i71
  %cond.i70 = phi ptr [ %15, %cond.true.i68 ], [ %call.i72, %cond.false.i71 ]
  %cmp59.not = icmp eq ptr %14, %cond.i70
  br i1 %cmp59.not, label %if.end61, label %if.then60

if.then60:                                        ; preds = %bdrv_get_aio_context.exit73
  tail call void @aio_context_release(ptr noundef %14) #29
  tail call void @aio_context_acquire(ptr noundef %cond.i70) #29
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %bdrv_get_aio_context.exit73
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  tail call void @bdrv_graph_wrlock(ptr noundef %new_child_bs.075808696) #29
  %call63 = tail call fastcc i32 @bdrv_set_file_or_backing_noperm(ptr noundef nonnull %0, ptr noundef %new_child_bs.075808696, i1 noundef zeroext %is_backing, ptr noundef %tran, ptr noundef %errp), !range !28
  tail call void @bdrv_graph_wrunlock_ctx(ptr noundef %cond.i70) #29
  br i1 %cmp59.not, label %if.end66, label %if.then65

if.then65:                                        ; preds = %if.end61
  tail call void @aio_context_release(ptr noundef %cond.i70) #29
  tail call void @aio_context_acquire(ptr noundef %14) #29
  br label %if.end66

if.end66:                                         ; preds = %if.then65, %if.end61
  br i1 %tobool318795, label %if.then68, label %return

if.then68:                                        ; preds = %if.end66
  tail call void @bdrv_drained_end(ptr noundef nonnull %cond27818597) #29
  tail call void @bdrv_unref(ptr noundef nonnull %cond27818597)
  br label %return

out_rdlock:                                       ; preds = %cond.true.thread, %bdrv_skip_implicit_filters.exit, %cond.end, %qobject_check_type.exit, %if.then45, %if.then38, %if.then20
  %ret.0 = phi i32 [ -22, %if.then20 ], [ -1, %if.then38 ], [ -22, %if.then45 ], [ -22, %qobject_check_type.exit ], [ 0, %cond.end ], [ 0, %bdrv_skip_implicit_filters.exit ], [ 0, %cond.true.thread ]
  tail call void @bdrv_graph_rdunlock_main_loop() #29
  br label %return

return:                                           ; preds = %if.end66, %if.then68, %do.end, %out_rdlock
  %retval.0 = phi i32 [ %ret.0, %out_rdlock ], [ 0, %do.end ], [ %call63, %if.then68 ], [ %call63, %if.end66 ]
  ret i32 %retval.0
}

declare ptr @qstring_get_str(ptr noundef) local_unnamed_addr #5

declare zeroext i1 @qobject_is_equal(ptr noundef, ptr noundef) local_unnamed_addr #5

declare ptr @qdict_next(ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @bdrv_graph_wrunlock_ctx(ptr noundef) #5

declare ptr @g_queue_new() local_unnamed_addr #5

declare void @g_queue_push_tail(ptr noundef, ptr noundef) local_unnamed_addr #5

declare i32 @g_queue_is_empty(ptr noundef) local_unnamed_addr #5

declare ptr @g_queue_pop_head(ptr noundef) local_unnamed_addr #5

declare void @g_queue_free(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_replace_child_abort(ptr nocapture noundef readonly %opaque) #4 {
entry:
  %0 = load ptr, ptr %opaque, align 8
  %1 = load ptr, ptr %0, align 8
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2416, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_abort) #31
  unreachable

do.end:                                           ; preds = %entry
  tail call void @assert_bdrv_graph_writable() #29
  %2 = load ptr, ptr %opaque, align 8
  %3 = load ptr, ptr %2, align 8
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %if.then3, label %if.end10

if.then3:                                         ; preds = %do.end
  tail call void @bdrv_parent_drained_begin_single(ptr noundef nonnull %2) #29
  %4 = load ptr, ptr %opaque, align 8
  %call6 = tail call zeroext i1 @bdrv_parent_drained_poll_single(ptr noundef %4) #29
  br i1 %call6, label %if.else8, label %if.then3.if.end10_crit_edge

if.then3.if.end10_crit_edge:                      ; preds = %if.then3
  %.pre = load ptr, ptr %opaque, align 8
  br label %if.end10

if.else8:                                         ; preds = %if.then3
  tail call void @__assert_fail(ptr noundef nonnull @.str.277, ptr noundef nonnull @.str.2, i32 noundef 2431, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_abort) #31
  unreachable

if.end10:                                         ; preds = %if.then3.if.end10_crit_edge, %do.end
  %5 = phi ptr [ %.pre, %if.then3.if.end10_crit_edge ], [ %2, %do.end ]
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %5, i64 0, i32 8
  %6 = load i8, ptr %quiesced_parent, align 1
  %7 = and i8 %6, 1
  %tobool12.not = icmp eq i8 %7, 0
  br i1 %tobool12.not, label %if.else14, label %if.end15

if.else14:                                        ; preds = %if.end10
  tail call void @__assert_fail(ptr noundef nonnull @.str.278, ptr noundef nonnull @.str.2, i32 noundef 2433, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_abort) #31
  unreachable

if.end15:                                         ; preds = %if.end10
  %old_bs = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %opaque, i64 0, i32 1
  %8 = load ptr, ptr %old_bs, align 8
  tail call fastcc void @bdrv_replace_child_noperm(ptr noundef nonnull %5, ptr noundef %8)
  tail call void @bdrv_unref(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_replace_child_commit(ptr nocapture noundef readonly %opaque) #4 {
entry:
  %call = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call, label %do.end, label %if.else

if.else:                                          ; preds = %entry
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 2406, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_replace_child_commit) #31
  unreachable

do.end:                                           ; preds = %entry
  %old_bs = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %opaque, i64 0, i32 1
  %0 = load ptr, ptr %old_bs, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %bdrv_schedule_unref.exit, label %if.end.i

if.end.i:                                         ; preds = %do.end
  %call.i = tail call ptr @qemu_get_aio_context() #29
  tail call void @aio_bh_schedule_oneshot_full(ptr noundef %call.i, ptr noundef nonnull @bdrv_schedule_unref_bh, ptr noundef nonnull %0, ptr noundef nonnull @.str.105) #29
  br label %bdrv_schedule_unref.exit

bdrv_schedule_unref.exit:                         ; preds = %do.end, %if.end.i
  ret void
}

declare zeroext i1 @bdrv_parent_drained_poll_single(ptr noundef) local_unnamed_addr #5

declare ptr @g_hash_table_lookup(ptr noundef, ptr noundef) local_unnamed_addr #5

declare i32 @g_hash_table_size(ptr noundef) local_unnamed_addr #5

declare i32 @g_hash_table_insert(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

declare void @qemu_mutex_unlock_impl(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #5

declare void @qemu_mutex_destroy(ptr noundef) local_unnamed_addr #5

declare void @bdrv_drain(ptr noundef) local_unnamed_addr #5

declare void @bdrv_release_named_dirty_bitmaps(ptr noundef) local_unnamed_addr #5

declare void @bdrv_drain_all_end_quiesce(ptr noundef) local_unnamed_addr #5

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_set_aio_context_commit(ptr nocapture noundef readonly %opaque) #4 {
entry:
  %bs1 = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %opaque, i64 0, i32 1
  %0 = load ptr, ptr %bs1, align 8
  %1 = load ptr, ptr %opaque, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %cond.false.i, label %cond.true.i

cond.true.i:                                      ; preds = %entry
  %aio_context.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 8
  %2 = load ptr, ptr %aio_context.i, align 8
  br label %bdrv_get_aio_context.exit

cond.false.i:                                     ; preds = %entry
  %call.i = tail call ptr @qemu_get_aio_context() #29
  br label %bdrv_get_aio_context.exit

bdrv_get_aio_context.exit:                        ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi ptr [ %2, %cond.true.i ], [ %call.i, %cond.false.i ]
  %call2 = tail call ptr @qemu_get_aio_context() #29
  %cmp.not = icmp eq ptr %cond.i, %call2
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %bdrv_get_aio_context.exit
  tail call void @aio_context_acquire(ptr noundef %cond.i) #29
  br label %if.end

if.end:                                           ; preds = %if.then, %bdrv_get_aio_context.exit
  %walking_aio_notifiers.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 10
  %3 = load i8, ptr %walking_aio_notifiers.i, align 8
  %4 = and i8 %3, 1
  %tobool.not.i7 = icmp eq i8 %4, 0
  br i1 %tobool.not.i7, label %do.body.i, label %if.else.i

if.else.i:                                        ; preds = %if.end
  tail call void @__assert_fail(ptr noundef nonnull @.str.289, ptr noundef nonnull @.str.2, i32 noundef 7624, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_detach_aio_context) #31
  unreachable

do.body.i:                                        ; preds = %if.end
  %call.i8 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i8, label %do.end.i, label %if.else2.i

if.else2.i:                                       ; preds = %do.body.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7625, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_detach_aio_context) #31
  unreachable

do.end.i:                                         ; preds = %do.body.i
  store i8 1, ptr %walking_aio_notifiers.i, align 8
  %aio_notifiers.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 9
  %5 = load ptr, ptr %aio_notifiers.i, align 8
  %tobool5.not15.i = icmp eq ptr %5, null
  br i1 %tobool5.not15.i, label %for.end.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.end.i, %for.inc.i
  %baf.016.i = phi ptr [ %6, %for.inc.i ], [ %5, %do.end.i ]
  %list.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %baf.016.i, i64 0, i32 4
  %6 = load ptr, ptr %list.i, align 8
  %deleted.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %baf.016.i, i64 0, i32 3
  %7 = load i8, ptr %deleted.i, align 8
  %8 = and i8 %7, 1
  %tobool6.not.i = icmp eq i8 %8, 0
  br i1 %tobool6.not.i, label %if.else8.i, label %if.then7.i

if.then7.i:                                       ; preds = %land.rhs.i
  %call.i.i = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i, label %do.body1.i.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then7.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7615, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_remove_aio_context_notifier) #31
  unreachable

do.body1.i.i:                                     ; preds = %if.then7.i
  %9 = load ptr, ptr %list.i, align 8
  %cmp.not.i.i = icmp eq ptr %9, null
  %le_prev12.phi.trans.insert.i.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %baf.016.i, i64 0, i32 4, i32 1
  %.pre8.i.i = load ptr, ptr %le_prev12.phi.trans.insert.i.i, align 8
  br i1 %cmp.not.i.i, label %bdrv_do_remove_aio_context_notifier.exit.i, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %do.body1.i.i
  %le_prev7.i.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %9, i64 0, i32 4, i32 1
  store ptr %.pre8.i.i, ptr %le_prev7.i.i, align 8
  %.pre.i.i = load ptr, ptr %list.i, align 8
  br label %bdrv_do_remove_aio_context_notifier.exit.i

bdrv_do_remove_aio_context_notifier.exit.i:       ; preds = %if.then2.i.i, %do.body1.i.i
  %10 = phi ptr [ %.pre.i.i, %if.then2.i.i ], [ null, %do.body1.i.i ]
  store ptr %10, ptr %.pre8.i.i, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %baf.016.i) #29
  br label %for.inc.i

if.else8.i:                                       ; preds = %land.rhs.i
  %detach_aio_context.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %baf.016.i, i64 0, i32 1
  %11 = load ptr, ptr %detach_aio_context.i, align 8
  %opaque.i = getelementptr inbounds %struct.BdrvAioNotifier, ptr %baf.016.i, i64 0, i32 2
  %12 = load ptr, ptr %opaque.i, align 8
  tail call void %11(ptr noundef %12) #29
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.else8.i, %bdrv_do_remove_aio_context_notifier.exit.i
  %tobool5.not.i = icmp eq ptr %6, null
  br i1 %tobool5.not.i, label %for.end.i, label %land.rhs.i, !llvm.loop !106

for.end.i:                                        ; preds = %for.inc.i, %do.end.i
  store i8 0, ptr %walking_aio_notifiers.i, align 8
  %drv.i = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 6
  %13 = load ptr, ptr %drv.i, align 8
  %tobool11.not.i = icmp eq ptr %13, null
  br i1 %tobool11.not.i, label %bdrv_detach_aio_context.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %for.end.i
  %bdrv_detach_aio_context.i = getelementptr inbounds %struct.BlockDriver, ptr %13, i64 0, i32 47
  %14 = load ptr, ptr %bdrv_detach_aio_context.i, align 8
  %tobool13.not.i = icmp eq ptr %14, null
  br i1 %tobool13.not.i, label %bdrv_detach_aio_context.exit, label %if.then14.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  tail call void %14(ptr noundef nonnull %0) #29
  br label %bdrv_detach_aio_context.exit

bdrv_detach_aio_context.exit:                     ; preds = %for.end.i, %land.lhs.true.i, %if.then14.i
  %aio_context.i9 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i64 0, i32 8
  store ptr null, ptr %aio_context.i9, align 8
  %call3 = tail call ptr @qemu_get_aio_context() #29
  %cmp4.not = icmp eq ptr %cond.i, %call3
  br i1 %cmp4.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %bdrv_detach_aio_context.exit
  tail call void @aio_context_release(ptr noundef %cond.i) #29
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %bdrv_detach_aio_context.exit
  %call.i10 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i10, label %do.end.i12, label %if.else.i11

if.else.i11:                                      ; preds = %if.end6
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7650, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_aio_context) #31
  unreachable

do.end.i12:                                       ; preds = %if.end6
  store ptr %1, ptr %aio_context.i9, align 8
  %15 = load ptr, ptr %drv.i, align 8
  %tobool.not.i15 = icmp eq ptr %15, null
  br i1 %tobool.not.i15, label %if.end6.i, label %land.lhs.true.i16

land.lhs.true.i16:                                ; preds = %do.end.i12
  %bdrv_attach_aio_context.i = getelementptr inbounds %struct.BlockDriver, ptr %15, i64 0, i32 48
  %16 = load ptr, ptr %bdrv_attach_aio_context.i, align 8
  %tobool2.not.i = icmp eq ptr %16, null
  br i1 %tobool2.not.i, label %if.end6.i, label %if.then3.i

if.then3.i:                                       ; preds = %land.lhs.true.i16
  tail call void %16(ptr noundef nonnull %0, ptr noundef %1) #29
  br label %if.end6.i

if.end6.i:                                        ; preds = %if.then3.i, %land.lhs.true.i16, %do.end.i12
  %17 = load i8, ptr %walking_aio_notifiers.i, align 8
  %18 = and i8 %17, 1
  %tobool7.not.i = icmp eq i8 %18, 0
  br i1 %tobool7.not.i, label %if.end10.i, label %if.else9.i

if.else9.i:                                       ; preds = %if.end6.i
  tail call void @__assert_fail(ptr noundef nonnull @.str.289, ptr noundef nonnull @.str.2, i32 noundef 7658, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_attach_aio_context) #31
  unreachable

if.end10.i:                                       ; preds = %if.end6.i
  store i8 1, ptr %walking_aio_notifiers.i, align 8
  %19 = load ptr, ptr %aio_notifiers.i, align 8
  %tobool12.not17.i = icmp eq ptr %19, null
  br i1 %tobool12.not17.i, label %bdrv_attach_aio_context.exit, label %land.rhs.i19

land.rhs.i19:                                     ; preds = %if.end10.i, %for.inc.i34
  %ban.018.i = phi ptr [ %20, %for.inc.i34 ], [ %19, %if.end10.i ]
  %list.i20 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.018.i, i64 0, i32 4
  %20 = load ptr, ptr %list.i20, align 8
  %deleted.i21 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.018.i, i64 0, i32 3
  %21 = load i8, ptr %deleted.i21, align 8
  %22 = and i8 %21, 1
  %tobool13.not.i22 = icmp eq i8 %22, 0
  br i1 %tobool13.not.i22, label %if.else15.i, label %if.then14.i23

if.then14.i23:                                    ; preds = %land.rhs.i19
  %call.i.i24 = tail call zeroext i1 @qemu_in_main_thread() #29
  br i1 %call.i.i24, label %do.body1.i.i26, label %if.else.i.i25

if.else.i.i25:                                    ; preds = %if.then14.i23
  tail call void @__assert_fail(ptr noundef nonnull @.str.10, ptr noundef nonnull @.str.2, i32 noundef 7615, ptr noundef nonnull @__PRETTY_FUNCTION__.bdrv_do_remove_aio_context_notifier) #31
  unreachable

do.body1.i.i26:                                   ; preds = %if.then14.i23
  %23 = load ptr, ptr %list.i20, align 8
  %cmp.not.i.i27 = icmp eq ptr %23, null
  %le_prev12.phi.trans.insert.i.i28 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.018.i, i64 0, i32 4, i32 1
  %.pre8.i.i29 = load ptr, ptr %le_prev12.phi.trans.insert.i.i28, align 8
  br i1 %cmp.not.i.i27, label %bdrv_do_remove_aio_context_notifier.exit.i33, label %if.then2.i.i30

if.then2.i.i30:                                   ; preds = %do.body1.i.i26
  %le_prev7.i.i31 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %23, i64 0, i32 4, i32 1
  store ptr %.pre8.i.i29, ptr %le_prev7.i.i31, align 8
  %.pre.i.i32 = load ptr, ptr %list.i20, align 8
  br label %bdrv_do_remove_aio_context_notifier.exit.i33

bdrv_do_remove_aio_context_notifier.exit.i33:     ; preds = %if.then2.i.i30, %do.body1.i.i26
  %24 = phi ptr [ %.pre.i.i32, %if.then2.i.i30 ], [ null, %do.body1.i.i26 ]
  store ptr %24, ptr %.pre8.i.i29, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %list.i20, i8 0, i64 16, i1 false)
  tail call void @g_free(ptr noundef nonnull %ban.018.i) #29
  br label %for.inc.i34

if.else15.i:                                      ; preds = %land.rhs.i19
  %25 = load ptr, ptr %ban.018.i, align 8
  %opaque.i36 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %ban.018.i, i64 0, i32 2
  %26 = load ptr, ptr %opaque.i36, align 8
  tail call void %25(ptr noundef %1, ptr noundef %26) #29
  br label %for.inc.i34

for.inc.i34:                                      ; preds = %if.else15.i, %bdrv_do_remove_aio_context_notifier.exit.i33
  %tobool12.not.i = icmp eq ptr %20, null
  br i1 %tobool12.not.i, label %bdrv_attach_aio_context.exit, label %land.rhs.i19, !llvm.loop !107

bdrv_attach_aio_context.exit:                     ; preds = %for.inc.i34, %if.end10.i
  store i8 0, ptr %walking_aio_notifiers.i, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_set_aio_context_clean(ptr noundef %opaque) #4 {
entry:
  %bs1 = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %opaque, i64 0, i32 1
  %0 = load ptr, ptr %bs1, align 8
  tail call void @bdrv_drained_end(ptr noundef %0) #29
  tail call void @g_free(ptr noundef %opaque) #29
  ret void
}

declare ptr @qdict_entry_key(ptr noundef) local_unnamed_addr #5

declare ptr @qdict_entry_value(ptr noundef) local_unnamed_addr #5

declare ptr @get_ptr_rcu_reader() local_unnamed_addr #5

declare void @qemu_event_set(ptr noundef) local_unnamed_addr #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umin.i64(i64, i64) #24

; Function Attrs: nofree nounwind
declare noundef i32 @putchar(i32 noundef) local_unnamed_addr #25

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umax.i32(i32, i32) #24

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #24

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #26

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #26

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.ctpop.i32(i32) #24

attributes #0 = { mustprogress nofree nosync nounwind sspstrong willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nofree nounwind sspstrong willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { mustprogress nofree nounwind willreturn memory(argmem: read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #8 = { mustprogress nofree nounwind willreturn memory(argmem: readwrite) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { allocsize(0,1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #13 = { mustprogress nofree nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { mustprogress nofree nounwind sspstrong willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #17 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { nofree "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { mustprogress nofree nounwind sspstrong willreturn memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #20 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #21 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { nofree nosync nounwind sspstrong memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #23 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #24 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #25 = { nofree nounwind }
attributes #26 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #27 = { nounwind willreturn memory(none) }
attributes #28 = { nounwind willreturn memory(read) }
attributes #29 = { nounwind }
attributes #30 = { nounwind allocsize(0) }
attributes #31 = { noreturn nounwind }
attributes #32 = { nounwind allocsize(0,1) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = !{i32 -2147483648, i32 1}
!15 = distinct !{!15, !6}
!16 = !{i32 0, i32 33}
!17 = distinct !{!17, !6, !18}
!18 = !{!"llvm.loop.unswitch.partial.disable"}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = !{i32 -1, i32 1}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = !{i32 -22, i32 1}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = !{i64 2151794335}
!96 = !{i64 2152840648}
!97 = !{i64 2151799496}
!98 = !{i64 2152850341}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6, !18}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
