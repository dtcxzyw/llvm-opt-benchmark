; ModuleID = 'bench/icu/original/writesrc.ll'
source_filename = "bench/icu/original/writesrc.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"class.icu_75::MaybeStackArray" = type <{ ptr, i32, i8, [40 x i8], [3 x i8] }>
%struct.UTrie2 = type { ptr, ptr, ptr, i32, i32, i16, i16, i32, i32, i32, i32, ptr, i32, i8, i8, i16, ptr }
%struct.UCPTrie = type { ptr, %union.UCPTrieData, i32, i32, i32, i16, i8, i8, i32, i16, i16, i32, i32 }
%union.UCPTrieData = type { ptr }
%"class.icu_75::UnicodeSetIterator" = type { %"class.icu_75::UObject", i32, i32, ptr, ptr, i32, i32, i32, i32, i32, i32, ptr }
%"class.icu_75::UObject" = type { ptr }
%"class.icu_75::UnicodeString" = type { %"class.icu_75::Replaceable", %"union.icu_75::UnicodeString::StackBufferOrFields" }
%"class.icu_75::Replaceable" = type { %"class.icu_75::UObject" }
%"union.icu_75::UnicodeString::StackBufferOrFields" = type { %struct.anon.0, [32 x i8] }
%struct.anon.0 = type { i16, i32, i32, ptr }
%"class.std::__cxx11::basic_string" = type { %"struct.std::__cxx11::basic_string<char>::_Alloc_hider", i64, %union.anon }
%"struct.std::__cxx11::basic_string<char>::_Alloc_hider" = type { ptr }
%union.anon = type { i64, [8 x i8] }
%"class.icu_75::StringByteSink" = type { %"class.icu_75::ByteSink", ptr }
%"class.icu_75::ByteSink" = type { ptr }

$_ZN6icu_7515MaybeStackArrayIcLi40EEC5Ev = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EEC5Ei10UErrorCode = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EE6resizeEii = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EED5Ev = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv = comdat any

$__clang_call_terminate = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EEC5EOS1_ = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EE17resetToStackArrayEv = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EEaSEOS1_ = comdat any

$_ZNK6icu_7515MaybeStackArrayIcLi40EE11getCapacityEv = comdat any

$_ZNK6icu_7515MaybeStackArrayIcLi40EE8getAliasEv = comdat any

$_ZNK6icu_7515MaybeStackArrayIcLi40EE13getArrayLimitEv = comdat any

$_ZNK6icu_7515MaybeStackArrayIcLi40EEixEl = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EEixEl = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EE12aliasInsteadEPci = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EE13orphanOrCloneEiRi = comdat any

$_ZN6icu_7515MaybeStackArrayIcLi40EE8copyFromERKS1_R10UErrorCode = comdat any

$_ZNK6icu_7513UnicodeString12toUTF8StringINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERT_S9_ = comdat any

$_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED2Ev = comdat any

$_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED0Ev = comdat any

$_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE6AppendEPKci = comdat any

$_ZTVN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE = comdat any

$_ZTSN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE = comdat any

$_ZTIN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE = comdat any

@.str = private unnamed_addr constant [3 x i8] c"//\00", align 1
@.str.1 = private unnamed_addr constant [2 x i8] c"#\00", align 1
@.str.2 = private unnamed_addr constant [123 x i8] c"%s Copyright (C) %d and later: Unicode, Inc. and others.\0A%s License & terms of use: http://www.unicode.org/copyright.html\0A\00", align 1
@.str.3 = private unnamed_addr constant [110 x i8] c"%s Copyright (C) 1999-2016, International Business Machines\0A%s Corporation and others.  All Rights Reserved.\0A\00", align 1
@.str.4 = private unnamed_addr constant [53 x i8] c"%s\0A%s file name: %s\0A%s\0A%s machine-generated by: %s\0A\0A\00", align 1
@.str.5 = private unnamed_addr constant [9 x i8] c"%Y-%m-%d\00", align 1
@stderr = external local_unnamed_addr global ptr, align 8
@.str.6 = private unnamed_addr constant [47 x i8] c"usrc_writeArray(width=%ld) unrecognized width\0A\00", align 1
@.str.7 = private unnamed_addr constant [3 x i8] c",\0A\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1
@.str.9 = private unnamed_addr constant [6 x i8] c"0x%lx\00", align 1
@.str.10 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [34 x i8] c"    %s,\0A    %s+%ld,\0A    nullptr,\0A\00", align 1
@.str.12 = private unnamed_addr constant [30 x i8] c"    %s,\0A    nullptr,\0A    %s,\0A\00", align 1
@.str.13 = private unnamed_addr constant [126 x i8] c"    %ld,\0A    %ld,\0A    0x%hx,\0A    0x%hx,\0A    0x%lx,\0A    0x%lx,\0A    0x%lx,\0A    0x%lx,\0A    nullptr, 0, false, false, 0, nullptr\0A\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"  \00", align 1
@.str.15 = private unnamed_addr constant [21 x i8] c"    %s,\0A    { %s },\0A\00", align 1
@.str.16 = private unnamed_addr constant [82 x i8] c"    %ld, %ld,\0A    0x%lx, 0x%x,\0A    %d, %d,\0A    0, 0,\0A    0x%x, 0x%lx,\0A    0x%lx,\0A\00", align 1
@.str.17 = private unnamed_addr constant [171 x i8] c"indexLength = %ld\0AdataLength = %ld\0AhighStart = 0x%lx\0Ashifted12HighStart = 0x%x\0Atype = %d\0AvalueWidth = %d\0Aindex3NullOffset = 0x%x\0AdataNullOffset = 0x%lx\0AnullValue = 0x%lx\0A\00", align 1
@.str.18 = private unnamed_addr constant [44 x i8] c"static const uint16_t %s_trieIndex[%%ld]={\0A\00", align 1
@.str.19 = private unnamed_addr constant [43 x i8] c"static const uint%d_t %s_trieData[%%ld]={\0A\00", align 1
@.str.20 = private unnamed_addr constant [6 x i8] c"\0A};\0A\0A\00", align 1
@.str.21 = private unnamed_addr constant [13 x i8] c"index = [\0A  \00", align 1
@.str.22 = private unnamed_addr constant [15 x i8] c"data_%d = [\0A  \00", align 1
@.str.24 = private unnamed_addr constant [32 x i8] c"static const UCPTrie %s_trie={\0A\00", align 1
@.str.25 = private unnamed_addr constant [13 x i8] c"%s_trieIndex\00", align 1
@.str.26 = private unnamed_addr constant [12 x i8] c"%s_trieData\00", align 1
@.str.27 = private unnamed_addr constant [5 x i8] c"};\0A\0A\00", align 1
@.str.28 = private unnamed_addr constant [51 x i8] c"# Inclusive ranges of the code points in the set.\0A\00", align 1
@.str.29 = private unnamed_addr constant [12 x i8] c"ranges = [\0A\00", align 1
@.str.30 = private unnamed_addr constant [15 x i8] c"]\0Astrings = [\0A\00", align 1
@.str.31 = private unnamed_addr constant [17 x i8] c"  [0x%x, 0x%x],\0A\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"]\0A\00", align 1
@.str.33 = private unnamed_addr constant [72 x i8] c"# Code points `a` through `b` have value `v`, corresponding to `name`.\0A\00", align 1
@.str.34 = private unnamed_addr constant [38 x i8] c"  {a=0x%x, b=0x%x, v=%u, name=\22%s\22},\0A\00", align 1
@.str.35 = private unnamed_addr constant [27 x i8] c"  {a=0x%x, b=0x%x, v=%u},\0A\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"'%c'\00", align 1
@.str.39 = private unnamed_addr constant [3 x i8] c"\\\22\00", align 1
@_ZTVN6icu_7515ValueNameGetterE = unnamed_addr constant { [5 x ptr] } { [5 x ptr] [ptr null, ptr @_ZTIN6icu_7515ValueNameGetterE, ptr @_ZN6icu_7515ValueNameGetterD1Ev, ptr @_ZN6icu_7515ValueNameGetterD0Ev, ptr @__cxa_pure_virtual] }, align 8
@_ZTVN10__cxxabiv117__class_type_infoE = external global [0 x ptr]
@_ZTSN6icu_7515ValueNameGetterE = constant [27 x i8] c"N6icu_7515ValueNameGetterE\00", align 1
@_ZTIN6icu_7515ValueNameGetterE = constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTSN6icu_7515ValueNameGetterE }, align 8
@.str.41 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.42 = private unnamed_addr constant [44 x i8] c"usrc_create(%s, %s): unable to create file\0A\00", align 1
@_ZTVN6icu_7513UnicodeStringE = external unnamed_addr constant { [13 x ptr] }, align 8
@_ZTVN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE = linkonce_odr unnamed_addr constant { [7 x ptr] } { [7 x ptr] [ptr null, ptr @_ZTIN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE, ptr @_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED2Ev, ptr @_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED0Ev, ptr @_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE6AppendEPKci, ptr @_ZN6icu_758ByteSink15GetAppendBufferEiiPciPi, ptr @_ZN6icu_758ByteSink5FlushEv] }, comdat, align 8
@_ZTVN10__cxxabiv120__si_class_type_infoE = external global [0 x ptr]
@_ZTSN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE = linkonce_odr constant [80 x i8] c"N6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE\00", comdat, align 1
@_ZTIN6icu_758ByteSinkE = external constant ptr
@_ZTIN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE = linkonce_odr constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTSN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE, ptr @_ZTIN6icu_758ByteSinkE }, comdat, align 8

@_ZN6icu_7515MaybeStackArrayIcLi40EEC1Ev = weak_odr unnamed_addr alias void (ptr), ptr @_ZN6icu_7515MaybeStackArrayIcLi40EEC2Ev
@_ZN6icu_7515MaybeStackArrayIcLi40EEC1Ei10UErrorCode = weak_odr unnamed_addr alias void (ptr, i32, i32), ptr @_ZN6icu_7515MaybeStackArrayIcLi40EEC2Ei10UErrorCode
@_ZN6icu_7515MaybeStackArrayIcLi40EED1Ev = weak_odr unnamed_addr alias void (ptr), ptr @_ZN6icu_7515MaybeStackArrayIcLi40EED2Ev
@_ZN6icu_7515MaybeStackArrayIcLi40EEC1EOS1_ = weak_odr unnamed_addr alias void (ptr, ptr), ptr @_ZN6icu_7515MaybeStackArrayIcLi40EEC2EOS1_
@_ZN6icu_7515ValueNameGetterD1Ev = unnamed_addr alias void (ptr), ptr @_ZN6icu_7515ValueNameGetterD2Ev

; Function Attrs: mustprogress nounwind uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EEC2Ev(ptr noundef nonnull align 8 dereferenceable(53) %this) unnamed_addr #0 comdat($_ZN6icu_7515MaybeStackArrayIcLi40EEC5Ev) align 2 {
entry:
  %stackArray = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 3
  store ptr %stackArray, ptr %this, align 8
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 40, ptr %capacity, align 8
  %needToRelease = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  store i8 0, ptr %needToRelease, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EEC2Ei10UErrorCode(ptr noundef nonnull align 8 dereferenceable(53) %this, i32 noundef %newCapacity, i32 noundef %status) unnamed_addr #1 comdat($_ZN6icu_7515MaybeStackArrayIcLi40EEC5Ei10UErrorCode) align 2 personality ptr @__gxx_personality_v0 {
entry:
  %stackArray.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 3
  store ptr %stackArray.i, ptr %this, align 8
  %capacity.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 40, ptr %capacity.i, align 8
  %needToRelease.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  store i8 0, ptr %needToRelease.i, align 4
  %cmp.i = icmp slt i32 %status, 1
  %cmp = icmp sgt i32 %newCapacity, 40
  %or.cond = and i1 %cmp, %cmp.i
  br i1 %or.cond, label %if.then.i, label %if.end8

lpad:                                             ; preds = %if.then.i.i, %if.then.i
  %0 = landingpad { ptr, i32 }
          cleanup
  tail call void @_ZN6icu_7515MaybeStackArrayIcLi40EED2Ev(ptr noundef nonnull align 8 dereferenceable(53) %this) #18
  resume { ptr, i32 } %0

if.then.i:                                        ; preds = %entry
  %conv.i3 = zext nneg i32 %newCapacity to i64
  %call.i4 = invoke noalias ptr @uprv_malloc_75(i64 noundef %conv.i3) #19
          to label %call.i.noexc unwind label %lpad

call.i.noexc:                                     ; preds = %if.then.i
  %cmp2.not.i = icmp eq ptr %call.i4, null
  br i1 %cmp2.not.i, label %if.end8, label %if.then3.i

if.then3.i:                                       ; preds = %call.i.noexc
  %1 = load i8, ptr %needToRelease.i, align 4
  %tobool.not.i.i = icmp eq i8 %1, 0
  br i1 %tobool.not.i.i, label %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then3.i
  %2 = load ptr, ptr %this, align 8
  invoke void @uprv_free_75(ptr noundef %2)
          to label %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit.i unwind label %lpad

_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit.i: ; preds = %if.then.i.i, %if.then3.i
  store ptr %call.i4, ptr %this, align 8
  store i32 %newCapacity, ptr %capacity.i, align 8
  store i8 1, ptr %needToRelease.i, align 4
  br label %if.end8

if.end8:                                          ; preds = %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit.i, %call.i.noexc, %entry
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: mustprogress uwtable
define weak_odr noundef ptr @_ZN6icu_7515MaybeStackArrayIcLi40EE6resizeEii(ptr noundef nonnull align 8 dereferenceable(53) %this, i32 noundef %newCapacity, i32 noundef %length) local_unnamed_addr #1 comdat align 2 {
entry:
  %cmp = icmp sgt i32 %newCapacity, 0
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %conv = zext nneg i32 %newCapacity to i64
  %call = tail call noalias ptr @uprv_malloc_75(i64 noundef %conv) #19
  %cmp2.not = icmp eq ptr %call, null
  br i1 %cmp2.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.then
  %cmp4 = icmp sgt i32 %length, 0
  br i1 %cmp4, label %if.then5, label %if.end14

if.then5:                                         ; preds = %if.then3
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  %0 = load i32, ptr %capacity, align 8
  %spec.select = tail call i32 @llvm.smin.i32(i32 %0, i32 %length)
  %length.addr.1 = tail call i32 @llvm.smin.i32(i32 %spec.select, i32 %newCapacity)
  %1 = load ptr, ptr %this, align 8
  %conv12 = sext i32 %length.addr.1 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call, ptr align 1 %1, i64 %conv12, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %if.then5, %if.then3
  %needToRelease.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %2 = load i8, ptr %needToRelease.i, align 4
  %tobool.not.i = icmp eq i8 %2, 0
  br i1 %tobool.not.i, label %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end14
  %3 = load ptr, ptr %this, align 8
  tail call void @uprv_free_75(ptr noundef %3)
  br label %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit

_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit: ; preds = %if.end14, %if.then.i
  store ptr %call, ptr %this, align 8
  %capacity16 = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 %newCapacity, ptr %capacity16, align 8
  store i8 1, ptr %needToRelease.i, align 4
  br label %return

return:                                           ; preds = %entry, %if.then, %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit
  %retval.0 = phi ptr [ %call, %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit ], [ null, %if.then ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EED2Ev(ptr noundef nonnull align 8 dereferenceable(53) %this) unnamed_addr #0 comdat($_ZN6icu_7515MaybeStackArrayIcLi40EED5Ev) align 2 personality ptr @__gxx_personality_v0 {
entry:
  %needToRelease.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %0 = load i8, ptr %needToRelease.i, align 4
  %tobool.not.i = icmp eq i8 %0, 0
  br i1 %tobool.not.i, label %invoke.cont, label %if.then.i

if.then.i:                                        ; preds = %entry
  %1 = load ptr, ptr %this, align 8
  invoke void @uprv_free_75(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry, %if.then.i
  ret void

terminate.lpad:                                   ; preds = %if.then.i
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  tail call void @__clang_call_terminate(ptr %3) #20
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv(ptr noundef nonnull align 8 dereferenceable(53) %this) local_unnamed_addr #1 comdat align 2 {
entry:
  %needToRelease = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %0 = load i8, ptr %needToRelease, align 4
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %this, align 8
  tail call void @uprv_free_75(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) local_unnamed_addr #2 comdat {
  %2 = tail call ptr @__cxa_begin_catch(ptr %0) #18
  tail call void @_ZSt9terminatev() #20
  unreachable
}

declare ptr @__cxa_begin_catch(ptr) local_unnamed_addr

declare void @_ZSt9terminatev() local_unnamed_addr

; Function Attrs: mustprogress nounwind uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EEC2EOS1_(ptr noundef nonnull align 8 dereferenceable(53) %this, ptr noundef nonnull align 8 dereferenceable(53) %src) unnamed_addr #0 comdat($_ZN6icu_7515MaybeStackArrayIcLi40EEC5EOS1_) align 2 personality ptr @__gxx_personality_v0 {
entry:
  %0 = load ptr, ptr %src, align 8
  store ptr %0, ptr %this, align 8
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  %capacity3 = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 1
  %1 = load i32, ptr %capacity3, align 8
  store i32 %1, ptr %capacity, align 8
  %needToRelease = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %needToRelease4 = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 2
  %2 = load i8, ptr %needToRelease4, align 4
  store i8 %2, ptr %needToRelease, align 4
  %3 = load ptr, ptr %src, align 8
  %stackArray = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 3
  %cmp = icmp eq ptr %3, %stackArray
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %stackArray6 = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 3
  store ptr %stackArray6, ptr %this, align 8
  %4 = load i32, ptr %capacity3, align 8
  %conv = sext i32 %4 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %stackArray6, ptr nonnull align 1 %3, i64 %conv, i1 false)
  br label %if.end

if.else:                                          ; preds = %entry
  store ptr %stackArray, ptr %src, align 8
  store i32 40, ptr %capacity3, align 8
  store i8 0, ptr %needToRelease4, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

; Function Attrs: mustprogress nounwind uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EE17resetToStackArrayEv(ptr noundef nonnull align 8 dereferenceable(53) %this) local_unnamed_addr #0 comdat align 2 {
entry:
  %stackArray = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 3
  store ptr %stackArray, ptr %this, align 8
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 40, ptr %capacity, align 8
  %needToRelease = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  store i8 0, ptr %needToRelease, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr noundef nonnull align 8 dereferenceable(53) ptr @_ZN6icu_7515MaybeStackArrayIcLi40EEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(53) %this, ptr noundef nonnull align 8 dereferenceable(53) %src) local_unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %needToRelease.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %0 = load i8, ptr %needToRelease.i, align 4
  %tobool.not.i = icmp eq i8 %0, 0
  br i1 %tobool.not.i, label %invoke.cont, label %if.then.i

if.then.i:                                        ; preds = %entry
  %1 = load ptr, ptr %this, align 8
  invoke void @uprv_free_75(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry, %if.then.i
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 1
  %2 = load i32, ptr %capacity, align 8
  %capacity2 = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 %2, ptr %capacity2, align 8
  %needToRelease = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 2
  %3 = load i8, ptr %needToRelease, align 4
  store i8 %3, ptr %needToRelease.i, align 4
  %4 = load ptr, ptr %src, align 8
  %stackArray = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 3
  %cmp = icmp eq ptr %4, %stackArray
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %invoke.cont
  %stackArray4 = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 3
  store ptr %stackArray4, ptr %this, align 8
  %5 = load i32, ptr %capacity, align 8
  %conv = sext i32 %5 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %stackArray4, ptr nonnull align 1 %4, i64 %conv, i1 false)
  br label %if.end

if.else:                                          ; preds = %invoke.cont
  store ptr %4, ptr %this, align 8
  store ptr %stackArray, ptr %src, align 8
  store i32 40, ptr %capacity, align 8
  store i8 0, ptr %needToRelease, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this

terminate.lpad:                                   ; preds = %if.then.i
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  tail call void @__clang_call_terminate(ptr %7) #20
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr noundef i32 @_ZNK6icu_7515MaybeStackArrayIcLi40EE11getCapacityEv(ptr noundef nonnull align 8 dereferenceable(53) %this) local_unnamed_addr #0 comdat align 2 {
entry:
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  %0 = load i32, ptr %capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr noundef ptr @_ZNK6icu_7515MaybeStackArrayIcLi40EE8getAliasEv(ptr noundef nonnull align 8 dereferenceable(53) %this) local_unnamed_addr #0 comdat align 2 {
entry:
  %0 = load ptr, ptr %this, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr noundef ptr @_ZNK6icu_7515MaybeStackArrayIcLi40EE13getArrayLimitEv(ptr noundef nonnull align 8 dereferenceable(53) %this) local_unnamed_addr #0 comdat align 2 {
entry:
  %0 = load ptr, ptr %this, align 8
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  %1 = load i32, ptr %capacity, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr noundef nonnull align 1 dereferenceable(1) ptr @_ZNK6icu_7515MaybeStackArrayIcLi40EEixEl(ptr noundef nonnull align 8 dereferenceable(53) %this, i64 noundef %i) local_unnamed_addr #0 comdat align 2 {
entry:
  %0 = load ptr, ptr %this, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 %i
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr noundef nonnull align 1 dereferenceable(1) ptr @_ZN6icu_7515MaybeStackArrayIcLi40EEixEl(ptr noundef nonnull align 8 dereferenceable(53) %this, i64 noundef %i) local_unnamed_addr #0 comdat align 2 {
entry:
  %0 = load ptr, ptr %this, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 %i
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EE12aliasInsteadEPci(ptr noundef nonnull align 8 dereferenceable(53) %this, ptr noundef %otherArray, i32 noundef %otherCapacity) local_unnamed_addr #1 comdat align 2 {
entry:
  %cmp = icmp ne ptr %otherArray, null
  %cmp2 = icmp sgt i32 %otherCapacity, 0
  %or.cond = and i1 %cmp, %cmp2
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %needToRelease.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %0 = load i8, ptr %needToRelease.i, align 4
  %tobool.not.i = icmp eq i8 %0, 0
  br i1 %tobool.not.i, label %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %1 = load ptr, ptr %this, align 8
  tail call void @uprv_free_75(ptr noundef %1)
  br label %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit

_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit: ; preds = %if.then, %if.then.i
  store ptr %otherArray, ptr %this, align 8
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 %otherCapacity, ptr %capacity, align 8
  store i8 0, ptr %needToRelease.i, align 4
  br label %if.end

if.end:                                           ; preds = %_ZN6icu_7515MaybeStackArrayIcLi40EE12releaseArrayEv.exit, %entry
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @uprv_malloc_75(i64 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress uwtable
define weak_odr noundef ptr @_ZN6icu_7515MaybeStackArrayIcLi40EE13orphanOrCloneEiRi(ptr noundef nonnull align 8 dereferenceable(53) %this, i32 noundef %length, ptr noundef nonnull align 4 dereferenceable(4) %resultCapacity) local_unnamed_addr #1 comdat align 2 {
entry:
  %needToRelease = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %0 = load i8, ptr %needToRelease, align 4
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %this, align 8
  br label %if.end14

if.else:                                          ; preds = %entry
  %cmp = icmp slt i32 %length, 1
  br i1 %cmp, label %return, label %if.else3

if.else3:                                         ; preds = %if.else
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  %2 = load i32, ptr %capacity, align 8
  %spec.select = tail call i32 @llvm.smin.i32(i32 %2, i32 %length)
  %conv = sext i32 %spec.select to i64
  %call = tail call noalias ptr @uprv_malloc_75(i64 noundef %conv) #19
  %cmp7 = icmp eq ptr %call, null
  br i1 %cmp7, label %return, label %do.body

do.body:                                          ; preds = %if.else3
  %3 = load ptr, ptr %this, align 8
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call, ptr align 1 %3, i64 %conv, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %do.body, %if.then
  %length.addr.1 = phi i32 [ %length, %if.then ], [ %spec.select, %do.body ]
  %p.0 = phi ptr [ %1, %if.then ], [ %call, %do.body ]
  store i32 %length.addr.1, ptr %resultCapacity, align 4
  %stackArray.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 3
  store ptr %stackArray.i, ptr %this, align 8
  %capacity.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 40, ptr %capacity.i, align 8
  store i8 0, ptr %needToRelease, align 4
  br label %return

return:                                           ; preds = %if.else3, %if.else, %if.end14
  %retval.0 = phi ptr [ %p.0, %if.end14 ], [ null, %if.else ], [ null, %if.else3 ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress uwtable
define weak_odr void @_ZN6icu_7515MaybeStackArrayIcLi40EE8copyFromERKS1_R10UErrorCode(ptr noundef nonnull align 8 dereferenceable(53) %this, ptr noundef nonnull align 8 dereferenceable(53) %src, ptr noundef nonnull align 4 dereferenceable(4) %status) local_unnamed_addr #1 comdat align 2 {
entry:
  %0 = load i32, ptr %status, align 4
  %cmp.i = icmp slt i32 %0, 1
  br i1 %cmp.i, label %if.end, label %do.end

if.end:                                           ; preds = %entry
  %capacity = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %src, i64 0, i32 1
  %1 = load i32, ptr %capacity, align 8
  %cmp.i3 = icmp sgt i32 %1, 0
  br i1 %cmp.i3, label %if.then.i, label %if.then3

if.then.i:                                        ; preds = %if.end
  %conv.i4 = zext nneg i32 %1 to i64
  %call.i = tail call noalias ptr @uprv_malloc_75(i64 noundef %conv.i4) #19
  %cmp2.not.i = icmp eq ptr %call.i, null
  br i1 %cmp2.not.i, label %if.then3, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i
  %needToRelease.i.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 2
  %2 = load i8, ptr %needToRelease.i.i, align 4
  %tobool.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool.not.i.i, label %do.body, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then3.i
  %3 = load ptr, ptr %this, align 8
  tail call void @uprv_free_75(ptr noundef %3)
  br label %do.body

if.then3:                                         ; preds = %if.then.i, %if.end
  store i32 7, ptr %status, align 4
  br label %do.end

do.body:                                          ; preds = %if.then.i.i, %if.then3.i
  store ptr %call.i, ptr %this, align 8
  %capacity16.i = getelementptr inbounds %"class.icu_75::MaybeStackArray", ptr %this, i64 0, i32 1
  store i32 %1, ptr %capacity16.i, align 8
  store i8 1, ptr %needToRelease.i.i, align 4
  %4 = load ptr, ptr %src, align 8
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %call.i, ptr align 1 %4, i64 %conv.i4, i1 false)
  br label %do.end

do.end:                                           ; preds = %entry, %do.body, %if.then3
  ret void
}

declare void @uprv_free_75(ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define void @_ZN6icu_7515ValueNameGetterD2Ev(ptr nocapture nonnull readnone align 8 %this) unnamed_addr #6 align 2 {
entry:
  ret void
}

; Function Attrs: mustprogress noreturn nounwind memory(inaccessiblemem: write) uwtable
define void @_ZN6icu_7515ValueNameGetterD0Ev(ptr nocapture nonnull readnone align 8 %this) unnamed_addr #7 align 2 {
entry:
  tail call void @llvm.trap() #20
  unreachable
}

; Function Attrs: cold noreturn nounwind memory(inaccessiblemem: write)
declare void @llvm.trap() #8

; Function Attrs: mustprogress nounwind uwtable
define noalias noundef ptr @usrc_create(ptr noundef %path, ptr noundef %filename, i32 noundef %copyrightYear, ptr noundef %generator) local_unnamed_addr #0 {
entry:
  %buffer.i9 = alloca [1024 x i8], align 16
  %t.i = alloca i64, align 8
  %buffer.i = alloca [1024 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %buffer.i)
  %cmp.i = icmp eq ptr %path, null
  br i1 %cmp.i, label %if.end14.i, label %if.else.i

if.else.i:                                        ; preds = %entry
  %call.i = call ptr @strcpy(ptr noundef nonnull dereferenceable(1) %buffer.i, ptr noundef nonnull dereferenceable(1) %path) #18
  %call3.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buffer.i) #21
  %add.ptr.i = getelementptr inbounds i8, ptr %buffer.i, i64 %call3.i
  %cmp5.i = icmp sgt i64 %call3.i, 0
  br i1 %cmp5.i, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %add.ptr6.i = getelementptr inbounds i8, ptr %add.ptr.i, i64 -1
  %0 = load i8, ptr %add.ptr6.i, align 1
  %cmp7.not.i = icmp eq i8 %0, 47
  br i1 %cmp7.not.i, label %if.end.i, label %if.then11.i

if.then11.i:                                      ; preds = %land.lhs.true.i
  %incdec.ptr.i = getelementptr inbounds i8, ptr %add.ptr.i, i64 1
  store i8 47, ptr %add.ptr.i, align 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then11.i, %land.lhs.true.i, %if.else.i
  %q.0.i = phi ptr [ %incdec.ptr.i, %if.then11.i ], [ %add.ptr.i, %land.lhs.true.i ], [ %add.ptr.i, %if.else.i ]
  %call12.i = call ptr @strcpy(ptr noundef nonnull dereferenceable(1) %q.0.i, ptr noundef nonnull dereferenceable(1) %filename) #18
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.end.i, %entry
  %p.0.i = phi ptr [ %buffer.i, %if.end.i ], [ %filename, %entry ]
  %call15.i = call noalias ptr @fopen(ptr noundef %p.0.i, ptr noundef nonnull @.str.41)
  %cmp16.i = icmp eq ptr %call15.i, null
  br i1 %cmp16.i, label %_ZL24usrc_createWithoutHeaderPKcS0_.exit.thread, label %if.end

_ZL24usrc_createWithoutHeaderPKcS0_.exit.thread:  ; preds = %if.end14.i
  %1 = load ptr, ptr @stderr, align 8
  %cond.i = select i1 %cmp.i, ptr @.str.10, ptr %path
  %call19.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef nonnull @.str.42, ptr noundef nonnull %cond.i, ptr noundef %filename) #22
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buffer.i)
  br label %return

if.end:                                           ; preds = %if.end14.i
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buffer.i)
  %call.i6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call15.i, ptr noundef nonnull @.str.2, ptr noundef nonnull @.str, i32 noundef %copyrightYear, ptr noundef nonnull @.str)
  %cmp.i7 = icmp slt i32 %copyrightYear, 2017
  br i1 %cmp.i7, label %if.then.i, label %usrc_writeCopyrightHeader.exit

if.then.i:                                        ; preds = %if.end
  %call1.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call15.i, ptr noundef nonnull @.str.3, ptr noundef nonnull @.str, ptr noundef nonnull @.str)
  br label %usrc_writeCopyrightHeader.exit

usrc_writeCopyrightHeader.exit:                   ; preds = %if.end, %if.then.i
  call void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %buffer.i9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %t.i)
  %call.i10 = call i64 @time(ptr noundef nonnull %t.i) #18
  %call1.i11 = call ptr @localtime(ptr noundef nonnull %t.i) #18
  %cmp.i12 = icmp eq ptr %generator, null
  br i1 %cmp.i12, label %if.then.i14, label %usrc_writeFileNameGeneratedBy.exit

if.then.i14:                                      ; preds = %usrc_writeCopyrightHeader.exit
  %call2.i = call i64 @strftime(ptr noundef nonnull %buffer.i9, i64 noundef 1024, ptr noundef nonnull @.str.5, ptr noundef %call1.i11) #18
  br label %usrc_writeFileNameGeneratedBy.exit

usrc_writeFileNameGeneratedBy.exit:               ; preds = %usrc_writeCopyrightHeader.exit, %if.then.i14
  %generator.sink.i = phi ptr [ %buffer.i9, %if.then.i14 ], [ %generator, %usrc_writeCopyrightHeader.exit ]
  %call5.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call15.i, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str, ptr noundef nonnull @.str, ptr noundef %filename, ptr noundef nonnull @.str, ptr noundef nonnull @.str, ptr noundef nonnull %generator.sink.i)
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buffer.i9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %t.i)
  br label %return

return:                                           ; preds = %_ZL24usrc_createWithoutHeaderPKcS0_.exit.thread, %usrc_writeFileNameGeneratedBy.exit
  ret ptr %call15.i
}

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeCopyrightHeader(ptr nocapture noundef %f, ptr noundef %prefix, i32 noundef %copyrightYear) local_unnamed_addr #9 {
entry:
  %call = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.2, ptr noundef %prefix, i32 noundef %copyrightYear, ptr noundef %prefix)
  %cmp = icmp slt i32 %copyrightYear, 2017
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.3, ptr noundef %prefix, ptr noundef %prefix)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define void @usrc_writeFileNameGeneratedBy(ptr nocapture noundef %f, ptr noundef %prefix, ptr noundef %filename, ptr noundef %generator) local_unnamed_addr #0 {
entry:
  %buffer = alloca [1024 x i8], align 16
  %t = alloca i64, align 8
  %call = call i64 @time(ptr noundef nonnull %t) #18
  %call1 = call ptr @localtime(ptr noundef nonnull %t) #18
  %cmp = icmp eq ptr %generator, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @strftime(ptr noundef nonnull %buffer, i64 noundef 1024, ptr noundef nonnull @.str.5, ptr noundef %call1) #18
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %generator.sink = phi ptr [ %buffer, %if.then ], [ %generator, %entry ]
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.4, ptr noundef %prefix, ptr noundef %prefix, ptr noundef %filename, ptr noundef %prefix, ptr noundef %prefix, ptr noundef nonnull %generator.sink)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define noalias noundef ptr @usrc_createTextData(ptr noundef %path, ptr noundef %filename, i32 noundef %copyrightYear, ptr noundef %generator) local_unnamed_addr #0 {
entry:
  %buffer.i9 = alloca [1024 x i8], align 16
  %t.i = alloca i64, align 8
  %buffer.i = alloca [1024 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %buffer.i)
  %cmp.i = icmp eq ptr %path, null
  br i1 %cmp.i, label %if.end14.i, label %if.else.i

if.else.i:                                        ; preds = %entry
  %call.i = call ptr @strcpy(ptr noundef nonnull dereferenceable(1) %buffer.i, ptr noundef nonnull dereferenceable(1) %path) #18
  %call3.i = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buffer.i) #21
  %add.ptr.i = getelementptr inbounds i8, ptr %buffer.i, i64 %call3.i
  %cmp5.i = icmp sgt i64 %call3.i, 0
  br i1 %cmp5.i, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %add.ptr6.i = getelementptr inbounds i8, ptr %add.ptr.i, i64 -1
  %0 = load i8, ptr %add.ptr6.i, align 1
  %cmp7.not.i = icmp eq i8 %0, 47
  br i1 %cmp7.not.i, label %if.end.i, label %if.then11.i

if.then11.i:                                      ; preds = %land.lhs.true.i
  %incdec.ptr.i = getelementptr inbounds i8, ptr %add.ptr.i, i64 1
  store i8 47, ptr %add.ptr.i, align 1
  br label %if.end.i

if.end.i:                                         ; preds = %if.then11.i, %land.lhs.true.i, %if.else.i
  %q.0.i = phi ptr [ %incdec.ptr.i, %if.then11.i ], [ %add.ptr.i, %land.lhs.true.i ], [ %add.ptr.i, %if.else.i ]
  %call12.i = call ptr @strcpy(ptr noundef nonnull dereferenceable(1) %q.0.i, ptr noundef nonnull dereferenceable(1) %filename) #18
  br label %if.end14.i

if.end14.i:                                       ; preds = %if.end.i, %entry
  %p.0.i = phi ptr [ %buffer.i, %if.end.i ], [ %filename, %entry ]
  %call15.i = call noalias ptr @fopen(ptr noundef %p.0.i, ptr noundef nonnull @.str.41)
  %cmp16.i = icmp eq ptr %call15.i, null
  br i1 %cmp16.i, label %_ZL24usrc_createWithoutHeaderPKcS0_.exit.thread, label %if.end

_ZL24usrc_createWithoutHeaderPKcS0_.exit.thread:  ; preds = %if.end14.i
  %1 = load ptr, ptr @stderr, align 8
  %cond.i = select i1 %cmp.i, ptr @.str.10, ptr %path
  %call19.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef nonnull @.str.42, ptr noundef nonnull %cond.i, ptr noundef %filename) #22
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buffer.i)
  br label %return

if.end:                                           ; preds = %if.end14.i
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buffer.i)
  %call.i6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call15.i, ptr noundef nonnull @.str.2, ptr noundef nonnull @.str.1, i32 noundef %copyrightYear, ptr noundef nonnull @.str.1)
  %cmp.i7 = icmp slt i32 %copyrightYear, 2017
  br i1 %cmp.i7, label %if.then.i, label %usrc_writeCopyrightHeader.exit

if.then.i:                                        ; preds = %if.end
  %call1.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call15.i, ptr noundef nonnull @.str.3, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.1)
  br label %usrc_writeCopyrightHeader.exit

usrc_writeCopyrightHeader.exit:                   ; preds = %if.end, %if.then.i
  call void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %buffer.i9)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %t.i)
  %call.i10 = call i64 @time(ptr noundef nonnull %t.i) #18
  %call1.i11 = call ptr @localtime(ptr noundef nonnull %t.i) #18
  %cmp.i12 = icmp eq ptr %generator, null
  br i1 %cmp.i12, label %if.then.i14, label %usrc_writeFileNameGeneratedBy.exit

if.then.i14:                                      ; preds = %usrc_writeCopyrightHeader.exit
  %call2.i = call i64 @strftime(ptr noundef nonnull %buffer.i9, i64 noundef 1024, ptr noundef nonnull @.str.5, ptr noundef %call1.i11) #18
  br label %usrc_writeFileNameGeneratedBy.exit

usrc_writeFileNameGeneratedBy.exit:               ; preds = %usrc_writeCopyrightHeader.exit, %if.then.i14
  %generator.sink.i = phi ptr [ %buffer.i9, %if.then.i14 ], [ %generator, %usrc_writeCopyrightHeader.exit ]
  %call5.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call15.i, ptr noundef nonnull @.str.4, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.1, ptr noundef %filename, ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.1, ptr noundef nonnull %generator.sink.i)
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buffer.i9)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %t.i)
  br label %return

return:                                           ; preds = %_ZL24usrc_createWithoutHeaderPKcS0_.exit.thread, %usrc_writeFileNameGeneratedBy.exit
  ret ptr %call15.i
}

; Function Attrs: nofree nounwind
declare noundef i32 @fprintf(ptr nocapture noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #10

; Function Attrs: nounwind
declare i64 @time(ptr noundef) local_unnamed_addr #11

; Function Attrs: nounwind
declare ptr @localtime(ptr noundef) local_unnamed_addr #11

; Function Attrs: nounwind
declare i64 @strftime(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #11

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeArray(ptr nocapture noundef %f, ptr noundef readonly %prefix, ptr nocapture noundef readonly %p, i32 noundef %width, i32 noundef %length, ptr nocapture noundef readonly %indent, ptr noundef readonly %postfix) local_unnamed_addr #9 {
entry:
  %0 = add i32 %width, -8
  %1 = tail call i32 @llvm.fshl.i32(i32 %0, i32 %0, i32 29)
  switch i32 %1, label %sw.default [
    i32 0, label %sw.epilog
    i32 1, label %sw.bb1
    i32 3, label %sw.bb2
    i32 7, label %sw.bb3
  ]

sw.bb1:                                           ; preds = %entry
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %2 = load ptr, ptr @stderr, align 8
  %conv = sext i32 %width to i64
  %call = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef nonnull @.str.6, i64 noundef %conv) #22
  br label %if.end37

sw.epilog:                                        ; preds = %entry, %sw.bb3, %sw.bb2, %sw.bb1
  %p8.0 = phi ptr [ null, %sw.bb3 ], [ null, %sw.bb2 ], [ null, %sw.bb1 ], [ %p, %entry ]
  %p16.0 = phi ptr [ null, %sw.bb3 ], [ null, %sw.bb2 ], [ %p, %sw.bb1 ], [ null, %entry ]
  %p32.0 = phi ptr [ null, %sw.bb3 ], [ %p, %sw.bb2 ], [ null, %sw.bb1 ], [ null, %entry ]
  %p64.0 = phi ptr [ %p, %sw.bb3 ], [ null, %sw.bb2 ], [ null, %sw.bb1 ], [ null, %entry ]
  %cmp.not = icmp eq ptr %prefix, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %sw.epilog
  %conv4 = sext i32 %length to i64
  %call5 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull %prefix, i64 noundef %conv4)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.epilog
  %cmp626 = icmp sgt i32 %length, 0
  br i1 %cmp626, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.end
  %wide.trip.count = zext nneg i32 %length to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %sw.epilog30.thread
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %sw.epilog30.thread ]
  %col.029 = phi i32 [ 0, %for.body.preheader ], [ %inc33, %sw.epilog30.thread ]
  %cmp7.not = icmp eq i64 %indvars.iv, 0
  br i1 %cmp7.not, label %if.end15, label %if.then8

if.then8:                                         ; preds = %for.body
  %cmp9 = icmp slt i32 %col.029, 16
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then8
  %call11 = tail call i32 @fputc(i32 noundef 44, ptr noundef %f)
  br label %if.end15

if.else:                                          ; preds = %if.then8
  %3 = tail call i64 @fwrite(ptr nonnull @.str.7, i64 2, i64 1, ptr %f)
  %call13 = tail call i32 @fputs(ptr noundef %indent, ptr noundef %f)
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %if.else, %for.body
  %col.1 = phi i32 [ %col.029, %if.then10 ], [ 0, %if.else ], [ %col.029, %for.body ]
  switch i32 %1, label %sw.epilog30.thread [
    i32 0, label %sw.bb16
    i32 1, label %sw.bb18
    i32 3, label %sw.bb22
    i32 7, label %sw.bb26
  ]

sw.bb16:                                          ; preds = %if.end15
  %arrayidx = getelementptr inbounds i8, ptr %p8.0, i64 %indvars.iv
  %4 = load i8, ptr %arrayidx, align 1
  %conv17 = zext i8 %4 to i64
  br label %sw.epilog30

sw.bb18:                                          ; preds = %if.end15
  %arrayidx20 = getelementptr inbounds i16, ptr %p16.0, i64 %indvars.iv
  %5 = load i16, ptr %arrayidx20, align 2
  %conv21 = zext i16 %5 to i64
  br label %sw.epilog30

sw.bb22:                                          ; preds = %if.end15
  %arrayidx24 = getelementptr inbounds i32, ptr %p32.0, i64 %indvars.iv
  %6 = load i32, ptr %arrayidx24, align 4
  %conv25 = zext i32 %6 to i64
  br label %sw.epilog30

sw.bb26:                                          ; preds = %if.end15
  %arrayidx28 = getelementptr inbounds i64, ptr %p64.0, i64 %indvars.iv
  %7 = load i64, ptr %arrayidx28, align 8
  br label %sw.epilog30

sw.epilog30:                                      ; preds = %sw.bb26, %sw.bb22, %sw.bb18, %sw.bb16
  %value.0 = phi i64 [ %7, %sw.bb26 ], [ %conv25, %sw.bb22 ], [ %conv21, %sw.bb18 ], [ %conv17, %sw.bb16 ]
  %cmp31 = icmp slt i64 %value.0, 10
  %spec.select = select i1 %cmp31, ptr @.str.8, ptr @.str.9
  br label %sw.epilog30.thread

sw.epilog30.thread:                               ; preds = %sw.epilog30, %if.end15
  %value.024 = phi i64 [ 0, %if.end15 ], [ %value.0, %sw.epilog30 ]
  %8 = phi ptr [ @.str.8, %if.end15 ], [ %spec.select, %sw.epilog30 ]
  %call32 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull %8, i64 noundef %value.024)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %inc33 = add nsw i32 %col.1, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !4

for.end:                                          ; preds = %sw.epilog30.thread, %if.end
  %cmp34.not = icmp eq ptr %postfix, null
  br i1 %cmp34.not, label %if.end37, label %if.then35

if.then35:                                        ; preds = %for.end
  %call36 = tail call i32 @fputs(ptr noundef nonnull %postfix, ptr noundef %f)
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %for.end, %sw.default
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @fputc(i32 noundef, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nofree nounwind
declare noundef i32 @fputs(ptr nocapture noundef readonly, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeUTrie2Arrays(ptr nocapture noundef %f, ptr noundef %indexPrefix, ptr noundef %data32Prefix, ptr nocapture noundef readonly %pTrie, ptr noundef %postfix) local_unnamed_addr #9 {
entry:
  %data32 = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 2
  %0 = load ptr, ptr %data32, align 8
  %cmp = icmp eq ptr %0, null
  %1 = load ptr, ptr %pTrie, align 8
  %indexLength = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 3
  %2 = load i32, ptr %indexLength, align 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %dataLength = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 4
  %3 = load i32, ptr %dataLength, align 4
  %add = add nsw i32 %3, %2
  tail call void @usrc_writeArray(ptr noundef %f, ptr noundef %indexPrefix, ptr noundef %1, i32 noundef 16, i32 noundef %add, ptr noundef nonnull @.str.10, ptr noundef %postfix)
  br label %if.end

if.else:                                          ; preds = %entry
  tail call void @usrc_writeArray(ptr noundef %f, ptr noundef %indexPrefix, ptr noundef %1, i32 noundef 16, i32 noundef %2, ptr noundef nonnull @.str.10, ptr noundef %postfix)
  %4 = load ptr, ptr %data32, align 8
  %dataLength4 = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 4
  %5 = load i32, ptr %dataLength4, align 4
  tail call void @usrc_writeArray(ptr noundef %f, ptr noundef %data32Prefix, ptr noundef %4, i32 noundef 32, i32 noundef %5, ptr noundef nonnull @.str.10, ptr noundef %postfix)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeUTrie2Struct(ptr nocapture noundef %f, ptr noundef readonly %prefix, ptr nocapture noundef readonly %pTrie, ptr noundef %indexName, ptr noundef %data32Name, ptr noundef readonly %postfix) local_unnamed_addr #9 {
entry:
  %cmp.not = icmp eq ptr %prefix, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @fputs(ptr noundef nonnull %prefix, ptr noundef %f)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %data32 = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 2
  %0 = load ptr, ptr %data32, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %indexLength = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 3
  %1 = load i32, ptr %indexLength, align 8
  %conv = sext i32 %1 to i64
  %call3 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.11, ptr noundef %indexName, ptr noundef %indexName, i64 noundef %conv)
  br label %if.end5

if.else:                                          ; preds = %if.end
  %call4 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.12, ptr noundef %indexName, ptr noundef %data32Name)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then2
  %indexLength6 = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 3
  %2 = load i32, ptr %indexLength6, align 8
  %conv7 = sext i32 %2 to i64
  %dataLength = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 4
  %3 = load i32, ptr %dataLength, align 4
  %conv8 = sext i32 %3 to i64
  %index2NullOffset = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 5
  %4 = load i16, ptr %index2NullOffset, align 8
  %conv9 = sext i16 %4 to i32
  %dataNullOffset = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 6
  %5 = load i16, ptr %dataNullOffset, align 2
  %conv10 = sext i16 %5 to i32
  %initialValue = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 7
  %6 = load i32, ptr %initialValue, align 4
  %conv11 = zext i32 %6 to i64
  %errorValue = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 8
  %7 = load i32, ptr %errorValue, align 8
  %conv12 = zext i32 %7 to i64
  %highStart = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 9
  %8 = load i32, ptr %highStart, align 4
  %conv13 = sext i32 %8 to i64
  %highValueIndex = getelementptr inbounds %struct.UTrie2, ptr %pTrie, i64 0, i32 10
  %9 = load i32, ptr %highValueIndex, align 8
  %conv14 = sext i32 %9 to i64
  %call15 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.13, i64 noundef %conv7, i64 noundef %conv8, i32 noundef %conv9, i32 noundef %conv10, i64 noundef %conv11, i64 noundef %conv12, i64 noundef %conv13, i64 noundef %conv14)
  %cmp16.not = icmp eq ptr %postfix, null
  br i1 %cmp16.not, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end5
  %call18 = tail call i32 @fputs(ptr noundef nonnull %postfix, ptr noundef %f)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end5
  ret void
}

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeUCPTrieArrays(ptr nocapture noundef %f, ptr noundef %indexPrefix, ptr noundef %dataPrefix, ptr nocapture noundef readonly %pTrie, ptr noundef %postfix, i32 noundef %syntax) local_unnamed_addr #9 {
entry:
  %cmp = icmp eq i32 %syntax, 1
  %cond = select i1 %cmp, ptr @.str.14, ptr @.str.10
  %0 = load ptr, ptr %pTrie, align 8
  %indexLength = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 2
  %1 = load i32, ptr %indexLength, align 8
  tail call void @usrc_writeArray(ptr noundef %f, ptr noundef %indexPrefix, ptr noundef %0, i32 noundef 16, i32 noundef %1, ptr noundef nonnull %cond, ptr noundef %postfix)
  %valueWidth = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 7
  %2 = load i8, ptr %valueWidth, align 1
  switch i8 %2, label %cond.false6 [
    i8 0, label %cond.end12
    i8 1, label %cond.end12.fold.split
  ]

cond.false6:                                      ; preds = %entry
  %cmp9 = icmp eq i8 %2, 2
  %cond10 = select i1 %cmp9, i32 8, i32 0
  br label %cond.end12

cond.end12.fold.split:                            ; preds = %entry
  br label %cond.end12

cond.end12:                                       ; preds = %entry, %cond.end12.fold.split, %cond.false6
  %cond13 = phi i32 [ 16, %entry ], [ %cond10, %cond.false6 ], [ 32, %cond.end12.fold.split ]
  %data = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 1
  %3 = load ptr, ptr %data, align 8
  %dataLength = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 3
  %4 = load i32, ptr %dataLength, align 4
  tail call void @usrc_writeArray(ptr noundef %f, ptr noundef %dataPrefix, ptr noundef %3, i32 noundef %cond13, i32 noundef %4, ptr noundef nonnull %cond, ptr noundef %postfix)
  ret void
}

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeUCPTrieStruct(ptr nocapture noundef %f, ptr noundef readonly %prefix, ptr nocapture noundef readonly %pTrie, ptr noundef %indexName, ptr noundef %dataName, ptr noundef readonly %postfix, i32 noundef %syntax) local_unnamed_addr #9 {
entry:
  %cmp.not = icmp eq ptr %prefix, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @fputs(ptr noundef nonnull %prefix, ptr noundef %f)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp1 = icmp eq i32 %syntax, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.15, ptr noundef %indexName, ptr noundef %dataName)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %cond = phi ptr [ @.str.16, %if.then2 ], [ @.str.17, %if.end ]
  %indexLength = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 2
  %0 = load i32, ptr %indexLength, align 8
  %conv = sext i32 %0 to i64
  %dataLength = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 3
  %1 = load i32, ptr %dataLength, align 4
  %conv6 = sext i32 %1 to i64
  %highStart = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 4
  %2 = load i32, ptr %highStart, align 8
  %conv7 = sext i32 %2 to i64
  %shifted12HighStart = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 5
  %3 = load i16, ptr %shifted12HighStart, align 4
  %conv8 = zext i16 %3 to i32
  %type = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 6
  %4 = load i8, ptr %type, align 2
  %conv9 = sext i8 %4 to i32
  %valueWidth = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 7
  %5 = load i8, ptr %valueWidth, align 1
  %conv10 = sext i8 %5 to i32
  %index3NullOffset = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 10
  %6 = load i16, ptr %index3NullOffset, align 2
  %conv11 = zext i16 %6 to i32
  %dataNullOffset = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 11
  %7 = load i32, ptr %dataNullOffset, align 8
  %conv12 = sext i32 %7 to i64
  %nullValue = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 12
  %8 = load i32, ptr %nullValue, align 4
  %conv13 = zext i32 %8 to i64
  %call14 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull %cond, i64 noundef %conv, i64 noundef %conv6, i64 noundef %conv7, i32 noundef %conv8, i32 noundef %conv9, i32 noundef %conv10, i32 noundef %conv11, i64 noundef %conv12, i64 noundef %conv13)
  %cmp15.not = icmp eq ptr %postfix, null
  br i1 %cmp15.not, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end4
  %call17 = tail call i32 @fputs(ptr noundef nonnull %postfix, ptr noundef %f)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define void @usrc_writeUCPTrie(ptr nocapture noundef %f, ptr noundef %name, ptr nocapture noundef readonly %pTrie, i32 noundef %syntax) local_unnamed_addr #0 {
entry:
  %line = alloca [100 x i8], align 16
  %line2 = alloca [100 x i8], align 16
  %line3 = alloca [100 x i8], align 16
  %line4 = alloca [100 x i8], align 16
  %valueWidth = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 7
  %0 = load i8, ptr %valueWidth, align 1
  switch i8 %0, label %cond.false5 [
    i8 0, label %cond.end10
    i8 1, label %cond.end10.fold.split
  ]

cond.false5:                                      ; preds = %entry
  %cmp8 = icmp eq i8 %0, 2
  %cond = select i1 %cmp8, i32 8, i32 0
  br label %cond.end10

cond.end10.fold.split:                            ; preds = %entry
  br label %cond.end10

cond.end10:                                       ; preds = %entry, %cond.end10.fold.split, %cond.false5
  %cond11 = phi i32 [ 16, %entry ], [ %cond, %cond.false5 ], [ 32, %cond.end10.fold.split ]
  switch i32 %syntax, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb16
  ]

sw.bb:                                            ; preds = %cond.end10
  %call = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %line, i64 noundef 100, ptr noundef nonnull @.str.18, ptr noundef %name) #18
  %call13 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %line2, i64 noundef 100, ptr noundef nonnull @.str.19, i32 noundef %cond11, ptr noundef %name) #18
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(6) %line3, ptr noundef nonnull align 1 dereferenceable(6) @.str.20, i64 6, i1 false)
  br label %sw.epilog

sw.bb16:                                          ; preds = %cond.end10
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(13) %line, ptr noundef nonnull align 1 dereferenceable(13) @.str.21, i64 13, i1 false)
  %call20 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %line2, i64 noundef 100, ptr noundef nonnull @.str.22, i32 noundef %cond11) #18
  store i32 679178, ptr %line3, align 16
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end10
  tail call void @abort() #20
  unreachable

sw.epilog:                                        ; preds = %sw.bb16, %sw.bb
  %cmp.i = icmp eq i32 %syntax, 1
  %cond.i = select i1 %cmp.i, ptr @.str.14, ptr @.str.10
  %1 = load ptr, ptr %pTrie, align 8
  %indexLength.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 2
  %2 = load i32, ptr %indexLength.i, align 8
  call void @usrc_writeArray(ptr noundef %f, ptr noundef nonnull %line, ptr noundef %1, i32 noundef 16, i32 noundef %2, ptr noundef nonnull %cond.i, ptr noundef nonnull %line3)
  %3 = load i8, ptr %valueWidth, align 1
  switch i8 %3, label %cond.false6.i [
    i8 0, label %usrc_writeUCPTrieArrays.exit
    i8 1, label %cond.end12.fold.split.i
  ]

cond.false6.i:                                    ; preds = %sw.epilog
  %cmp9.i = icmp eq i8 %3, 2
  %cond10.i = select i1 %cmp9.i, i32 8, i32 0
  br label %usrc_writeUCPTrieArrays.exit

cond.end12.fold.split.i:                          ; preds = %sw.epilog
  br label %usrc_writeUCPTrieArrays.exit

usrc_writeUCPTrieArrays.exit:                     ; preds = %sw.epilog, %cond.false6.i, %cond.end12.fold.split.i
  %cond13.i = phi i32 [ 16, %sw.epilog ], [ %cond10.i, %cond.false6.i ], [ 32, %cond.end12.fold.split.i ]
  %data.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 1
  %4 = load ptr, ptr %data.i, align 8
  %dataLength.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 3
  %5 = load i32, ptr %dataLength.i, align 4
  call void @usrc_writeArray(ptr noundef %f, ptr noundef nonnull %line2, ptr noundef %4, i32 noundef %cond13.i, i32 noundef %5, ptr noundef nonnull %cond.i, ptr noundef nonnull %line3)
  switch i32 %syntax, label %sw.default39 [
    i32 0, label %if.then2.i
    i32 1, label %sw.epilog40
  ]

sw.default39:                                     ; preds = %usrc_writeUCPTrieArrays.exit
  call void @abort() #20
  unreachable

sw.epilog40:                                      ; preds = %usrc_writeUCPTrieArrays.exit
  store i8 0, ptr %line, align 16
  store i8 0, ptr %line2, align 16
  store i8 0, ptr %line3, align 16
  store i8 0, ptr %line4, align 16
  %call.i = call i32 @fputs(ptr noundef nonnull %line, ptr noundef %f)
  br label %usrc_writeUCPTrieStruct.exit

if.then2.i:                                       ; preds = %usrc_writeUCPTrieArrays.exit
  %call28 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %line, i64 noundef 100, ptr noundef nonnull @.str.24, ptr noundef %name) #18
  %call30 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %line2, i64 noundef 100, ptr noundef nonnull @.str.25, ptr noundef %name) #18
  %call32 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %line3, i64 noundef 100, ptr noundef nonnull @.str.26, ptr noundef %name) #18
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(5) %line4, ptr noundef nonnull align 1 dereferenceable(5) @.str.27, i64 5, i1 false)
  %call.i18 = call i32 @fputs(ptr noundef nonnull %line, ptr noundef %f)
  %call3.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.15, ptr noundef nonnull %line2, ptr noundef nonnull %line3)
  br label %usrc_writeUCPTrieStruct.exit

usrc_writeUCPTrieStruct.exit:                     ; preds = %sw.epilog40, %if.then2.i
  %cond.i14 = phi ptr [ @.str.16, %if.then2.i ], [ @.str.17, %sw.epilog40 ]
  %6 = load i32, ptr %indexLength.i, align 8
  %conv.i = sext i32 %6 to i64
  %7 = load i32, ptr %dataLength.i, align 4
  %conv6.i = sext i32 %7 to i64
  %highStart.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 4
  %8 = load i32, ptr %highStart.i, align 8
  %conv7.i = sext i32 %8 to i64
  %shifted12HighStart.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 5
  %9 = load i16, ptr %shifted12HighStart.i, align 4
  %conv8.i = zext i16 %9 to i32
  %type.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 6
  %10 = load i8, ptr %type.i, align 2
  %conv9.i = sext i8 %10 to i32
  %11 = load i8, ptr %valueWidth, align 1
  %conv10.i = sext i8 %11 to i32
  %index3NullOffset.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 10
  %12 = load i16, ptr %index3NullOffset.i, align 2
  %conv11.i = zext i16 %12 to i32
  %dataNullOffset.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 11
  %13 = load i32, ptr %dataNullOffset.i, align 8
  %conv12.i = sext i32 %13 to i64
  %nullValue.i = getelementptr inbounds %struct.UCPTrie, ptr %pTrie, i64 0, i32 12
  %14 = load i32, ptr %nullValue.i, align 4
  %conv13.i = zext i32 %14 to i64
  %call14.i = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull %cond.i14, i64 noundef %conv.i, i64 noundef %conv6.i, i64 noundef %conv7.i, i32 noundef %conv8.i, i32 noundef %conv9.i, i32 noundef %conv10.i, i32 noundef %conv11.i, i64 noundef %conv12.i, i64 noundef %conv13.i)
  %call17.i = call i32 @fputs(ptr noundef nonnull %line4, ptr noundef %f)
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @snprintf(ptr noalias nocapture noundef writeonly, i64 noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #10

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #12

; Function Attrs: mustprogress uwtable
define void @usrc_writeUnicodeSet(ptr nocapture noundef %f, ptr noundef nonnull %pSet, i32 noundef %syntax) local_unnamed_addr #1 personality ptr @__gxx_personality_v0 {
entry:
  %it = alloca %"class.icu_75::UnicodeSetIterator", align 8
  call void @_ZN6icu_7518UnicodeSetIteratorC1ERKNS_10UnicodeSetE(ptr noundef nonnull align 8 dereferenceable(64) %it, ptr noundef nonnull align 8 dereferenceable(200) %pSet)
  %0 = call i64 @fwrite(ptr nonnull @.str.28, i64 50, i64 1, ptr %f)
  %1 = call i64 @fwrite(ptr nonnull @.str.29, i64 11, i64 1, ptr %f)
  %codepoint.i = getelementptr inbounds %"class.icu_75::UnicodeSetIterator", ptr %it, i64 0, i32 1
  %codepointEnd.i = getelementptr inbounds %"class.icu_75::UnicodeSetIterator", ptr %it, i64 0, i32 2
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %invoke.cont21, %entry
  %seenFirstString.0.ph = phi i8 [ %seenFirstString.1, %invoke.cont21 ], [ 0, %entry ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %if.else
  %call5 = invoke noundef signext i8 @_ZN6icu_7518UnicodeSetIterator9nextRangeEv(ptr noundef nonnull align 8 dereferenceable(64) %it)
          to label %invoke.cont4 unwind label %lpad.loopexit

invoke.cont4:                                     ; preds = %while.cond
  %tobool.not = icmp eq i8 %call5, 0
  br i1 %tobool.not, label %while.end, label %while.body

while.body:                                       ; preds = %invoke.cont4
  %2 = load i32, ptr %codepoint.i, align 8
  %tobool8.not = icmp sgt i32 %2, -1
  br i1 %tobool8.not, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %3 = and i8 %seenFirstString.0.ph, 1
  %tobool9.not = icmp eq i8 %3, 0
  br i1 %tobool9.not, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  %4 = call i64 @fwrite(ptr nonnull @.str.30, i64 14, i64 1, ptr %f)
  br label %if.end

lpad.loopexit:                                    ; preds = %while.cond
  %lpad.loopexit10 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad.loopexit.split-lp:                           ; preds = %if.end, %invoke.cont19
  %lpad.loopexit.split-lp11 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad:                                             ; preds = %lpad.loopexit.split-lp, %lpad.loopexit
  %lpad.phi = phi { ptr, i32 } [ %lpad.loopexit10, %lpad.loopexit ], [ %lpad.loopexit.split-lp11, %lpad.loopexit.split-lp ]
  call void @_ZN6icu_7518UnicodeSetIteratorD1Ev(ptr noundef nonnull align 8 dereferenceable(64) %it) #18
  resume { ptr, i32 } %lpad.phi

if.end:                                           ; preds = %if.then10, %if.then
  %seenFirstString.1 = phi i8 [ %seenFirstString.0.ph, %if.then ], [ 1, %if.then10 ]
  %call14 = invoke noundef nonnull align 8 dereferenceable(64) ptr @_ZN6icu_7518UnicodeSetIterator9getStringEv(ptr noundef nonnull align 8 dereferenceable(64) %it)
          to label %invoke.cont13 unwind label %lpad.loopexit.split-lp

invoke.cont13:                                    ; preds = %if.end
  %5 = call i64 @fwrite(ptr nonnull @.str.14, i64 2, i64 1, ptr %f)
  %fUnion.i = getelementptr inbounds %"class.icu_75::UnicodeString", ptr %call14, i64 0, i32 1
  %6 = load i16, ptr %fUnion.i, align 8
  %conv1.i = zext i16 %6 to i32
  %and.i = and i32 %conv1.i, 17
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else.i, label %invoke.cont19

if.else.i:                                        ; preds = %invoke.cont13
  %and5.i = and i32 %conv1.i, 2
  %tobool6.not.i = icmp eq i32 %and5.i, 0
  br i1 %tobool6.not.i, label %if.else9.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.else.i
  %fBuffer.i = getelementptr inbounds i8, ptr %call14, i64 10
  br label %invoke.cont19

if.else9.i:                                       ; preds = %if.else.i
  %fArray.i = getelementptr inbounds %"class.icu_75::UnicodeString", ptr %call14, i64 0, i32 1, i32 0, i32 3
  %7 = load ptr, ptr %fArray.i, align 8
  br label %invoke.cont19

invoke.cont19:                                    ; preds = %if.else9.i, %if.then7.i, %invoke.cont13
  %retval.0.i = phi ptr [ %fBuffer.i, %if.then7.i ], [ %7, %if.else9.i ], [ null, %invoke.cont13 ]
  %cmp.i.i = icmp slt i16 %6, 0
  %8 = ashr i16 %6, 5
  %shr.i.i = sext i16 %8 to i32
  %fLength.i = getelementptr inbounds %"class.icu_75::UnicodeString", ptr %call14, i64 0, i32 1, i32 0, i32 1
  %9 = load i32, ptr %fLength.i, align 4
  %cond.i = select i1 %cmp.i.i, i32 %9, i32 %shr.i.i
  invoke void @usrc_writeStringAsASCII(ptr noundef %f, ptr noundef %retval.0.i, i32 noundef %cond.i, i32 poison)
          to label %invoke.cont21 unwind label %lpad.loopexit.split-lp

invoke.cont21:                                    ; preds = %invoke.cont19
  %10 = call i64 @fwrite(ptr nonnull @.str.7, i64 2, i64 1, ptr %f)
  br label %while.cond.outer, !llvm.loop !6

if.else:                                          ; preds = %while.body
  %11 = load i32, ptr %codepointEnd.i, align 4
  %call29 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.31, i32 noundef %2, i32 noundef %11)
  br label %while.cond, !llvm.loop !6

while.end:                                        ; preds = %invoke.cont4
  %12 = call i64 @fwrite(ptr nonnull @.str.32, i64 2, i64 1, ptr %f)
  call void @_ZN6icu_7518UnicodeSetIteratorD1Ev(ptr noundef nonnull align 8 dereferenceable(64) %it) #18
  ret void
}

declare void @_ZN6icu_7518UnicodeSetIteratorC1ERKNS_10UnicodeSetE(ptr noundef nonnull align 8 dereferenceable(64), ptr noundef nonnull align 8 dereferenceable(200)) unnamed_addr #5

declare noundef signext i8 @_ZN6icu_7518UnicodeSetIterator9nextRangeEv(ptr noundef nonnull align 8 dereferenceable(64)) local_unnamed_addr #5

declare noundef nonnull align 8 dereferenceable(64) ptr @_ZN6icu_7518UnicodeSetIterator9getStringEv(ptr noundef nonnull align 8 dereferenceable(64)) local_unnamed_addr #5

; Function Attrs: mustprogress uwtable
define void @usrc_writeStringAsASCII(ptr nocapture noundef %f, ptr nocapture noundef readonly %ptr, i32 noundef %length, i32 %0) local_unnamed_addr #1 personality ptr @__gxx_personality_v0 {
entry:
  %u16result = alloca %"class.icu_75::UnicodeString", align 8
  %u8result = alloca %"class.std::__cxx11::basic_string", align 8
  %s = alloca [2 x i8], align 1
  %fputc = tail call i32 @fputc(i32 34, ptr %f)
  %cmp25 = icmp sgt i32 %length, 0
  br i1 %cmp25, label %do.body.lr.ph, label %while.end

do.body.lr.ph:                                    ; preds = %entry
  %fUnion2.i = getelementptr inbounds %"class.icu_75::UnicodeString", ptr %u16result, i64 0, i32 1
  %arrayinit.element = getelementptr inbounds i8, ptr %s, i64 1
  br label %do.body

do.body:                                          ; preds = %do.body.lr.ph, %if.end28
  %i.026 = phi i32 [ 0, %do.body.lr.ph ], [ %i.123, %if.end28 ]
  %inc = add nsw i32 %i.026, 1
  %idxprom = sext i32 %i.026 to i64
  %arrayidx = getelementptr inbounds i16, ptr %ptr, i64 %idxprom
  %1 = load i16, ptr %arrayidx, align 2
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 64512
  %cmp1 = icmp ne i32 %and, 55296
  %cmp2.not = icmp eq i32 %inc, %length
  %or.cond = select i1 %cmp1, i1 true, i1 %cmp2.not
  br i1 %or.cond, label %do.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %idxprom3 = sext i32 %inc to i64
  %arrayidx4 = getelementptr inbounds i16, ptr %ptr, i64 %idxprom3
  %2 = load i16, ptr %arrayidx4, align 2
  %conv5 = zext i16 %2 to i32
  %and6 = and i32 %conv5, 64512
  %cmp7 = icmp eq i32 %and6, 56320
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %land.lhs.true
  %inc9 = add nsw i32 %i.026, 2
  %shl = shl nuw nsw i32 %conv, 10
  %add = add nsw i32 %shl, -56613888
  %sub = add nuw nsw i32 %add, %conv5
  br label %if.else

do.end:                                           ; preds = %do.body
  %cmp12 = icmp eq i16 %1, 34
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %do.end
  %3 = call i64 @fwrite(ptr nonnull @.str.39, i64 2, i64 1, ptr %f)
  br label %if.end28

if.else:                                          ; preds = %land.lhs.true, %if.then8, %do.end
  %i.124 = phi i32 [ %inc, %do.end ], [ %inc, %land.lhs.true ], [ %inc9, %if.then8 ]
  %cp.022 = phi i32 [ %conv, %do.end ], [ %conv, %land.lhs.true ], [ %sub, %if.then8 ]
  %call15 = call noundef signext i8 @_ZN6icu_7511ICU_Utility13isUnprintableEi(i32 noundef %cp.022)
  %tobool.not = icmp eq i8 %call15, 0
  br i1 %tobool.not, label %if.else24, label %if.then16

if.then16:                                        ; preds = %if.else
  store ptr getelementptr inbounds ({ [13 x ptr] }, ptr @_ZTVN6icu_7513UnicodeStringE, i64 0, inrange i32 0, i64 2), ptr %u16result, align 8
  store i16 2, ptr %fUnion2.i, align 8
  %call17 = invoke noundef signext i8 @_ZN6icu_7511ICU_Utility17escapeUnprintableERNS_13UnicodeStringEi(ptr noundef nonnull align 8 dereferenceable(64) %u16result, i32 noundef %cp.022)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then16
  call void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev(ptr noundef nonnull align 8 dereferenceable(32) %u8result) #18
  %call20 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZNK6icu_7513UnicodeString12toUTF8StringINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERT_S9_(ptr noundef nonnull align 8 dereferenceable(64) %u16result, ptr noundef nonnull align 8 dereferenceable(32) %u8result)
          to label %invoke.cont19 unwind label %lpad18

invoke.cont19:                                    ; preds = %invoke.cont
  %call21 = call noundef ptr @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %u8result) #18
  %fputs18 = call i32 @fputs(ptr %call21, ptr %f)
  call void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(ptr noundef nonnull align 8 dereferenceable(32) %u8result) #18
  call void @_ZN6icu_7513UnicodeStringD1Ev(ptr noundef nonnull align 8 dereferenceable(64) %u16result) #18
  br label %if.end28

lpad:                                             ; preds = %if.then16
  %4 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup

lpad18:                                           ; preds = %invoke.cont
  %5 = landingpad { ptr, i32 }
          cleanup
  call void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(ptr noundef nonnull align 8 dereferenceable(32) %u8result) #18
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad18, %lpad
  %.pn = phi { ptr, i32 } [ %5, %lpad18 ], [ %4, %lpad ]
  call void @_ZN6icu_7513UnicodeStringD1Ev(ptr noundef nonnull align 8 dereferenceable(64) %u16result) #18
  resume { ptr, i32 } %.pn

if.else24:                                        ; preds = %if.else
  %conv25 = trunc i32 %cp.022 to i8
  store i8 %conv25, ptr %s, align 1
  store i8 0, ptr %arrayinit.element, align 1
  %fputs = call i32 @fputs(ptr nonnull %s, ptr %f)
  br label %if.end28

if.end28:                                         ; preds = %invoke.cont19, %if.else24, %if.then13
  %i.123 = phi i32 [ %i.124, %invoke.cont19 ], [ %i.124, %if.else24 ], [ %inc, %if.then13 ]
  %cmp = icmp slt i32 %i.123, %length
  br i1 %cmp, label %do.body, label %while.end, !llvm.loop !7

while.end:                                        ; preds = %if.end28, %entry
  %fputc16 = call i32 @fputc(i32 34, ptr %f)
  ret void
}

; Function Attrs: nounwind
declare void @_ZN6icu_7518UnicodeSetIteratorD1Ev(ptr noundef nonnull align 8 dereferenceable(64)) unnamed_addr #11

; Function Attrs: mustprogress uwtable
define void @usrc_writeUCPMap(ptr nocapture noundef %f, ptr noundef %pMap, ptr noundef %valueNameGetter, i32 noundef %syntax) local_unnamed_addr #1 {
entry:
  %value = alloca i32, align 4
  %0 = tail call i64 @fwrite(ptr nonnull @.str.33, i64 71, i64 1, ptr %f)
  %1 = tail call i64 @fwrite(ptr nonnull @.str.29, i64 11, i64 1, ptr %f)
  %call210 = call i32 @ucpmap_getRange_75(ptr noundef %pMap, i32 noundef 0, i32 noundef 0, i32 noundef 0, ptr noundef null, ptr noundef null, ptr noundef nonnull %value)
  %cmp11 = icmp sgt i32 %call210, -1
  br i1 %cmp11, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %entry
  %cmp3.not = icmp eq ptr %valueNameGetter, null
  br i1 %cmp3.not, label %while.body.us, label %while.body

while.body.us:                                    ; preds = %while.body.lr.ph, %while.body.us
  %call213.us = phi i32 [ %call2.us, %while.body.us ], [ %call210, %while.body.lr.ph ]
  %start.012.us = phi i32 [ %add.us, %while.body.us ], [ 0, %while.body.lr.ph ]
  %2 = load i32, ptr %value, align 4
  %call6.us = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.35, i32 noundef %start.012.us, i32 noundef %call213.us, i32 noundef %2)
  %add.us = add nuw nsw i32 %call213.us, 1
  %call2.us = call i32 @ucpmap_getRange_75(ptr noundef %pMap, i32 noundef %add.us, i32 noundef 0, i32 noundef 0, ptr noundef null, ptr noundef null, ptr noundef nonnull %value)
  %cmp.us = icmp sgt i32 %call2.us, -1
  br i1 %cmp.us, label %while.body.us, label %while.end, !llvm.loop !8

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %call213 = phi i32 [ %call2, %while.body ], [ %call210, %while.body.lr.ph ]
  %start.012 = phi i32 [ %add, %while.body ], [ 0, %while.body.lr.ph ]
  %3 = load i32, ptr %value, align 4
  %vtable = load ptr, ptr %valueNameGetter, align 8
  %vfn = getelementptr inbounds ptr, ptr %vtable, i64 2
  %4 = load ptr, ptr %vfn, align 8
  %call4 = call noundef ptr %4(ptr noundef nonnull align 8 dereferenceable(8) %valueNameGetter, i32 noundef %3)
  %5 = load i32, ptr %value, align 4
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull @.str.34, i32 noundef %start.012, i32 noundef %call213, i32 noundef %5, ptr noundef %call4)
  %add = add nuw nsw i32 %call213, 1
  %call2 = call i32 @ucpmap_getRange_75(ptr noundef %pMap, i32 noundef %add, i32 noundef 0, i32 noundef 0, ptr noundef null, ptr noundef null, ptr noundef nonnull %value)
  %cmp = icmp sgt i32 %call2, -1
  br i1 %cmp, label %while.body, label %while.end, !llvm.loop !8

while.end:                                        ; preds = %while.body, %while.body.us, %entry
  %6 = call i64 @fwrite(ptr nonnull @.str.32, i64 2, i64 1, ptr %f)
  ret void
}

declare i32 @ucpmap_getRange_75(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree nounwind uwtable
define void @usrc_writeArrayOfMostlyInvChars(ptr nocapture noundef %f, ptr noundef readonly %prefix, ptr nocapture noundef readonly %p, i32 noundef %length, ptr noundef readonly %postfix) local_unnamed_addr #9 {
entry:
  %cmp.not = icmp eq ptr %prefix, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv = sext i32 %length to i64
  %call = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull %prefix, i64 noundef %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp125 = icmp sgt i32 %length, 0
  br i1 %cmp125, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.end
  %wide.trip.count = zext nneg i32 %length to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end24
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end24 ]
  %prev.028 = phi i32 [ -1, %for.body.preheader ], [ %conv2, %if.end24 ]
  %prev2.027 = phi i32 [ -1, %for.body.preheader ], [ %prev.028, %if.end24 ]
  %col.026 = phi i32 [ 0, %for.body.preheader ], [ %inc27, %if.end24 ]
  %arrayidx = getelementptr inbounds i8, ptr %p, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %conv2 = zext i8 %0 to i32
  %cmp3.not = icmp eq i64 %indvars.iv, 0
  br i1 %cmp3.not, label %if.end24, label %if.then4

if.then4:                                         ; preds = %for.body
  %cmp5 = icmp sgt i32 %col.026, 31
  br i1 %cmp5, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then4
  %cmp6 = icmp sgt i32 %col.026, 23
  %cmp7 = icmp sgt i32 %prev2.027, 31
  %or.cond = select i1 %cmp6, i1 %cmp7, i1 false
  %cmp9 = icmp eq i32 %prev.028, 0
  %or.cond1 = select i1 %or.cond, i1 %cmp9, i1 false
  br i1 %or.cond1, label %if.then20, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %cmp11 = icmp sgt i32 %col.026, 15
  br i1 %cmp11, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %lor.lhs.false10
  %cmp15 = icmp sgt i32 %prev.028, 31
  %or.cond2 = or i1 %cmp9, %cmp15
  %cmp17 = icmp ne i8 %0, 0
  %or.cond3 = select i1 %or.cond2, i1 %cmp17, i1 false
  %cmp19 = icmp ult i8 %0, 32
  %or.cond4 = select i1 %or.cond3, i1 %cmp19, i1 false
  br i1 %or.cond4, label %if.then20, label %if.else

if.then20:                                        ; preds = %land.lhs.true12, %lor.lhs.false, %if.then4
  %1 = tail call i64 @fwrite(ptr nonnull @.str.7, i64 2, i64 1, ptr %f)
  br label %if.end24

if.else:                                          ; preds = %land.lhs.true12, %lor.lhs.false10
  %call22 = tail call i32 @fputc(i32 noundef 44, ptr noundef %f)
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %if.else, %for.body
  %col.1 = phi i32 [ 0, %if.then20 ], [ %col.026, %if.else ], [ %col.026, %for.body ]
  %cmp25 = icmp ult i8 %0, 32
  %cond = select i1 %cmp25, ptr @.str.36, ptr @.str.37
  %call26 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %f, ptr noundef nonnull %cond, i32 noundef %conv2)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %inc27 = add nsw i32 %col.1, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !9

for.end:                                          ; preds = %if.end24, %if.end
  %cmp28.not = icmp eq ptr %postfix, null
  br i1 %cmp28.not, label %if.end31, label %if.then29

if.then29:                                        ; preds = %for.end
  %call30 = tail call i32 @fputs(ptr noundef nonnull %postfix, ptr noundef %f)
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %for.end
  ret void
}

declare noundef signext i8 @_ZN6icu_7511ICU_Utility13isUnprintableEi(i32 noundef) local_unnamed_addr #5

declare noundef signext i8 @_ZN6icu_7511ICU_Utility17escapeUnprintableERNS_13UnicodeStringEi(ptr noundef nonnull align 8 dereferenceable(64), i32 noundef) local_unnamed_addr #5

; Function Attrs: nounwind
declare void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev(ptr noundef nonnull align 8 dereferenceable(32)) unnamed_addr #11

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(32) ptr @_ZNK6icu_7513UnicodeString12toUTF8StringINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERT_S9_(ptr noundef nonnull align 8 dereferenceable(64) %this, ptr noundef nonnull align 8 dereferenceable(32) %result) local_unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %sbs = alloca %"class.icu_75::StringByteSink", align 8
  %fUnion.i.i = getelementptr inbounds %"class.icu_75::UnicodeString", ptr %this, i64 0, i32 1
  %0 = load i16, ptr %fUnion.i.i, align 8
  %cmp.i.i = icmp slt i16 %0, 0
  %1 = ashr i16 %0, 5
  %shr.i.i = sext i16 %1 to i32
  %fLength.i = getelementptr inbounds %"class.icu_75::UnicodeString", ptr %this, i64 0, i32 1, i32 0, i32 1
  %2 = load i32, ptr %fLength.i, align 4
  %cond.i = select i1 %cmp.i.i, i32 %2, i32 %shr.i.i
  store ptr getelementptr inbounds ({ [7 x ptr] }, ptr @_ZTVN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE, i64 0, inrange i32 0, i64 2), ptr %sbs, align 8
  %dest_.i = getelementptr inbounds %"class.icu_75::StringByteSink", ptr %sbs, i64 0, i32 1
  store ptr %result, ptr %dest_.i, align 8
  %cmp.i = icmp sgt i32 %cond.i, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPS6_i.exit

land.lhs.true.i:                                  ; preds = %entry
  %conv.i = zext nneg i32 %cond.i to i64
  %call.i = tail call noundef i64 @_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32) %result) #18
  %call2.i = tail call noundef i64 @_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6lengthEv(ptr noundef nonnull align 8 dereferenceable(32) %result) #18
  %sub.i = sub i64 %call.i, %call2.i
  %cmp3.i = icmp ult i64 %sub.i, %conv.i
  br i1 %cmp3.i, label %if.then.i, label %_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPS6_i.exit

if.then.i:                                        ; preds = %land.lhs.true.i
  %call4.i = tail call noundef i64 @_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6lengthEv(ptr noundef nonnull align 8 dereferenceable(32) %result) #18
  %add.i = add i64 %call4.i, %conv.i
  invoke void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32) %result, i64 noundef %add.i)
          to label %_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPS6_i.exit unwind label %lpad.i

common.resume:                                    ; preds = %lpad, %lpad.i
  %common.resume.op = phi { ptr, i32 } [ %3, %lpad.i ], [ %4, %lpad ]
  call void @_ZN6icu_758ByteSinkD2Ev(ptr noundef nonnull align 8 dereferenceable(8) %sbs) #18
  resume { ptr, i32 } %common.resume.op

lpad.i:                                           ; preds = %if.then.i
  %3 = landingpad { ptr, i32 }
          cleanup
  br label %common.resume

_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPS6_i.exit: ; preds = %entry, %land.lhs.true.i, %if.then.i
  invoke void @_ZNK6icu_7513UnicodeString6toUTF8ERNS_8ByteSinkE(ptr noundef nonnull align 8 dereferenceable(64) %this, ptr noundef nonnull align 8 dereferenceable(8) %sbs)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPS6_i.exit
  call void @_ZN6icu_758ByteSinkD2Ev(ptr noundef nonnull align 8 dereferenceable(8) %sbs) #18
  ret ptr %result

lpad:                                             ; preds = %_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPS6_i.exit
  %4 = landingpad { ptr, i32 }
          cleanup
  br label %common.resume
}

; Function Attrs: nounwind
declare noundef ptr @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32)) local_unnamed_addr #11

; Function Attrs: nounwind
declare void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(ptr noundef nonnull align 8 dereferenceable(32)) unnamed_addr #11

; Function Attrs: nounwind
declare void @_ZN6icu_7513UnicodeStringD1Ev(ptr noundef nonnull align 8 dereferenceable(64)) unnamed_addr #11

declare void @__cxa_pure_virtual() unnamed_addr

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: readwrite)
declare ptr @strcpy(ptr noalias noundef returned writeonly, ptr noalias nocapture noundef readonly) local_unnamed_addr #13

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #14

; Function Attrs: nofree nounwind
declare noalias noundef ptr @fopen(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #10

declare void @_ZNK6icu_7513UnicodeString6toUTF8ERNS_8ByteSinkE(ptr noundef nonnull align 8 dereferenceable(64), ptr noundef nonnull align 8 dereferenceable(8)) local_unnamed_addr #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  tail call void @_ZN6icu_758ByteSinkD2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this) #18
  ret void
}

; Function Attrs: nounwind
declare noundef i64 @_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32)) local_unnamed_addr #11

; Function Attrs: nounwind
declare noundef i64 @_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6lengthEv(ptr noundef nonnull align 8 dereferenceable(32)) local_unnamed_addr #11

declare void @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32), i64 noundef) local_unnamed_addr #5

; Function Attrs: nounwind
declare void @_ZN6icu_758ByteSinkD2Ev(ptr noundef nonnull align 8 dereferenceable(8)) unnamed_addr #11

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED0Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  tail call void @_ZN6icu_758ByteSinkD2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this) #18
  tail call void @_ZN6icu_757UMemorydlEPv(ptr noundef nonnull %this) #18
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN6icu_7514StringByteSinkINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE6AppendEPKci(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %data, i32 noundef %n) unnamed_addr #1 comdat align 2 {
entry:
  %dest_ = getelementptr inbounds %"class.icu_75::StringByteSink", ptr %this, i64 0, i32 1
  %0 = load ptr, ptr %dest_, align 8
  %conv = sext i32 %n to i64
  %call = tail call noundef nonnull align 8 dereferenceable(32) ptr @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKcm(ptr noundef nonnull align 8 dereferenceable(32) %0, ptr noundef %data, i64 noundef %conv)
  ret void
}

declare noundef ptr @_ZN6icu_758ByteSink15GetAppendBufferEiiPciPi(ptr noundef nonnull align 8 dereferenceable(8), i32 noundef, i32 noundef, ptr noundef, i32 noundef, ptr noundef) unnamed_addr #5

declare void @_ZN6icu_758ByteSink5FlushEv(ptr noundef nonnull align 8 dereferenceable(8)) unnamed_addr #5

; Function Attrs: nounwind
declare void @_ZN6icu_757UMemorydlEPv(ptr noundef) local_unnamed_addr #11

declare noundef nonnull align 8 dereferenceable(32) ptr @_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendEPKcm(ptr noundef nonnull align 8 dereferenceable(32), ptr noundef, i64 noundef) local_unnamed_addr #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.fshl.i32(i32, i32, i32) #15

; Function Attrs: nofree nounwind
declare noundef i64 @fwrite(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #16

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #15

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #17

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #17

attributes #0 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress noreturn nounwind memory(inaccessiblemem: write) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { cold noreturn nounwind memory(inaccessiblemem: write) }
attributes #9 = { mustprogress nofree nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { mustprogress nofree nounwind willreturn memory(argmem: readwrite) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { mustprogress nofree nounwind willreturn memory(argmem: read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #16 = { nofree nounwind }
attributes #17 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #18 = { nounwind }
attributes #19 = { allocsize(0) }
attributes #20 = { noreturn nounwind }
attributes #21 = { nounwind willreturn memory(read) }
attributes #22 = { cold }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
